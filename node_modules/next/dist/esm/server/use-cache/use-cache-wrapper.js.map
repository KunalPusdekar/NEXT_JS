{"version":3,"sources":["../../../src/server/use-cache/use-cache-wrapper.ts"],"sourcesContent":["import type { DeepReadonly } from '../../shared/lib/deep-readonly'\n/* eslint-disable import/no-extraneous-dependencies */\nimport {\n  renderToReadableStream,\n  decodeReply,\n  createTemporaryReferenceSet as createServerTemporaryReferenceSet,\n} from 'react-server-dom-webpack/server.edge'\n/* eslint-disable import/no-extraneous-dependencies */\nimport {\n  createFromReadableStream,\n  encodeReply,\n  createTemporaryReferenceSet as createClientTemporaryReferenceSet,\n} from 'react-server-dom-webpack/client.edge'\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport type {\n  UseCacheStore,\n  WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport { runInCleanSnapshot } from '../app-render/clean-async-snapshot.external'\n\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\n\nimport {\n  getClientReferenceManifestSingleton,\n  getServerModuleMap,\n} from '../app-render/encryption-utils'\nimport { defaultCacheLife } from './cache-life'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\ntype CacheEntry = {\n  value: ReadableStream\n  // In-memory caches are fragile and should not use stale-while-revalidate\n  // semantics on the caches because it's not worth warming up an entry that's\n  // likely going to get evicted before we get to use it anyway. However,\n  // we also don't want to reuse a stale entry for too long so stale entries\n  // should be considered expired/missing in such CacheHandlers.\n  stale: boolean\n  tags: string[]\n  revalidate: number\n}\n\ninterface CacheHandler {\n  get(\n    cacheKey: string | ArrayBuffer,\n    implicitTags: string[]\n  ): Promise<undefined | CacheEntry>\n  set(cacheKey: string | ArrayBuffer, value: Promise<CacheEntry>): Promise<void>\n}\n\nconst cacheHandlerMap: Map<string, CacheHandler> = new Map()\n\n// TODO: Move default implementation to be injectable.\nconst defaultCacheStorage: Map<string, CacheEntry> = new Map()\ncacheHandlerMap.set('default', {\n  async get(cacheKey: string | ArrayBuffer): Promise<undefined | CacheEntry> {\n    // TODO: Implement proper caching.\n    if (typeof cacheKey === 'string') {\n      const entry = defaultCacheStorage.get(cacheKey)\n      if (entry !== undefined) {\n        const [returnStream, newSaved] = entry.value.tee()\n        entry.value = newSaved\n        return {\n          value: returnStream,\n          stale: false,\n          revalidate: entry.revalidate,\n          tags: entry.tags,\n        }\n      }\n    } else {\n      // TODO: Handle binary keys.\n    }\n    return undefined\n  },\n  async set(cacheKey: string | ArrayBuffer, promise: Promise<CacheEntry>) {\n    const entry = await promise\n    // TODO: Implement proper caching.\n    if (typeof cacheKey === 'string') {\n      defaultCacheStorage.set(cacheKey, entry)\n    } else {\n      // TODO: Handle binary keys.\n      await entry.value.cancel()\n    }\n  },\n})\n\nfunction generateCacheEntry(\n  workStore: WorkStore,\n  outerWorkUnitStore: WorkUnitStore | undefined,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  cacheHandler: CacheHandler,\n  serializedCacheKey: string | ArrayBuffer,\n  encodedArguments: FormData | string,\n  fn: any\n): Promise<ReadableStream> {\n  // We need to run this inside a clean AsyncLocalStorage snapshot so that the cache\n  // generation cannot read anything from the context we're currently executing which\n  // might include request specific things like cookies() inside a React.cache().\n  // Note: It is important that we await at least once before this because it lets us\n  // pop out of any stack specific contexts as well - aka \"Sync\" Local Storage.\n  return runInCleanSnapshot(\n    generateCacheEntryWithRestoredWorkStore,\n    workStore,\n    outerWorkUnitStore,\n    clientReferenceManifest,\n    cacheHandler,\n    serializedCacheKey,\n    encodedArguments,\n    fn\n  )\n}\n\nfunction generateCacheEntryWithRestoredWorkStore(\n  workStore: WorkStore,\n  outerWorkUnitStore: WorkUnitStore | undefined,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  cacheHandler: CacheHandler,\n  serializedCacheKey: string | ArrayBuffer,\n  encodedArguments: FormData | string,\n  fn: any\n) {\n  // Since we cleared the AsyncLocalStorage we need to restore the workStore.\n  // Note: We explicitly don't restore the RequestStore nor the PrerenderStore.\n  // We don't want any request specific information leaking an we don't want to create a\n  // bloated fake request mock for every cache call. So any feature that currently lives\n  // in RequestStore but should be available to Caches need to move to WorkStore.\n  // PrerenderStore is not needed inside the cache scope because the outer most one will\n  // be the one to report its result to the outer Prerender.\n  return workAsyncStorage.run(\n    workStore,\n    generateCacheEntryWithCacheContext,\n    workStore,\n    outerWorkUnitStore,\n    clientReferenceManifest,\n    cacheHandler,\n    serializedCacheKey,\n    encodedArguments,\n    fn\n  )\n}\n\nfunction generateCacheEntryWithCacheContext(\n  workStore: WorkStore,\n  outerWorkUnitStore: WorkUnitStore | undefined,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  cacheHandler: CacheHandler,\n  serializedCacheKey: string | ArrayBuffer,\n  encodedArguments: FormData | string,\n  fn: any\n) {\n  // Initialize the Store for this Cache entry.\n  const cacheStore: UseCacheStore = {\n    type: 'cache',\n    phase: 'render',\n    implicitTags:\n      outerWorkUnitStore === undefined ||\n      outerWorkUnitStore.type === 'unstable-cache'\n        ? []\n        : outerWorkUnitStore.implicitTags,\n    revalidate: defaultCacheLife.revalidate,\n    explicitRevalidate: undefined,\n    tags: null,\n  }\n  return workUnitAsyncStorage.run(\n    cacheStore,\n    generateCacheEntryImpl,\n    workStore,\n    outerWorkUnitStore,\n    cacheStore,\n    clientReferenceManifest,\n    cacheHandler,\n    serializedCacheKey,\n    encodedArguments,\n    fn\n  )\n}\n\nfunction propagateCacheLifeAndTags(\n  workUnitStore: WorkUnitStore | undefined,\n  entry: CacheEntry\n): void {\n  if (\n    workUnitStore &&\n    (workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'prerender' ||\n      workUnitStore.type === 'prerender-ppr' ||\n      workUnitStore.type === 'prerender-legacy')\n  ) {\n    // Propagate tags and revalidate upwards\n    const outerTags = workUnitStore.tags ?? (workUnitStore.tags = [])\n    const entryTags = entry.tags\n    for (let i = 0; i < entryTags.length; i++) {\n      const tag = entryTags[i]\n      if (!outerTags.includes(tag)) {\n        outerTags.push(tag)\n      }\n    }\n    if (workUnitStore.revalidate > entry.revalidate) {\n      workUnitStore.revalidate = entry.revalidate\n    }\n  }\n}\n\nasync function collectResult(\n  savedStream: ReadableStream,\n  outerWorkUnitStore: WorkUnitStore | undefined,\n  innerCacheStore: UseCacheStore,\n  errors: Array<unknown> // This is a live array that gets pushed into.\n): Promise<CacheEntry> {\n  // We create a buffered stream that collects all chunks until the end to\n  // ensure that RSC has finished rendering and therefore we have collected\n  // all tags. In the future the RSC API might allow for the equivalent of\n  // the allReady Promise that exists on SSR streams.\n  //\n  // If something errored or rejected anywhere in the render, we close\n  // the stream as errored. This lets a CacheHandler choose to save the\n  // partial result up until that point for future hits for a while to avoid\n  // unnecessary retries or not to retry. We use the end of the stream for\n  // this to avoid another complicated side-channel. A receiver has to consider\n  // that the stream might also error for other reasons anyway such as losing\n  // connection.\n\n  const buffer: any[] = []\n  const reader = savedStream.getReader()\n  for (let entry; !(entry = await reader.read()).done; ) {\n    buffer.push(entry.value)\n  }\n\n  let idx = 0\n  const bufferStream = new ReadableStream({\n    pull(controller) {\n      if (idx < buffer.length) {\n        controller.enqueue(buffer[idx++])\n      } else if (errors.length > 0) {\n        // TODO: Should we use AggregateError here?\n        controller.error(errors[0])\n      } else {\n        controller.close()\n      }\n    },\n  })\n\n  const collectedTags = innerCacheStore.tags\n  // If cacheLife() was used to set an explicit revalidate time we use that.\n  // Otherwise, we use the lowest of all inner fetch()/unstable_cache() or nested \"use cache\".\n  // If they're lower than our default.\n  const collectedRevalidate =\n    innerCacheStore.explicitRevalidate !== undefined\n      ? innerCacheStore.explicitRevalidate\n      : innerCacheStore.revalidate\n\n  const entry = {\n    value: bufferStream,\n    stale: false, // TODO: rm\n    tags: collectedTags === null ? [] : collectedTags,\n    revalidate: collectedRevalidate,\n  }\n  // Propagate tags/revalidate to the parent context.\n  propagateCacheLifeAndTags(outerWorkUnitStore, entry)\n  return entry\n}\n\nasync function generateCacheEntryImpl(\n  workStore: WorkStore,\n  outerWorkUnitStore: WorkUnitStore | undefined,\n  innerCacheStore: UseCacheStore,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  cacheHandler: CacheHandler,\n  serializedCacheKey: string | ArrayBuffer,\n  encodedArguments: FormData | string,\n  fn: any\n): Promise<ReadableStream> {\n  const temporaryReferences = createServerTemporaryReferenceSet()\n\n  const [, , args] = await decodeReply<any[]>(\n    encodedArguments,\n    getServerModuleMap(),\n    {\n      temporaryReferences,\n    }\n  )\n\n  // Invoke the inner function to load a new result.\n  const result = fn.apply(null, args)\n\n  let errors: Array<unknown> = []\n\n  const stream = renderToReadableStream(\n    result,\n    clientReferenceManifest.clientModules,\n    {\n      environmentName: 'Cache',\n      temporaryReferences,\n      onError(error: unknown) {\n        // Report the error.\n        console.error(error)\n        errors.push(error)\n      },\n    }\n  )\n\n  const [returnStream, savedStream] = stream.tee()\n\n  const cacheEntry = collectResult(\n    savedStream,\n    outerWorkUnitStore,\n    innerCacheStore,\n    errors\n  )\n\n  if (!workStore.pendingRevalidateWrites) {\n    workStore.pendingRevalidateWrites = []\n  }\n\n  const promise = cacheHandler.set(serializedCacheKey, cacheEntry)\n\n  workStore.pendingRevalidateWrites.push(promise)\n\n  // Return the stream as we're creating it. This means that if it ends up\n  // erroring we cannot return a stale-while-error version but it allows\n  // streaming back the result earlier.\n  return returnStream\n}\n\nexport function cache(kind: string, id: string, fn: any) {\n  if (!process.env.__NEXT_DYNAMIC_IO) {\n    throw new Error(\n      '\"use cache\" is only available with the experimental.dynamicIO config.'\n    )\n  }\n  const cacheHandler = cacheHandlerMap.get(kind)\n  if (cacheHandler === undefined) {\n    throw new Error('Unknown cache handler: ' + kind)\n  }\n  const name = fn.name\n  const cachedFn = {\n    [name]: async function (...args: any[]) {\n      const workStore = workAsyncStorage.getStore()\n      if (workStore === undefined) {\n        throw new Error(\n          '\"use cache\" cannot be used outside of App Router. Expected a WorkStore.'\n        )\n      }\n\n      const workUnitStore = workUnitAsyncStorage.getStore()\n\n      const implicitTags =\n        workUnitStore === undefined || workUnitStore.type === 'unstable-cache'\n          ? []\n          : workUnitStore.implicitTags\n\n      // Because the Action ID is not yet unique per implementation of that Action we can't\n      // safely reuse the results across builds yet. In the meantime we add the buildId to the\n      // arguments as a seed to ensure they're not reused. Remove this once Action IDs hash\n      // the implementation.\n      const buildId = workStore.buildId\n\n      const temporaryReferences = createClientTemporaryReferenceSet()\n      const encodedArguments: FormData | string = await encodeReply(\n        [buildId, id, args],\n        {\n          temporaryReferences,\n        }\n      )\n\n      const serializedCacheKey =\n        typeof encodedArguments === 'string'\n          ? // Fast path for the simple case for simple inputs. We let the CacheHandler\n            // Convert it to an ArrayBuffer if it wants to.\n            encodedArguments\n          : // The FormData might contain binary data that is not valid UTF-8 so this\n            // cannot be a string in this case. I.e. .text() is not valid here and it\n            // is not valid to use TextDecoder on this result.\n            await new Response(encodedArguments).arrayBuffer()\n\n      let entry: undefined | CacheEntry = await cacheHandler.get(\n        serializedCacheKey,\n        implicitTags\n      )\n\n      // Get the clientReferenceManifestSingleton while we're still in the outer Context.\n      // In case getClientReferenceManifestSingleton is implemented using AsyncLocalStorage.\n      const clientReferenceManifestSingleton =\n        getClientReferenceManifestSingleton()\n\n      let stream\n      if (\n        entry === undefined ||\n        (entry.stale && workStore.isStaticGeneration)\n      ) {\n        // Miss. Generate a new result.\n\n        // If the cache entry is stale and we're prerendering, we don't want to use the\n        // stale entry since it would unnecessarily need to shorten the lifetime of the\n        // prerender. We're not time constrained here so we can re-generated it now.\n\n        // We need to run this inside a clean AsyncLocalStorage snapshot so that the cache\n        // generation cannot read anything from the context we're currently executing which\n        // might include request specific things like cookies() inside a React.cache().\n        // Note: It is important that we await at least once before this because it lets us\n        // pop out of any stack specific contexts as well - aka \"Sync\" Local Storage.\n\n        stream = await generateCacheEntry(\n          workStore,\n          workUnitStore,\n          clientReferenceManifestSingleton,\n          cacheHandler,\n          serializedCacheKey,\n          encodedArguments,\n          fn\n        )\n      } else {\n        stream = entry.value\n\n        propagateCacheLifeAndTags(workUnitStore, entry)\n\n        if (entry.stale) {\n          // If this is stale, and we're not in a prerender (i.e. this is dynamic render),\n          // then we should warm up the cache with a fresh revalidated entry.\n          const ignoredStream = await generateCacheEntry(\n            workStore,\n            workUnitStore,\n            clientReferenceManifestSingleton,\n            cacheHandler,\n            serializedCacheKey,\n            encodedArguments,\n            fn\n          )\n          await ignoredStream.cancel()\n        }\n      }\n\n      // Logs are replayed even if it's a hit - to ensure we see them on the client eventually.\n      // If we didn't then the client wouldn't see the logs if it was seeded from a prewarm that\n      // never made it to the client. However, this also means that you see logs even when the\n      // cached function isn't actually re-executed. We should instead ensure prewarms always\n      // make it to the client. Another issue is that this will cause double logging in the\n      // server terminal. Once while generating the cache entry and once when replaying it on\n      // the server, which is required to pick it up for replaying again on the client.\n      const replayConsoleLogs = true\n\n      const ssrManifest = {\n        // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n        // to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted\n        // which themselves will handle the preloading.\n        moduleLoading: null,\n        moduleMap: isEdgeRuntime\n          ? clientReferenceManifestSingleton.edgeRscModuleMapping\n          : clientReferenceManifestSingleton.rscModuleMapping,\n      }\n\n      return createFromReadableStream(stream, {\n        ssrManifest,\n        temporaryReferences,\n        replayConsoleLogs,\n        environmentName: 'Cache',\n      })\n    },\n  }[name]\n  return cachedFn\n}\n"],"names":["renderToReadableStream","decodeReply","createTemporaryReferenceSet","createServerTemporaryReferenceSet","createFromReadableStream","encodeReply","createClientTemporaryReferenceSet","workAsyncStorage","workUnitAsyncStorage","runInCleanSnapshot","getClientReferenceManifestSingleton","getServerModuleMap","defaultCacheLife","isEdgeRuntime","process","env","NEXT_RUNTIME","cacheHandlerMap","Map","defaultCacheStorage","set","get","cacheKey","entry","undefined","returnStream","newSaved","value","tee","stale","revalidate","tags","promise","cancel","generateCacheEntry","workStore","outerWorkUnitStore","clientReferenceManifest","cacheHandler","serializedCacheKey","encodedArguments","fn","generateCacheEntryWithRestoredWorkStore","run","generateCacheEntryWithCacheContext","cacheStore","type","phase","implicitTags","explicitRevalidate","generateCacheEntryImpl","propagateCacheLifeAndTags","workUnitStore","outerTags","entryTags","i","length","tag","includes","push","collectResult","savedStream","innerCacheStore","errors","buffer","reader","getReader","read","done","idx","bufferStream","ReadableStream","pull","controller","enqueue","error","close","collectedTags","collectedRevalidate","temporaryReferences","args","result","apply","stream","clientModules","environmentName","onError","console","cacheEntry","pendingRevalidateWrites","cache","kind","id","__NEXT_DYNAMIC_IO","Error","name","cachedFn","getStore","buildId","Response","arrayBuffer","clientReferenceManifestSingleton","isStaticGeneration","ignoredStream","replayConsoleLogs","ssrManifest","moduleLoading","moduleMap","edgeRscModuleMapping","rscModuleMapping"],"mappings":"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"}