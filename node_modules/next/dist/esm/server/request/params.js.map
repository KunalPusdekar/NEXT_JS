{"version":3,"sources":["../../../src/server/request/params.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { FallbackRouteParams } from './fallback-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  abortAndThrowOnSynchronousDynamicDataAccess,\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStorePPR,\n  type PrerenderStoreLegacy,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { makeResolvedReactPromise, describeStringPropertyAccess } from './utils'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-loger'\n\nexport type Params = Record<string, string | Array<string> | undefined>\n\n/**\n * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n * The `UnsafeUnwrappedParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n *\n * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n *\n * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n *\n * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n *\n * ```tsx\n * type Props = { params: Promise<{ id: string }>}\n *\n * export default async function Layout(props: Props) {\n *  const directParams = (props.params as unknown as UnsafeUnwrappedParams<typeof props.params>)\n *  return ...\n * }\n * ```\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedParams<P> =\n  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n\nexport function createPrerenderParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  return createPrerenderParams(underlyingParams, workStore)\n}\n\nexport function createRenderParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  return createRenderParams(underlyingParams, workStore)\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport type CreateServerParamsForMetadata = typeof createServerParamsForMetadata\nexport const createServerParamsForMetadata = createServerParamsForServerSegment\n\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  if (workStore.isStaticGeneration) {\n    return createPrerenderParams(underlyingParams, workStore)\n  } else {\n    return createRenderParams(underlyingParams, workStore)\n  }\n}\n\nexport function createServerParamsForServerSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  if (workStore.isStaticGeneration) {\n    return createPrerenderParams(underlyingParams, workStore)\n  } else {\n    return createRenderParams(underlyingParams, workStore)\n  }\n}\n\nexport function createPrerenderParamsForClientSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (prerenderStore && prerenderStore.type === 'prerender') {\n    const fallbackParams = workStore.fallbackRouteParams\n    if (fallbackParams) {\n      for (let key in underlyingParams) {\n        if (fallbackParams.has(key)) {\n          // This params object has one of more fallback params so we need to consider\n          // the awaiting of this params object \"dynamic\". Since we are in dynamicIO mode\n          // we encode this as a promise that never resolves\n          return makeHangingPromise()\n        }\n      }\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return makeResolvedReactPromise(underlyingParams)\n}\n\nfunction createPrerenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const fallbackParams = workStore.fallbackRouteParams\n  if (fallbackParams) {\n    let hasSomeFallbackParams = false\n    for (const key in underlyingParams) {\n      if (fallbackParams.has(key)) {\n        hasSomeFallbackParams = true\n        break\n      }\n    }\n\n    if (hasSomeFallbackParams) {\n      // params need to be treated as dynamic because we have at least one fallback param\n      const workUnitStore = workUnitAsyncStorage.getStore()\n      if (workUnitStore) {\n        if (workUnitStore.type === 'prerender') {\n          // We are in a dynamicIO (PPR or otherwise) prerender\n          return makeAbortingExoticParams(\n            underlyingParams,\n            workStore.route,\n            workUnitStore\n          )\n        } else if (\n          workUnitStore.type === 'prerender-legacy' ||\n          workUnitStore.type === 'prerender-ppr'\n        )\n          // We aren't in a dynamicIO prerender but we do have fallback params at this\n          // level so we need to make an erroring exotic params object which will postpone\n          // if you access the fallback params\n          return makeErroringExoticParams(\n            underlyingParams,\n            fallbackParams,\n            workStore,\n            workUnitStore\n          )\n      }\n      throw new InvariantError(\n        'createPrerenderParams called without a prerenderStore in scope. This is a bug in Next.js'\n      )\n    }\n  }\n\n  // We don't have any fallback params so we have an entirely static safe params object\n  return makeUntrackedExoticParams(underlyingParams)\n}\n\nfunction createRenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  if (process.env.NODE_ENV === 'development' && !workStore.isPrefetchRequest) {\n    return makeDynamicallyTrackedExoticParamsWithDevWarnings(\n      underlyingParams,\n      workStore\n    )\n  } else {\n    return makeUntrackedExoticParams(underlyingParams)\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nfunction makeAbortingExoticParams(\n  underlyingParams: Params,\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = makeHangingPromise<Params>()\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    switch (prop) {\n      // Object prototype\n      case 'hasOwnProperty':\n      case 'isPrototypeOf':\n      case 'propertyIsEnumerable':\n      case 'toString':\n      case 'valueOf':\n      case 'toLocaleString':\n\n      // Promise prototype\n      // fallthrough\n      case 'then':\n      case 'catch':\n      case 'finally':\n\n      // React Promise extension\n      // fallthrough\n      case 'status':\n\n      // Common tested properties\n      // fallthrough\n      case 'toJSON':\n      case '$$typeof':\n      case '__esModule': {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        break\n      }\n      default: {\n        Object.defineProperty(promise, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            abortAndThrowOnSynchronousDynamicDataAccess(\n              route,\n              expression,\n              prerenderStore\n            )\n          },\n          set(newValue) {\n            Object.defineProperty(promise, prop, {\n              value: newValue,\n              writable: true,\n              enumerable: true,\n            })\n          },\n          enumerable: true,\n          configurable: true,\n        })\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeErroringExoticParams(\n  underlyingParams: Params,\n  fallbackParams: FallbackRouteParams,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const augmentedUnderlying = { ...underlyingParams }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    switch (prop) {\n      // Object prototype\n      case 'hasOwnProperty':\n      case 'isPrototypeOf':\n      case 'propertyIsEnumerable':\n      case 'toString':\n      case 'valueOf':\n      case 'toLocaleString':\n\n      // Promise prototype\n      // fallthrough\n      case 'then':\n      case 'catch':\n      case 'finally':\n\n      // React Promise extension\n      // fallthrough\n      case 'status':\n\n      // Common tested properties\n      // fallthrough\n      case 'toJSON':\n      case '$$typeof':\n      case '__esModule': {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        break\n      }\n      default: {\n        if (fallbackParams.has(prop)) {\n          Object.defineProperty(augmentedUnderlying, prop, {\n            get() {\n              const expression = describeStringPropertyAccess('params', prop)\n              // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n              // for params is only dynamic when we're generating a fallback shell\n              // and even when `dynamic = \"error\"` we still support generating dynamic\n              // fallback shells\n              // TODO remove this comment when dynamicIO is the default since there\n              // will be no `dynamic = \"error\"`\n              if (prerenderStore.type === 'prerender-ppr') {\n                // PPR Prerender (no dynamicIO)\n                postponeWithTracking(\n                  workStore.route,\n                  expression,\n                  prerenderStore.dynamicTracking\n                )\n              } else {\n                // Legacy Prerender\n                throwToInterruptStaticGeneration(\n                  expression,\n                  workStore,\n                  prerenderStore\n                )\n              }\n            },\n            enumerable: true,\n          })\n          Object.defineProperty(promise, prop, {\n            get() {\n              const expression = describeStringPropertyAccess('params', prop)\n              // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n              // for params is only dynamic when we're generating a fallback shell\n              // and even when `dynamic = \"error\"` we still support generating dynamic\n              // fallback shells\n              // TODO remove this comment when dynamicIO is the default since there\n              // will be no `dynamic = \"error\"`\n              if (prerenderStore.type === 'prerender-ppr') {\n                // PPR Prerender (no dynamicIO)\n                postponeWithTracking(\n                  workStore.route,\n                  expression,\n                  prerenderStore.dynamicTracking\n                )\n              } else {\n                // Legacy Prerender\n                throwToInterruptStaticGeneration(\n                  expression,\n                  workStore,\n                  prerenderStore\n                )\n              }\n            },\n            set(newValue) {\n              Object.defineProperty(promise, prop, {\n                value: newValue,\n                writable: true,\n                enumerable: true,\n              })\n            },\n            enumerable: true,\n            configurable: true,\n          })\n        } else {\n          ;(promise as any)[prop] = underlyingParams[prop]\n        }\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedExoticParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    switch (prop) {\n      // Object prototype\n      case 'hasOwnProperty':\n      case 'isPrototypeOf':\n      case 'propertyIsEnumerable':\n      case 'toString':\n      case 'valueOf':\n      case 'toLocaleString':\n\n      // Promise prototype\n      // fallthrough\n      case 'then':\n      case 'catch':\n      case 'finally':\n\n      // React Promise extension\n      // fallthrough\n      case 'status':\n\n      // Common tested properties\n      // fallthrough\n      case 'toJSON':\n      case '$$typeof':\n      case '__esModule': {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        break\n      }\n      default: {\n        ;(promise as any)[prop] = underlyingParams[prop]\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(\n  underlyingParams: Params,\n  store: WorkStore\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    switch (prop) {\n      // Object prototype\n      case 'hasOwnProperty':\n      case 'isPrototypeOf':\n      case 'propertyIsEnumerable':\n      case 'toString':\n      case 'valueOf':\n      case 'toLocaleString':\n\n      // Promise prototype\n      // fallthrough\n      case 'then':\n      case 'catch':\n      case 'finally':\n\n      // React Promise extension\n      // fallthrough\n      case 'status':\n\n      // Common tested properties\n      // fallthrough\n      case 'toJSON':\n      case '$$typeof':\n      case '__esModule': {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        unproxiedProperties.push(prop)\n        break\n      }\n      default: {\n        proxiedProperties.add(prop)\n        ;(promise as any)[prop] = underlyingParams[prop]\n      }\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      warnForEnumeration(store.route, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nconst noop = () => {}\n\nconst warnForSyncAccess = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(function getSyncAccessMessage(\n      route: undefined | string,\n      expression: string\n    ) {\n      const prefix = route ? ` In route ${route} a ` : 'A '\n      return (\n        `${prefix}param property was accessed directly with ${expression}. ` +\n        `\\`params\\` should be awaited before accessing its properties. ` +\n        `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n      )\n    })\n\nconst warnForEnumeration = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(function getEnumerationMessage(\n      route: undefined | string,\n      missingProperties: Array<string>\n    ) {\n      const prefix = route ? ` In route ${route} ` : ''\n      if (missingProperties.length) {\n        const describedMissingProperties =\n          describeListOfPropertyNames(missingProperties)\n        return (\n          `${prefix}params are being enumerated incompletely missing these properties: ${describedMissingProperties}. ` +\n          `\\`params\\` should be awaited before accessing its properties. ` +\n          `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n        )\n      } else {\n        return (\n          `${prefix}params are being enumerated. ` +\n          `\\`params\\` should be awaited before accessing its properties. ` +\n          `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n        )\n      }\n    })\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n"],"names":["ReflectAdapter","abortAndThrowOnSynchronousDynamicDataAccess","throwToInterruptStaticGeneration","postponeWithTracking","workUnitAsyncStorage","InvariantError","makeResolvedReactPromise","describeStringPropertyAccess","makeHangingPromise","createDedupedByCallsiteServerErrorLoggerDev","createPrerenderParamsFromClient","underlyingParams","workStore","createPrerenderParams","createRenderParamsFromClient","createRenderParams","createServerParamsForMetadata","createServerParamsForServerSegment","createServerParamsForRoute","isStaticGeneration","createPrerenderParamsForClientSegment","prerenderStore","getStore","type","fallbackParams","fallbackRouteParams","key","has","hasSomeFallbackParams","workUnitStore","makeAbortingExoticParams","route","makeErroringExoticParams","makeUntrackedExoticParams","process","env","NODE_ENV","isPrefetchRequest","makeDynamicallyTrackedExoticParamsWithDevWarnings","CachedParams","WeakMap","cachedParams","get","promise","set","Object","keys","forEach","prop","defineProperty","expression","newValue","value","writable","enumerable","configurable","augmentedUnderlying","Promise","resolve","dynamicTracking","store","proxiedProperties","Set","unproxiedProperties","push","add","proxiedPromise","Proxy","target","receiver","warnForSyncAccess","delete","ownKeys","warnForEnumeration","Reflect","noop","__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS","getSyncAccessMessage","prefix","getEnumerationMessage","missingProperties","length","describedMissingProperties","describeListOfPropertyNames","properties","description","i"],"mappings":"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"}