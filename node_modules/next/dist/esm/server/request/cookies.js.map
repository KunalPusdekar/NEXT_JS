{"version":3,"sources":["../../../src/server/request/cookies.ts"],"sourcesContent":["import {\n  type ReadonlyRequestCookies,\n  type ResponseCookies,\n  RequestCookiesAdapter,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { RequestCookies } from '../web/spec-extension/cookies'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  postponeWithTracking,\n  abortAndThrowOnSynchronousDynamicDataAccess,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { getExpectedRequestStore } from '../app-render/work-unit-async-storage.external'\nimport { actionAsyncStorage } from '../app-render/action-async-storage.external'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { makeResolvedReactPromise } from './utils'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-loger'\n\n/**\n * In this version of Next.js `cookies()` returns a Promise however you can still reference the properties of the underlying cookies object\n * synchronously to facilitate migration. The `UnsafeUnwrappedCookies` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `cookies()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedCookies` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `cookies()` value can be awaited or you should call `cookies()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedCookies` in your codebase or by search for a comment that\n * starts with:\n *\n * ```\n * // TODO [sync-cookies-usage]\n * ```\n * In a future version of Next.js `cookies()` will only return a Promise and you will not be able to access the underlying cookies object directly\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedCookies` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedCookies = ReadonlyRequestCookies\n\nexport function cookies(): Promise<ReadonlyRequestCookies> {\n  const callingExpression = 'cookies'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // cookies object without tracking\n      const underlyingCookies = createEmptyCookies()\n      return makeUntrackedExoticCookies(underlyingCookies)\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"cookies\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      }\n    }\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'prerender') {\n        // dynamicIO Prerender\n        // We don't track dynamic access here because access will be tracked when you access\n        // one of the properties of the cookies object.\n        return makeDynamicallyTrackedExoticCookies(\n          workStore.route,\n          workUnitStore\n        )\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        // We are prerendering with PPR. We need track dynamic access here eagerly\n        // to keep continuity with how cookies has worked in PPR without dynamicIO.\n        postponeWithTracking(\n          workStore.route,\n          callingExpression,\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        // Legacy Prerender\n        // We track dynamic access here so we don't need to wrap the cookies in\n        // individual property access tracking.\n        throwToInterruptStaticGeneration(\n          callingExpression,\n          workStore,\n          workUnitStore\n        )\n      }\n    }\n    // We fall through to the dynamic context below but we still track dynamic access\n    // because in dev we can still error for things like using cookies inside a cache context\n    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n  }\n\n  // cookies is being called in a dynamic context\n  const actionStore = actionAsyncStorage.getStore()\n\n  const requestStore = getExpectedRequestStore(callingExpression)\n\n  let underlyingCookies: ReadonlyRequestCookies\n\n  // The current implementation of cookies will return Response cookies\n  // for a server action during the render phase of a server action.\n  // This is not correct b/c the type of cookies during render is ReadOnlyRequestCookies\n  // where as the type of cookies during action is ResponseCookies\n  // This was found because RequestCookies is iterable and ResponseCookies is not\n  if (actionStore?.isAction || actionStore?.isAppRoute) {\n    // We can't conditionally return different types here based on the context.\n    // To avoid confusion, we always return the readonly type here.\n    underlyingCookies =\n      requestStore.mutableCookies as unknown as ReadonlyRequestCookies\n  } else {\n    underlyingCookies = requestStore.cookies\n  }\n\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    return makeUntrackedExoticCookiesWithDevWarnings(\n      underlyingCookies,\n      workStore?.route\n    )\n  } else {\n    return makeUntrackedExoticCookies(underlyingCookies)\n  }\n}\n\nfunction createEmptyCookies(): ReadonlyRequestCookies {\n  return RequestCookiesAdapter.seal(new RequestCookies(new Headers({})))\n}\n\ninterface CacheLifetime {}\nconst CachedCookies = new WeakMap<\n  CacheLifetime,\n  Promise<ReadonlyRequestCookies>\n>()\n\nfunction makeDynamicallyTrackedExoticCookies(\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyRequestCookies> {\n  const cachedPromise = CachedCookies.get(prerenderStore)\n  if (cachedPromise) {\n    return cachedPromise\n  }\n\n  const promise = makeHangingPromise<ReadonlyRequestCookies>()\n  CachedCookies.set(prerenderStore, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = 'cookies()[Symbol.iterator]()'\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    size: {\n      get() {\n        const expression = `cookies().size`\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    get: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = 'cookies().get()'\n        } else {\n          expression = `cookies().get(${describeNameArg(arguments[0])})`\n        }\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    getAll: {\n      value: function getAll() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = `cookies().getAll()`\n        } else {\n          expression = `cookies().getAll(${describeNameArg(arguments[0])})`\n        }\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    has: {\n      value: function has() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = `cookies().has()`\n        } else {\n          expression = `cookies().has(${describeNameArg(arguments[0])})`\n        }\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    set: {\n      value: function set() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = 'cookies().set()'\n        } else {\n          const arg = arguments[0]\n          if (arg) {\n            expression = `cookies().set(${describeNameArg(arg)}, ...)`\n          } else {\n            expression = `cookies().set(...)`\n          }\n        }\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    delete: {\n      value: function () {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = `cookies().delete()`\n        } else if (arguments.length === 1) {\n          expression = `cookies().delete(${describeNameArg(arguments[0])})`\n        } else {\n          expression = `cookies().delete(${describeNameArg(arguments[0])}, ...)`\n        }\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    clear: {\n      value: function clear() {\n        const expression = 'cookies().clear()'\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    toString: {\n      value: function toString() {\n        const expression = 'cookies().toString()'\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticCookies(\n  underlyingCookies: ReadonlyRequestCookies\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = makeResolvedReactPromise(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: underlyingCookies[Symbol.iterator]\n        ? underlyingCookies[Symbol.iterator].bind(underlyingCookies)\n        : // TODO this is a polyfill for when the underlying type is ResponseCookies\n          // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n          // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n          // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n          // has extra properties not available on RequestCookie instances.\n          polyfilledResponseCookiesIterator.bind(underlyingCookies),\n    },\n    size: {\n      get(): number {\n        return underlyingCookies.size\n      },\n    },\n    get: {\n      value: underlyingCookies.get.bind(underlyingCookies),\n    },\n    getAll: {\n      value: underlyingCookies.getAll.bind(underlyingCookies),\n    },\n    has: {\n      value: underlyingCookies.has.bind(underlyingCookies),\n    },\n    set: {\n      value: underlyingCookies.set.bind(underlyingCookies),\n    },\n    delete: {\n      value: underlyingCookies.delete.bind(underlyingCookies),\n    },\n    clear: {\n      value:\n        // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n        typeof underlyingCookies.clear === 'function'\n          ? // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n            underlyingCookies.clear.bind(underlyingCookies)\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.bind(underlyingCookies, promise),\n    },\n    toString: {\n      value: underlyingCookies.toString.bind(underlyingCookies),\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticCookiesWithDevWarnings(\n  underlyingCookies: ReadonlyRequestCookies,\n  route?: string\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = makeResolvedReactPromise(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: function () {\n        warnForSyncIteration(route)\n        return underlyingCookies[Symbol.iterator]\n          ? underlyingCookies[Symbol.iterator].apply(\n              underlyingCookies,\n              arguments as any\n            )\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesIterator.call(underlyingCookies)\n      },\n      writable: false,\n    },\n    size: {\n      get(): number {\n        const expression = 'cookies().size'\n        warnForSyncAccess(route, expression)\n        return underlyingCookies.size\n      },\n    },\n    get: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = 'cookies().get()'\n        } else {\n          expression = `cookies().get(${describeNameArg(arguments[0])})`\n        }\n        warnForSyncAccess(route, expression)\n        return underlyingCookies.get.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    getAll: {\n      value: function getAll() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = `cookies().getAll()`\n        } else {\n          expression = `cookies().getAll(${describeNameArg(arguments[0])})`\n        }\n        warnForSyncAccess(route, expression)\n        return underlyingCookies.getAll.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n    has: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = `cookies().has()`\n        } else {\n          expression = `cookies().has(${describeNameArg(arguments[0])})`\n        }\n        warnForSyncAccess(route, expression)\n        return underlyingCookies.has.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    set: {\n      value: function set() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = 'cookies().set()'\n        } else {\n          const arg = arguments[0]\n          if (arg) {\n            expression = `cookies().set(${describeNameArg(arg)}, ...)`\n          } else {\n            expression = `cookies().set(...)`\n          }\n        }\n        warnForSyncAccess(route, expression)\n        return underlyingCookies.set.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    delete: {\n      value: function () {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = `cookies().delete()`\n        } else if (arguments.length === 1) {\n          expression = `cookies().delete(${describeNameArg(arguments[0])})`\n        } else {\n          expression = `cookies().delete(${describeNameArg(arguments[0])}, ...)`\n        }\n        warnForSyncAccess(route, expression)\n        return underlyingCookies.delete.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n    clear: {\n      value: function clear() {\n        const expression = 'cookies().clear()'\n        warnForSyncAccess(route, expression)\n        // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n        return typeof underlyingCookies.clear === 'function'\n          ? // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n            underlyingCookies.clear.apply(underlyingCookies, arguments)\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.call(underlyingCookies, promise)\n      },\n      writable: false,\n    },\n    toString: {\n      value: function toString() {\n        const expression = 'cookies().toString()'\n        warnForSyncAccess(route, expression)\n        return underlyingCookies.toString.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction describeNameArg(arg: unknown) {\n  return typeof arg === 'object' &&\n    arg !== null &&\n    typeof (arg as any).name === 'string'\n    ? `'${(arg as any).name}'`\n    : typeof arg === 'string'\n      ? `'${arg}'`\n      : '...'\n}\n\nconst noop = () => {}\n\nconst warnForSyncIteration = process.env\n  .__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(\n      function getSyncIterationMessage(route?: string) {\n        const prefix = route ? ` In route ${route} ` : ''\n        return (\n          `${prefix}cookies were iterated over. ` +\n          `\\`cookies()\\` should be awaited before using its value. ` +\n          `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n        )\n      }\n    )\n\nconst warnForSyncAccess = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(function getSyncAccessMessage(\n      route: undefined | string,\n      expression: string\n    ) {\n      const prefix = route ? ` In route ${route} a ` : 'A '\n      return (\n        `${prefix}cookie property was accessed directly with \\`${expression}\\`. ` +\n        `\\`cookies()\\` should be awaited before using its value. ` +\n        `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n      )\n    })\n\nfunction polyfilledResponseCookiesIterator(\n  this: ResponseCookies\n): ReturnType<ReadonlyRequestCookies[typeof Symbol.iterator]> {\n  return this.getAll()\n    .map((c) => [c.name, c] as [string, any])\n    .values()\n}\n\nfunction polyfilledResponseCookiesClear(\n  this: ResponseCookies,\n  returnable: Promise<ReadonlyRequestCookies>\n): typeof returnable {\n  for (const cookie of this.getAll()) {\n    this.delete(cookie.name)\n  }\n  return returnable\n}\n\ntype CookieExtensions = {\n  [K in keyof ReadonlyRequestCookies | 'clear']: unknown\n}\n"],"names":["RequestCookiesAdapter","RequestCookies","workAsyncStorage","workUnitAsyncStorage","postponeWithTracking","abortAndThrowOnSynchronousDynamicDataAccess","throwToInterruptStaticGeneration","trackDynamicDataInDynamicRender","getExpectedRequestStore","actionAsyncStorage","StaticGenBailoutError","makeResolvedReactPromise","makeHangingPromise","createDedupedByCallsiteServerErrorLoggerDev","cookies","callingExpression","workStore","getStore","workUnitStore","forceStatic","underlyingCookies","createEmptyCookies","makeUntrackedExoticCookies","type","Error","route","dynamicShouldError","makeDynamicallyTrackedExoticCookies","dynamicTracking","actionStore","requestStore","isAction","isAppRoute","mutableCookies","process","env","NODE_ENV","isPrefetchRequest","makeUntrackedExoticCookiesWithDevWarnings","seal","Headers","CachedCookies","WeakMap","prerenderStore","cachedPromise","get","promise","set","Object","defineProperties","Symbol","iterator","value","expression","size","arguments","length","describeNameArg","getAll","has","arg","delete","clear","toString","cachedCookies","bind","polyfilledResponseCookiesIterator","polyfilledResponseCookiesClear","warnForSyncIteration","apply","call","writable","warnForSyncAccess","name","noop","__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS","getSyncIterationMessage","prefix","getSyncAccessMessage","map","c","values","returnable","cookie"],"mappings":"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"}