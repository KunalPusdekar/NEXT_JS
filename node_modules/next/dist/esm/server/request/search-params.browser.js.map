{"version":3,"sources":["../../../src/server/request/search-params.browser.ts"],"sourcesContent":["import type { SearchParams } from './search-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  describeStringPropertyAccess,\n  describeHasCheckingStringProperty,\n} from './utils'\n\nexport function createRenderSearchParamsFromClient(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  if (process.env.NODE_ENV === 'development') {\n    return makeUntrackedExoticSearchParamsWithDevWarnings(\n      underlyingSearchParams\n    )\n  } else {\n    return makeUntrackedExoticSearchParams(underlyingSearchParams)\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nfunction makeUntrackedExoticSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve(underlyingSearchParams)\n  Object.defineProperties(promise, {\n    status: {\n      value: 'fulfilled',\n    },\n    value: {\n      value: underlyingSearchParams,\n    },\n  })\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (Reflect.has(promise, prop)) {\n      // We can't assign a value over a property on the promise. The only way to\n      // access this is if you await the promise and recover the underlying searchParams object.\n    } else {\n      Object.defineProperty(promise, prop, {\n        value: underlyingSearchParams[prop],\n        writable: false,\n        enumerable: true,\n      })\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Reflect.has(target, prop)) {\n        return ReflectAdapter.get(target, prop, receiver)\n      } else if (typeof prop === 'symbol') {\n        return undefined\n      } else {\n        const expression = describeStringPropertyAccess('searchParams', prop)\n        warnForSyncAccess(expression)\n        return underlyingSearchParams[prop]\n      }\n    },\n    has(target, prop) {\n      if (Reflect.has(target, prop)) {\n        return true\n      } else if (typeof prop === 'symbol') {\n        // searchParams never has symbol properties containing searchParam data\n        // and we didn't match above so we just return false here.\n        return false\n      } else {\n        const expression = describeHasCheckingStringProperty(\n          'searchParams',\n          prop\n        )\n        warnForSyncAccess(expression)\n        return Reflect.has(underlyingSearchParams, prop)\n      }\n    },\n    ownKeys(target) {\n      warnForSyncSpread()\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeUntrackedExoticSearchParams(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const promise = Promise.resolve(underlyingSearchParams)\n  Object.defineProperties(promise, {\n    status: {\n      value: 'fulfilled',\n    },\n    value: {\n      value: underlyingSearchParams,\n    },\n  })\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (Reflect.has(promise, prop)) {\n      // We can't assign a value over a property on the promise. The only way to\n      // access this is if you await the promise and recover the underlying searchParams object.\n    } else {\n      Object.defineProperty(promise, prop, {\n        value: underlyingSearchParams[prop],\n        writable: false,\n        enumerable: true,\n      })\n    }\n  })\n\n  return promise\n}\n\nconst noop = () => {}\n\nconst warnForSyncAccess = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : function warnForSyncAccess(expression: string) {\n      if (process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS) {\n        return\n      }\n\n      console.error(\n        `A searchParam property was accessed directly with ${expression}. ` +\n          `\\`searchParams\\` should be unwrapped with \\`React.use()\\` before accessing its properties. ` +\n          `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n      )\n    }\n\nconst warnForSyncSpread = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : function warnForSyncSpread() {\n      if (process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS) {\n        return\n      }\n\n      console.error(\n        `The keys of \\`searchParams\\` were accessed directly. ` +\n          `\\`searchParams\\` should be unwrapped with \\`React.use()\\` before accessing its properties. ` +\n          `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n      )\n    }\n"],"names":["ReflectAdapter","describeStringPropertyAccess","describeHasCheckingStringProperty","createRenderSearchParamsFromClient","underlyingSearchParams","process","env","NODE_ENV","makeUntrackedExoticSearchParamsWithDevWarnings","makeUntrackedExoticSearchParams","CachedSearchParams","WeakMap","cachedSearchParams","get","promise","Promise","resolve","Object","defineProperties","status","value","keys","forEach","prop","Reflect","has","defineProperty","writable","enumerable","proxiedPromise","Proxy","target","receiver","undefined","expression","warnForSyncAccess","ownKeys","warnForSyncSpread","set","noop","__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS","console","error"],"mappings":"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"}