{"version":3,"sources":["../../../src/server/after/after-context.ts"],"sourcesContent":["import PromiseQueue from 'next/dist/compiled/p-queue'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { AfterCallback, AfterTask } from './after'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { withExecuteRevalidates } from './revalidation-utils'\nimport { bindSnapshot } from '../app-render/async-local-storage'\nimport {\n  workUnitAsyncStorage,\n  type WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\n\nexport type AfterContextOpts = {\n  waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  onClose: RequestLifecycleOpts['onClose'] | undefined\n}\n\nexport class AfterContext {\n  private waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  private onClose: RequestLifecycleOpts['onClose'] | undefined\n\n  private runCallbacksOnClosePromise: Promise<void> | undefined\n  private callbackQueue: PromiseQueue\n  private workUnitStores = new Set<WorkUnitStore>()\n\n  constructor({ waitUntil, onClose }: AfterContextOpts) {\n    this.waitUntil = waitUntil\n    this.onClose = onClose\n\n    this.callbackQueue = new PromiseQueue()\n    this.callbackQueue.pause()\n  }\n\n  public after(task: AfterTask): void {\n    if (isThenable(task)) {\n      task.catch(() => {}) // avoid unhandled rejection crashes\n      if (!this.waitUntil) {\n        errorWaitUntilNotAvailable()\n      }\n      this.waitUntil(task)\n    } else if (typeof task === 'function') {\n      // TODO(after): implement tracing\n      this.addCallback(task)\n    } else {\n      throw new Error(\n        '`unstable_after()`: Argument must be a promise or a function'\n      )\n    }\n  }\n\n  private addCallback(callback: AfterCallback) {\n    // if something is wrong, throw synchronously, bubbling up to the `unstable_after` callsite.\n    if (!this.waitUntil) {\n      errorWaitUntilNotAvailable()\n    }\n    if (!this.onClose) {\n      throw new InvariantError(\n        'unstable_after: Missing `onClose` implementation'\n      )\n    }\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (!workUnitStore) {\n      throw new InvariantError(\n        'Missing workUnitStore in AfterContext.addCallback'\n      )\n    }\n    this.workUnitStores.add(workUnitStore)\n\n    // this should only happen once.\n    if (!this.runCallbacksOnClosePromise) {\n      this.runCallbacksOnClosePromise = this.runCallbacksOnClose()\n      this.waitUntil(this.runCallbacksOnClosePromise)\n    }\n\n    // Bind the callback to the current execution context (i.e. preserve all currently available ALS-es).\n    // We do this because we want all of these to be equivalent in every regard except timing:\n    //   after(() => x())\n    //   after(x())\n    //   await x()\n    const wrappedCallback = bindSnapshot(async () => {\n      try {\n        await callback()\n      } catch (err) {\n        // TODO(after): this is fine for now, but will need better intergration with our error reporting.\n        console.error(\n          'An error occurred in a function passed to `unstable_after()`:',\n          err\n        )\n      }\n    })\n\n    this.callbackQueue.add(wrappedCallback)\n  }\n\n  private async runCallbacksOnClose() {\n    await new Promise<void>((resolve) => this.onClose!(resolve))\n    return this.runCallbacks()\n  }\n\n  private async runCallbacks(): Promise<void> {\n    if (this.callbackQueue.size === 0) return\n\n    for (const workUnitStore of this.workUnitStores) {\n      workUnitStore.phase = 'after'\n    }\n\n    const workStore = workAsyncStorage.getStore()\n    if (!workStore) {\n      throw new InvariantError('Missing workStore in AfterContext.runCallbacks')\n    }\n\n    return withExecuteRevalidates(workStore, () => {\n      this.callbackQueue.start()\n      return this.callbackQueue.onIdle()\n    })\n  }\n}\n\nfunction errorWaitUntilNotAvailable(): never {\n  throw new Error(\n    '`unstable_after()` will not work correctly, because `waitUntil` is not available in the current environment.'\n  )\n}\n"],"names":["PromiseQueue","InvariantError","isThenable","workAsyncStorage","withExecuteRevalidates","bindSnapshot","workUnitAsyncStorage","AfterContext","constructor","waitUntil","onClose","workUnitStores","Set","callbackQueue","pause","after","task","catch","errorWaitUntilNotAvailable","addCallback","Error","callback","workUnitStore","getStore","add","runCallbacksOnClosePromise","runCallbacksOnClose","wrappedCallback","err","console","error","Promise","resolve","runCallbacks","size","phase","workStore","start","onIdle"],"mappings":"AAAA,OAAOA,kBAAkB,6BAA4B;AAGrD,SAASC,cAAc,QAAQ,mCAAkC;AACjE,SAASC,UAAU,QAAQ,+BAA8B;AACzD,SAASC,gBAAgB,QAAQ,4CAA2C;AAC5E,SAASC,sBAAsB,QAAQ,uBAAsB;AAC7D,SAASC,YAAY,QAAQ,oCAAmC;AAChE,SACEC,oBAAoB,QAEf,iDAAgD;AAOvD,OAAO,MAAMC;IAQXC,YAAY,EAAEC,SAAS,EAAEC,OAAO,EAAoB,CAAE;aAF9CC,iBAAiB,IAAIC;QAG3B,IAAI,CAACH,SAAS,GAAGA;QACjB,IAAI,CAACC,OAAO,GAAGA;QAEf,IAAI,CAACG,aAAa,GAAG,IAAIb;QACzB,IAAI,CAACa,aAAa,CAACC,KAAK;IAC1B;IAEOC,MAAMC,IAAe,EAAQ;QAClC,IAAId,WAAWc,OAAO;YACpBA,KAAKC,KAAK,CAAC,KAAO,GAAG,oCAAoC;;YACzD,IAAI,CAAC,IAAI,CAACR,SAAS,EAAE;gBACnBS;YACF;YACA,IAAI,CAACT,SAAS,CAACO;QACjB,OAAO,IAAI,OAAOA,SAAS,YAAY;YACrC,iCAAiC;YACjC,IAAI,CAACG,WAAW,CAACH;QACnB,OAAO;YACL,MAAM,IAAII,MACR;QAEJ;IACF;IAEQD,YAAYE,QAAuB,EAAE;QAC3C,4FAA4F;QAC5F,IAAI,CAAC,IAAI,CAACZ,SAAS,EAAE;YACnBS;QACF;QACA,IAAI,CAAC,IAAI,CAACR,OAAO,EAAE;YACjB,MAAM,IAAIT,eACR;QAEJ;QAEA,MAAMqB,gBAAgBhB,qBAAqBiB,QAAQ;QACnD,IAAI,CAACD,eAAe;YAClB,MAAM,IAAIrB,eACR;QAEJ;QACA,IAAI,CAACU,cAAc,CAACa,GAAG,CAACF;QAExB,gCAAgC;QAChC,IAAI,CAAC,IAAI,CAACG,0BAA0B,EAAE;YACpC,IAAI,CAACA,0BAA0B,GAAG,IAAI,CAACC,mBAAmB;YAC1D,IAAI,CAACjB,SAAS,CAAC,IAAI,CAACgB,0BAA0B;QAChD;QAEA,qGAAqG;QACrG,0FAA0F;QAC1F,qBAAqB;QACrB,eAAe;QACf,cAAc;QACd,MAAME,kBAAkBtB,aAAa;YACnC,IAAI;gBACF,MAAMgB;YACR,EAAE,OAAOO,KAAK;gBACZ,iGAAiG;gBACjGC,QAAQC,KAAK,CACX,iEACAF;YAEJ;QACF;QAEA,IAAI,CAACf,aAAa,CAACW,GAAG,CAACG;IACzB;IAEA,MAAcD,sBAAsB;QAClC,MAAM,IAAIK,QAAc,CAACC,UAAY,IAAI,CAACtB,OAAO,CAAEsB;QACnD,OAAO,IAAI,CAACC,YAAY;IAC1B;IAEA,MAAcA,eAA8B;QAC1C,IAAI,IAAI,CAACpB,aAAa,CAACqB,IAAI,KAAK,GAAG;QAEnC,KAAK,MAAMZ,iBAAiB,IAAI,CAACX,cAAc,CAAE;YAC/CW,cAAca,KAAK,GAAG;QACxB;QAEA,MAAMC,YAAYjC,iBAAiBoB,QAAQ;QAC3C,IAAI,CAACa,WAAW;YACd,MAAM,IAAInC,eAAe;QAC3B;QAEA,OAAOG,uBAAuBgC,WAAW;YACvC,IAAI,CAACvB,aAAa,CAACwB,KAAK;YACxB,OAAO,IAAI,CAACxB,aAAa,CAACyB,MAAM;QAClC;IACF;AACF;AAEA,SAASpB;IACP,MAAM,IAAIE,MACR;AAEJ"}