{"version":3,"sources":["../../../src/server/app-render/dynamic-rendering.ts"],"sourcesContent":["/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { WorkUnitStore } from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreLegacy,\n  type PrerenderStoreModern,\n} from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n} from '../../lib/metadata/metadata-constants'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\ntype DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during a render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  /**\n   * disallowedDynamic tracks information about what dynamic accesses\n   * were not properly scoped. These are prerender failures both at build\n   * and revalidate time.\n   */\n  readonly disallowedDynamic: {\n    hasSuspendedDynamic: boolean\n    hasDynamicMetadata: boolean\n    hasDynamicViewport: boolean\n    syncDynamicExpression: string\n    syncDynamicErrors: Array<Error>\n    dynamicErrors: Array<Error>\n  }\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    disallowedDynamic: {\n      hasSuspendedDynamic: false,\n      hasDynamicMetadata: false,\n      hasDynamicViewport: false,\n      syncDynamicExpression: '',\n      syncDynamicErrors: [],\n      dynamicErrors: [],\n    },\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | WorkUnitStore,\n  expression: string\n): void {\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache'\n    ) {\n      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n      // forbidden inside a cache scope.\n      return\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    if (workUnitStore.type === 'prerender') {\n      // We're prerendering the RSC stream with dynamicIO enabled and we need to abort the\n      // current render because something dynamic is being used.\n      // This won't throw so we still need to fall through to determine if/how we handle\n      // this specific dynamic request.\n      abortAndThrowOnSynchronousDynamicDataAccess(\n        store.route,\n        expression,\n        workUnitStore\n      )\n    } else if (workUnitStore.type === 'prerender-ppr') {\n      postponeWithTracking(\n        store.route,\n        expression,\n        workUnitStore.dynamicTracking\n      )\n    } else if (workUnitStore.type === 'prerender-legacy') {\n      workUnitStore.revalidate = 0\n\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      const err = new DynamicServerError(\n        `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n      )\n      store.dynamicUsageDescription = expression\n      store.dynamicUsageStack = err.stack\n\n      throw err\n    } else if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\n/**\n * This function communicates that some dynamic path parameter was read. This\n * differs from the more general `trackDynamicDataAccessed` in that it is will\n * not error when `dynamic = \"error\"` is set.\n *\n * @param store The static generation store\n * @param expression The expression that was accessed dynamically\n */\nexport function trackFallbackParamAccessed(\n  store: WorkStore,\n  expression: string\n): void {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return\n\n  postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking)\n}\n\n/**\n * This function communicates that some dynamic data was read. This typically would refer to accessing\n * a Request specific data store such as cookies or headers. This function is not how end-users will\n * describe reading from dynamic data sources which are valid to cache and up to the author to make\n * a determination of when to do so.\n *\n * If we are inside a cache scope we error\n * Also during a PPR Prerender we postpone\n */\nexport function trackDynamicDataAccessed(\n  store: WorkStore,\n  workUnitStore: undefined | WorkUnitStore,\n  expression: string\n): void {\n  if (workUnitStore) {\n    if (workUnitStore.type === 'cache') {\n      throw new Error(\n        `Route ${store.route} used \"${expression}\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"${expression}\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n      )\n    } else if (workUnitStore.type === 'unstable-cache') {\n      throw new Error(\n        `Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"${expression}\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n      )\n    }\n  }\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    if (workUnitStore.type === 'prerender') {\n      // dynamicIO Prerender\n      abortAndThrowOnSynchronousDynamicDataAccess(\n        store.route,\n        expression,\n        workUnitStore\n      )\n    } else if (workUnitStore.type === 'prerender-ppr') {\n      // PPR Prerender\n      postponeWithTracking(\n        store.route,\n        expression,\n        workUnitStore.dynamicTracking\n      )\n    } else if (workUnitStore.type === 'prerender-legacy') {\n      // legacy Prerender\n      workUnitStore.revalidate = 0\n\n      const err = new DynamicServerError(\n        `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n      )\n      store.dynamicUsageDescription = expression\n      store.dynamicUsageStack = err.stack\n\n      throw err\n    } else if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\n/**\n * This function is meant to be used when prerendering without dynamicIO or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(\n  _store: WorkStore,\n  workUnitStore: void | WorkUnitStore\n) {\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache'\n    ) {\n      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n      // forbidden inside a cache scope.\n      return\n    }\n    if (\n      workUnitStore.type === 'prerender' ||\n      workUnitStore.type === 'prerender-legacy'\n    ) {\n      workUnitStore.revalidate = 0\n    }\n    if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\n// Despite it's name we don't actually abort unless we have a controller to call abort on\n// There are times when we let a prerender run long to discover caches where we want the semantics\n// of tracking dynamic access without terminating the prerender early\nexport function abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  if (prerenderStore.dynamicTracking) {\n    const disallowedDynamic = prerenderStore.dynamicTracking.disallowedDynamic\n    if (disallowedDynamic.syncDynamicExpression === '') {\n      disallowedDynamic.syncDynamicExpression = expression\n    }\n  }\n\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  if (prerenderStore.controller) {\n    prerenderStore.controller.abort(error)\n  }\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\n/**\n * use this function when prerendering with dynamicIO. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in dynamicIO mode.\n *\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): never {\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function isRenderInterruptedReason(reason: string) {\n  return reason === NEXT_PRERENDER_INTERRUPTED\n}\n\nexport function accessedDynamicData(\n  dynamicTracking: DynamicTrackingState\n): boolean {\n  return dynamicTracking.dynamicAccesses.length > 0\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicTracking: DynamicTrackingState\n): string[] {\n  return dynamicTracking.dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createPostponedAbortSignal(reason: string): AbortSignal {\n  assertPostpone()\n  const controller = new AbortController()\n  // We get our hands on a postpone instance by calling postpone and catching the throw\n  try {\n    React.unstable_postpone(reason)\n  } catch (x: unknown) {\n    controller.abort(x)\n  }\n  return controller.signal\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  if (typeof window === 'undefined') {\n    const workStore = workAsyncStorage.getStore()\n\n    if (\n      workStore &&\n      workStore.isStaticGeneration &&\n      workStore.fallbackRouteParams &&\n      workStore.fallbackRouteParams.size > 0\n    ) {\n      // There are fallback route params, we should track these as dynamic\n      // accesses.\n      const workUnitStore = workUnitAsyncStorage.getStore()\n      if (workUnitStore) {\n        // We're prerendering with dynamicIO or PPR or both\n        if (workUnitStore.type === 'prerender') {\n          // We are in a prerender with dynamicIO semantics\n          // We are going to hang here and never resolve. This will cause the currently\n          // rendering component to effectively be a dynamic hole\n          React.use(makeHangingPromise())\n        } else if (workUnitStore.type === 'prerender-ppr') {\n          // We're prerendering with PPR\n          postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        } else if (workUnitStore.type === 'prerender-legacy') {\n          throwToInterruptStaticGeneration(expression, workStore, workUnitStore)\n        }\n      }\n    }\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  route: string,\n  thrownValue: Error,\n  componentStack: string,\n  dynamicTracking: DynamicTrackingState\n) {\n  const disallowedDynamic = dynamicTracking.disallowedDynamic\n  if (hasSuspenseRegex.test(componentStack)) {\n    disallowedDynamic.hasSuspendedDynamic = true\n    return\n  } else if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    //\n    disallowedDynamic.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    disallowedDynamic.hasDynamicViewport = true\n    return\n  } else if (isPrerenderInterruptedError(thrownValue)) {\n    const syncDynamicExpression = disallowedDynamic.syncDynamicExpression\n    let message: string\n    if (syncDynamicExpression) {\n      message = `Route ${route} used a synchronous Dynamic API: ${syncDynamicExpression}, which caused this component to not finish rendering before the prerender completed and no fallback UI was defined.`\n    } else {\n      message = `Route ${route} used a synchronous Dynamic API which caused this component to not finish rendering before the prerender completed and no fallback UI was defined.`\n    }\n    const error = createErrorWithComponentStack(message, componentStack)\n    disallowedDynamic.syncDynamicErrors.push(error)\n    return\n  } else if (disallowedDynamic.syncDynamicExpression) {\n    const message = `Route ${route} used a synchronous Dynamic API: ${disallowedDynamic.syncDynamicExpression}. This particular component may have been dynamic anyway or it may have just not finished before the synchronous Dynamic API was invoked.`\n    const error = createErrorWithComponentStack(message, componentStack)\n    disallowedDynamic.syncDynamicErrors.push(error)\n    return\n  } else {\n    // The thrownValue must have been the RENDER_COMPLETE abortReason because the only kinds of errors tracked here are\n    // interrupts or render completes\n    const message = `Route ${route} performed an IO operation that was not cached and no Suspense boundary was found to define a fallback UI.`\n    const error = createErrorWithComponentStack(message, componentStack)\n    disallowedDynamic.dynamicErrors.push(error)\n    return\n  }\n}\n\nfunction createErrorWithComponentStack(\n  message: string,\n  componentStack: string\n) {\n  const error = new Error(message)\n  error.stack = 'Error: ' + message + componentStack\n  return error\n}\n\nexport function throwIfDisallowedDynamic(\n  workStore: WorkStore,\n  dynamicTracking: DynamicTrackingState\n): void {\n  const disallowedDynamic = dynamicTracking.disallowedDynamic\n  const syncDynamicErrors = disallowedDynamic.syncDynamicErrors\n  if (syncDynamicErrors.length) {\n    for (let i = 0; i < syncDynamicErrors.length; i++) {\n      console.error(syncDynamicErrors[i])\n    }\n    const expression =\n      disallowedDynamic.syncDynamicExpression || 'a synchronous Dynamic API'\n    throw new StaticGenBailoutError(\n      `Route ${workStore.route} used ${expression} while prerendering which caused some part of the page to be dynamic without a Suspense boundary above it defining a fallback UI. It is best to avoid synchronous Dynamic API access during prerendering.`\n    )\n  }\n\n  const dynamicErrors = disallowedDynamic.dynamicErrors\n  if (dynamicErrors.length) {\n    for (let i = 0; i < dynamicErrors.length; i++) {\n      console.error(dynamicErrors[i])\n    }\n    throw new StaticGenBailoutError(\n      `Route ${workStore.route} has one or more dynamic components without a defined fallback UI. Render dynamic components inside a Suspense boundary to indicate what the appropriate fallback UI should be.`\n    )\n  }\n\n  if (!disallowedDynamic.hasSuspendedDynamic) {\n    if (disallowedDynamic.hasDynamicMetadata) {\n      if (disallowedDynamic.syncDynamicExpression) {\n        throw new StaticGenBailoutError(\n          `Route ${workStore.route} used ${disallowedDynamic.syncDynamicExpression} before Next.js could finish rendering metadata.`\n        )\n      }\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} has a dynamic \\`generateMetadata\\` but nothing else is dynamic. Try updating your \\`generateMetadata\\` to use cached data or ensure your route has at least one dynamic component in the a Page or Layout.`\n      )\n    } else if (disallowedDynamic.hasDynamicViewport) {\n      if (disallowedDynamic.syncDynamicExpression) {\n        throw new StaticGenBailoutError(\n          `Route ${workStore.route} used ${disallowedDynamic.syncDynamicExpression} before Next.js could finish rendering viewport.`\n        )\n      }\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} has a dynamic \\`generateViewport\\` but nothing else is dynamic. Try updating your \\`generateViewport\\` to use cached data or ensure your route has at least one dynamic component in the a Page or Layout.`\n      )\n    }\n  }\n}\n"],"names":["Postpone","abortAndThrowOnSynchronousDynamicDataAccess","abortOnSynchronousDynamicDataAccess","accessedDynamicData","annotateDynamicAccess","createDynamicTrackingState","createPostponedAbortSignal","formatDynamicAPIAccesses","getFirstDynamicReason","isDynamicPostpone","isPrerenderInterruptedError","isRenderInterruptedReason","markCurrentScopeAsDynamic","postponeWithTracking","throwIfDisallowedDynamic","throwToInterruptStaticGeneration","trackAllowedDynamicAccess","trackDynamicDataAccessed","trackDynamicDataInDynamicRender","trackFallbackParamAccessed","useDynamicRouteParams","hasPostpone","React","unstable_postpone","isDebugDynamicAccesses","dynamicAccesses","disallowedDynamic","hasSuspendedDynamic","hasDynamicMetadata","hasDynamicViewport","syncDynamicExpression","syncDynamicErrors","dynamicErrors","trackingState","expression","store","workUnitStore","type","forceDynamic","forceStatic","dynamicShouldError","StaticGenBailoutError","route","dynamicTracking","revalidate","err","DynamicServerError","dynamicUsageDescription","dynamicUsageStack","stack","process","env","NODE_ENV","usedDynamic","prerenderStore","workUnitAsyncStorage","getStore","Error","_store","reason","error","createPrerenderInterruptedError","controller","abort","push","undefined","assertPostpone","createPostponeReason","message","isDynamicPostponeReason","includes","NEXT_PRERENDER_INTERRUPTED","digest","length","filter","access","map","split","slice","line","join","AbortController","x","signal","window","workStore","workAsyncStorage","isStaticGeneration","fallbackRouteParams","size","use","makeHangingPromise","hasSuspenseRegex","hasMetadataRegex","RegExp","METADATA_BOUNDARY_NAME","hasViewportRegex","VIEWPORT_BOUNDARY_NAME","hasOutletRegex","OUTLET_BOUNDARY_NAME","thrownValue","componentStack","test","createErrorWithComponentStack","i","console"],"mappings":"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"}