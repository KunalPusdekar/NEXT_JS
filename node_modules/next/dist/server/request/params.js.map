{"version":3,"sources":["../../../src/server/request/params.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { FallbackRouteParams } from './fallback-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  abortAndThrowOnSynchronousDynamicDataAccess,\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStorePPR,\n  type PrerenderStoreLegacy,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { makeResolvedReactPromise, describeStringPropertyAccess } from './utils'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-loger'\n\nexport type Params = Record<string, string | Array<string> | undefined>\n\n/**\n * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n * The `UnsafeUnwrappedParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n *\n * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n *\n * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n *\n * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n *\n * ```tsx\n * type Props = { params: Promise<{ id: string }>}\n *\n * export default async function Layout(props: Props) {\n *  const directParams = (props.params as unknown as UnsafeUnwrappedParams<typeof props.params>)\n *  return ...\n * }\n * ```\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedParams<P> =\n  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n\nexport function createPrerenderParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  return createPrerenderParams(underlyingParams, workStore)\n}\n\nexport function createRenderParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  return createRenderParams(underlyingParams, workStore)\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport type CreateServerParamsForMetadata = typeof createServerParamsForMetadata\nexport const createServerParamsForMetadata = createServerParamsForServerSegment\n\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  if (workStore.isStaticGeneration) {\n    return createPrerenderParams(underlyingParams, workStore)\n  } else {\n    return createRenderParams(underlyingParams, workStore)\n  }\n}\n\nexport function createServerParamsForServerSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  if (workStore.isStaticGeneration) {\n    return createPrerenderParams(underlyingParams, workStore)\n  } else {\n    return createRenderParams(underlyingParams, workStore)\n  }\n}\n\nexport function createPrerenderParamsForClientSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (prerenderStore && prerenderStore.type === 'prerender') {\n    const fallbackParams = workStore.fallbackRouteParams\n    if (fallbackParams) {\n      for (let key in underlyingParams) {\n        if (fallbackParams.has(key)) {\n          // This params object has one of more fallback params so we need to consider\n          // the awaiting of this params object \"dynamic\". Since we are in dynamicIO mode\n          // we encode this as a promise that never resolves\n          return makeHangingPromise()\n        }\n      }\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return makeResolvedReactPromise(underlyingParams)\n}\n\nfunction createPrerenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const fallbackParams = workStore.fallbackRouteParams\n  if (fallbackParams) {\n    let hasSomeFallbackParams = false\n    for (const key in underlyingParams) {\n      if (fallbackParams.has(key)) {\n        hasSomeFallbackParams = true\n        break\n      }\n    }\n\n    if (hasSomeFallbackParams) {\n      // params need to be treated as dynamic because we have at least one fallback param\n      const workUnitStore = workUnitAsyncStorage.getStore()\n      if (workUnitStore) {\n        if (workUnitStore.type === 'prerender') {\n          // We are in a dynamicIO (PPR or otherwise) prerender\n          return makeAbortingExoticParams(\n            underlyingParams,\n            workStore.route,\n            workUnitStore\n          )\n        } else if (\n          workUnitStore.type === 'prerender-legacy' ||\n          workUnitStore.type === 'prerender-ppr'\n        )\n          // We aren't in a dynamicIO prerender but we do have fallback params at this\n          // level so we need to make an erroring exotic params object which will postpone\n          // if you access the fallback params\n          return makeErroringExoticParams(\n            underlyingParams,\n            fallbackParams,\n            workStore,\n            workUnitStore\n          )\n      }\n      throw new InvariantError(\n        'createPrerenderParams called without a prerenderStore in scope. This is a bug in Next.js'\n      )\n    }\n  }\n\n  // We don't have any fallback params so we have an entirely static safe params object\n  return makeUntrackedExoticParams(underlyingParams)\n}\n\nfunction createRenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  if (process.env.NODE_ENV === 'development' && !workStore.isPrefetchRequest) {\n    return makeDynamicallyTrackedExoticParamsWithDevWarnings(\n      underlyingParams,\n      workStore\n    )\n  } else {\n    return makeUntrackedExoticParams(underlyingParams)\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nfunction makeAbortingExoticParams(\n  underlyingParams: Params,\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = makeHangingPromise<Params>()\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    switch (prop) {\n      // Object prototype\n      case 'hasOwnProperty':\n      case 'isPrototypeOf':\n      case 'propertyIsEnumerable':\n      case 'toString':\n      case 'valueOf':\n      case 'toLocaleString':\n\n      // Promise prototype\n      // fallthrough\n      case 'then':\n      case 'catch':\n      case 'finally':\n\n      // React Promise extension\n      // fallthrough\n      case 'status':\n\n      // Common tested properties\n      // fallthrough\n      case 'toJSON':\n      case '$$typeof':\n      case '__esModule': {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        break\n      }\n      default: {\n        Object.defineProperty(promise, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            abortAndThrowOnSynchronousDynamicDataAccess(\n              route,\n              expression,\n              prerenderStore\n            )\n          },\n          set(newValue) {\n            Object.defineProperty(promise, prop, {\n              value: newValue,\n              writable: true,\n              enumerable: true,\n            })\n          },\n          enumerable: true,\n          configurable: true,\n        })\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeErroringExoticParams(\n  underlyingParams: Params,\n  fallbackParams: FallbackRouteParams,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const augmentedUnderlying = { ...underlyingParams }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    switch (prop) {\n      // Object prototype\n      case 'hasOwnProperty':\n      case 'isPrototypeOf':\n      case 'propertyIsEnumerable':\n      case 'toString':\n      case 'valueOf':\n      case 'toLocaleString':\n\n      // Promise prototype\n      // fallthrough\n      case 'then':\n      case 'catch':\n      case 'finally':\n\n      // React Promise extension\n      // fallthrough\n      case 'status':\n\n      // Common tested properties\n      // fallthrough\n      case 'toJSON':\n      case '$$typeof':\n      case '__esModule': {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        break\n      }\n      default: {\n        if (fallbackParams.has(prop)) {\n          Object.defineProperty(augmentedUnderlying, prop, {\n            get() {\n              const expression = describeStringPropertyAccess('params', prop)\n              // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n              // for params is only dynamic when we're generating a fallback shell\n              // and even when `dynamic = \"error\"` we still support generating dynamic\n              // fallback shells\n              // TODO remove this comment when dynamicIO is the default since there\n              // will be no `dynamic = \"error\"`\n              if (prerenderStore.type === 'prerender-ppr') {\n                // PPR Prerender (no dynamicIO)\n                postponeWithTracking(\n                  workStore.route,\n                  expression,\n                  prerenderStore.dynamicTracking\n                )\n              } else {\n                // Legacy Prerender\n                throwToInterruptStaticGeneration(\n                  expression,\n                  workStore,\n                  prerenderStore\n                )\n              }\n            },\n            enumerable: true,\n          })\n          Object.defineProperty(promise, prop, {\n            get() {\n              const expression = describeStringPropertyAccess('params', prop)\n              // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n              // for params is only dynamic when we're generating a fallback shell\n              // and even when `dynamic = \"error\"` we still support generating dynamic\n              // fallback shells\n              // TODO remove this comment when dynamicIO is the default since there\n              // will be no `dynamic = \"error\"`\n              if (prerenderStore.type === 'prerender-ppr') {\n                // PPR Prerender (no dynamicIO)\n                postponeWithTracking(\n                  workStore.route,\n                  expression,\n                  prerenderStore.dynamicTracking\n                )\n              } else {\n                // Legacy Prerender\n                throwToInterruptStaticGeneration(\n                  expression,\n                  workStore,\n                  prerenderStore\n                )\n              }\n            },\n            set(newValue) {\n              Object.defineProperty(promise, prop, {\n                value: newValue,\n                writable: true,\n                enumerable: true,\n              })\n            },\n            enumerable: true,\n            configurable: true,\n          })\n        } else {\n          ;(promise as any)[prop] = underlyingParams[prop]\n        }\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedExoticParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    switch (prop) {\n      // Object prototype\n      case 'hasOwnProperty':\n      case 'isPrototypeOf':\n      case 'propertyIsEnumerable':\n      case 'toString':\n      case 'valueOf':\n      case 'toLocaleString':\n\n      // Promise prototype\n      // fallthrough\n      case 'then':\n      case 'catch':\n      case 'finally':\n\n      // React Promise extension\n      // fallthrough\n      case 'status':\n\n      // Common tested properties\n      // fallthrough\n      case 'toJSON':\n      case '$$typeof':\n      case '__esModule': {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        break\n      }\n      default: {\n        ;(promise as any)[prop] = underlyingParams[prop]\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(\n  underlyingParams: Params,\n  store: WorkStore\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    switch (prop) {\n      // Object prototype\n      case 'hasOwnProperty':\n      case 'isPrototypeOf':\n      case 'propertyIsEnumerable':\n      case 'toString':\n      case 'valueOf':\n      case 'toLocaleString':\n\n      // Promise prototype\n      // fallthrough\n      case 'then':\n      case 'catch':\n      case 'finally':\n\n      // React Promise extension\n      // fallthrough\n      case 'status':\n\n      // Common tested properties\n      // fallthrough\n      case 'toJSON':\n      case '$$typeof':\n      case '__esModule': {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        unproxiedProperties.push(prop)\n        break\n      }\n      default: {\n        proxiedProperties.add(prop)\n        ;(promise as any)[prop] = underlyingParams[prop]\n      }\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      warnForEnumeration(store.route, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nconst noop = () => {}\n\nconst warnForSyncAccess = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(function getSyncAccessMessage(\n      route: undefined | string,\n      expression: string\n    ) {\n      const prefix = route ? ` In route ${route} a ` : 'A '\n      return (\n        `${prefix}param property was accessed directly with ${expression}. ` +\n        `\\`params\\` should be awaited before accessing its properties. ` +\n        `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n      )\n    })\n\nconst warnForEnumeration = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(function getEnumerationMessage(\n      route: undefined | string,\n      missingProperties: Array<string>\n    ) {\n      const prefix = route ? ` In route ${route} ` : ''\n      if (missingProperties.length) {\n        const describedMissingProperties =\n          describeListOfPropertyNames(missingProperties)\n        return (\n          `${prefix}params are being enumerated incompletely missing these properties: ${describedMissingProperties}. ` +\n          `\\`params\\` should be awaited before accessing its properties. ` +\n          `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n        )\n      } else {\n        return (\n          `${prefix}params are being enumerated. ` +\n          `\\`params\\` should be awaited before accessing its properties. ` +\n          `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n        )\n      }\n    })\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n"],"names":["createPrerenderParamsForClientSegment","createPrerenderParamsFromClient","createRenderParamsFromClient","createServerParamsForMetadata","createServerParamsForRoute","createServerParamsForServerSegment","underlyingParams","workStore","createPrerenderParams","createRenderParams","isStaticGeneration","prerenderStore","workUnitAsyncStorage","getStore","type","fallbackParams","fallbackRouteParams","key","has","makeHangingPromise","makeResolvedReactPromise","hasSomeFallbackParams","workUnitStore","makeAbortingExoticParams","route","makeErroringExoticParams","InvariantError","makeUntrackedExoticParams","process","env","NODE_ENV","isPrefetchRequest","makeDynamicallyTrackedExoticParamsWithDevWarnings","CachedParams","WeakMap","cachedParams","get","promise","set","Object","keys","forEach","prop","defineProperty","expression","describeStringPropertyAccess","abortAndThrowOnSynchronousDynamicDataAccess","newValue","value","writable","enumerable","configurable","augmentedUnderlying","Promise","resolve","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","store","proxiedProperties","Set","unproxiedProperties","push","add","proxiedPromise","Proxy","target","receiver","warnForSyncAccess","ReflectAdapter","delete","ownKeys","warnForEnumeration","Reflect","noop","__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS","createDedupedByCallsiteServerErrorLoggerDev","getSyncAccessMessage","prefix","getEnumerationMessage","missingProperties","length","describedMissingProperties","describeListOfPropertyNames","properties","description","i"],"mappings":"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"}