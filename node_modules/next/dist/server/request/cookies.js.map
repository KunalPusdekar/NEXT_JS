{"version":3,"sources":["../../../src/server/request/cookies.ts"],"sourcesContent":["import {\n  type ReadonlyRequestCookies,\n  type ResponseCookies,\n  RequestCookiesAdapter,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { RequestCookies } from '../web/spec-extension/cookies'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  postponeWithTracking,\n  abortAndThrowOnSynchronousDynamicDataAccess,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { getExpectedRequestStore } from '../app-render/work-unit-async-storage.external'\nimport { actionAsyncStorage } from '../app-render/action-async-storage.external'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { makeResolvedReactPromise } from './utils'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-loger'\n\n/**\n * In this version of Next.js `cookies()` returns a Promise however you can still reference the properties of the underlying cookies object\n * synchronously to facilitate migration. The `UnsafeUnwrappedCookies` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `cookies()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedCookies` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `cookies()` value can be awaited or you should call `cookies()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedCookies` in your codebase or by search for a comment that\n * starts with:\n *\n * ```\n * // TODO [sync-cookies-usage]\n * ```\n * In a future version of Next.js `cookies()` will only return a Promise and you will not be able to access the underlying cookies object directly\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedCookies` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedCookies = ReadonlyRequestCookies\n\nexport function cookies(): Promise<ReadonlyRequestCookies> {\n  const callingExpression = 'cookies'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // cookies object without tracking\n      const underlyingCookies = createEmptyCookies()\n      return makeUntrackedExoticCookies(underlyingCookies)\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"cookies\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      }\n    }\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'prerender') {\n        // dynamicIO Prerender\n        // We don't track dynamic access here because access will be tracked when you access\n        // one of the properties of the cookies object.\n        return makeDynamicallyTrackedExoticCookies(\n          workStore.route,\n          workUnitStore\n        )\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        // We are prerendering with PPR. We need track dynamic access here eagerly\n        // to keep continuity with how cookies has worked in PPR without dynamicIO.\n        postponeWithTracking(\n          workStore.route,\n          callingExpression,\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        // Legacy Prerender\n        // We track dynamic access here so we don't need to wrap the cookies in\n        // individual property access tracking.\n        throwToInterruptStaticGeneration(\n          callingExpression,\n          workStore,\n          workUnitStore\n        )\n      }\n    }\n    // We fall through to the dynamic context below but we still track dynamic access\n    // because in dev we can still error for things like using cookies inside a cache context\n    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n  }\n\n  // cookies is being called in a dynamic context\n  const actionStore = actionAsyncStorage.getStore()\n\n  const requestStore = getExpectedRequestStore(callingExpression)\n\n  let underlyingCookies: ReadonlyRequestCookies\n\n  // The current implementation of cookies will return Response cookies\n  // for a server action during the render phase of a server action.\n  // This is not correct b/c the type of cookies during render is ReadOnlyRequestCookies\n  // where as the type of cookies during action is ResponseCookies\n  // This was found because RequestCookies is iterable and ResponseCookies is not\n  if (actionStore?.isAction || actionStore?.isAppRoute) {\n    // We can't conditionally return different types here based on the context.\n    // To avoid confusion, we always return the readonly type here.\n    underlyingCookies =\n      requestStore.mutableCookies as unknown as ReadonlyRequestCookies\n  } else {\n    underlyingCookies = requestStore.cookies\n  }\n\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    return makeUntrackedExoticCookiesWithDevWarnings(\n      underlyingCookies,\n      workStore?.route\n    )\n  } else {\n    return makeUntrackedExoticCookies(underlyingCookies)\n  }\n}\n\nfunction createEmptyCookies(): ReadonlyRequestCookies {\n  return RequestCookiesAdapter.seal(new RequestCookies(new Headers({})))\n}\n\ninterface CacheLifetime {}\nconst CachedCookies = new WeakMap<\n  CacheLifetime,\n  Promise<ReadonlyRequestCookies>\n>()\n\nfunction makeDynamicallyTrackedExoticCookies(\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyRequestCookies> {\n  const cachedPromise = CachedCookies.get(prerenderStore)\n  if (cachedPromise) {\n    return cachedPromise\n  }\n\n  const promise = makeHangingPromise<ReadonlyRequestCookies>()\n  CachedCookies.set(prerenderStore, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = 'cookies()[Symbol.iterator]()'\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    size: {\n      get() {\n        const expression = `cookies().size`\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    get: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = 'cookies().get()'\n        } else {\n          expression = `cookies().get(${describeNameArg(arguments[0])})`\n        }\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    getAll: {\n      value: function getAll() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = `cookies().getAll()`\n        } else {\n          expression = `cookies().getAll(${describeNameArg(arguments[0])})`\n        }\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    has: {\n      value: function has() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = `cookies().has()`\n        } else {\n          expression = `cookies().has(${describeNameArg(arguments[0])})`\n        }\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    set: {\n      value: function set() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = 'cookies().set()'\n        } else {\n          const arg = arguments[0]\n          if (arg) {\n            expression = `cookies().set(${describeNameArg(arg)}, ...)`\n          } else {\n            expression = `cookies().set(...)`\n          }\n        }\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    delete: {\n      value: function () {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = `cookies().delete()`\n        } else if (arguments.length === 1) {\n          expression = `cookies().delete(${describeNameArg(arguments[0])})`\n        } else {\n          expression = `cookies().delete(${describeNameArg(arguments[0])}, ...)`\n        }\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    clear: {\n      value: function clear() {\n        const expression = 'cookies().clear()'\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n    toString: {\n      value: function toString() {\n        const expression = 'cookies().toString()'\n        abortAndThrowOnSynchronousDynamicDataAccess(\n          route,\n          expression,\n          prerenderStore\n        )\n      },\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticCookies(\n  underlyingCookies: ReadonlyRequestCookies\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = makeResolvedReactPromise(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: underlyingCookies[Symbol.iterator]\n        ? underlyingCookies[Symbol.iterator].bind(underlyingCookies)\n        : // TODO this is a polyfill for when the underlying type is ResponseCookies\n          // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n          // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n          // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n          // has extra properties not available on RequestCookie instances.\n          polyfilledResponseCookiesIterator.bind(underlyingCookies),\n    },\n    size: {\n      get(): number {\n        return underlyingCookies.size\n      },\n    },\n    get: {\n      value: underlyingCookies.get.bind(underlyingCookies),\n    },\n    getAll: {\n      value: underlyingCookies.getAll.bind(underlyingCookies),\n    },\n    has: {\n      value: underlyingCookies.has.bind(underlyingCookies),\n    },\n    set: {\n      value: underlyingCookies.set.bind(underlyingCookies),\n    },\n    delete: {\n      value: underlyingCookies.delete.bind(underlyingCookies),\n    },\n    clear: {\n      value:\n        // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n        typeof underlyingCookies.clear === 'function'\n          ? // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n            underlyingCookies.clear.bind(underlyingCookies)\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.bind(underlyingCookies, promise),\n    },\n    toString: {\n      value: underlyingCookies.toString.bind(underlyingCookies),\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticCookiesWithDevWarnings(\n  underlyingCookies: ReadonlyRequestCookies,\n  route?: string\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = makeResolvedReactPromise(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: function () {\n        warnForSyncIteration(route)\n        return underlyingCookies[Symbol.iterator]\n          ? underlyingCookies[Symbol.iterator].apply(\n              underlyingCookies,\n              arguments as any\n            )\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesIterator.call(underlyingCookies)\n      },\n      writable: false,\n    },\n    size: {\n      get(): number {\n        const expression = 'cookies().size'\n        warnForSyncAccess(route, expression)\n        return underlyingCookies.size\n      },\n    },\n    get: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = 'cookies().get()'\n        } else {\n          expression = `cookies().get(${describeNameArg(arguments[0])})`\n        }\n        warnForSyncAccess(route, expression)\n        return underlyingCookies.get.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    getAll: {\n      value: function getAll() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = `cookies().getAll()`\n        } else {\n          expression = `cookies().getAll(${describeNameArg(arguments[0])})`\n        }\n        warnForSyncAccess(route, expression)\n        return underlyingCookies.getAll.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n    has: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = `cookies().has()`\n        } else {\n          expression = `cookies().has(${describeNameArg(arguments[0])})`\n        }\n        warnForSyncAccess(route, expression)\n        return underlyingCookies.has.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    set: {\n      value: function set() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = 'cookies().set()'\n        } else {\n          const arg = arguments[0]\n          if (arg) {\n            expression = `cookies().set(${describeNameArg(arg)}, ...)`\n          } else {\n            expression = `cookies().set(...)`\n          }\n        }\n        warnForSyncAccess(route, expression)\n        return underlyingCookies.set.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    delete: {\n      value: function () {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = `cookies().delete()`\n        } else if (arguments.length === 1) {\n          expression = `cookies().delete(${describeNameArg(arguments[0])})`\n        } else {\n          expression = `cookies().delete(${describeNameArg(arguments[0])}, ...)`\n        }\n        warnForSyncAccess(route, expression)\n        return underlyingCookies.delete.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n    clear: {\n      value: function clear() {\n        const expression = 'cookies().clear()'\n        warnForSyncAccess(route, expression)\n        // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n        return typeof underlyingCookies.clear === 'function'\n          ? // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n            underlyingCookies.clear.apply(underlyingCookies, arguments)\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.call(underlyingCookies, promise)\n      },\n      writable: false,\n    },\n    toString: {\n      value: function toString() {\n        const expression = 'cookies().toString()'\n        warnForSyncAccess(route, expression)\n        return underlyingCookies.toString.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction describeNameArg(arg: unknown) {\n  return typeof arg === 'object' &&\n    arg !== null &&\n    typeof (arg as any).name === 'string'\n    ? `'${(arg as any).name}'`\n    : typeof arg === 'string'\n      ? `'${arg}'`\n      : '...'\n}\n\nconst noop = () => {}\n\nconst warnForSyncIteration = process.env\n  .__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(\n      function getSyncIterationMessage(route?: string) {\n        const prefix = route ? ` In route ${route} ` : ''\n        return (\n          `${prefix}cookies were iterated over. ` +\n          `\\`cookies()\\` should be awaited before using its value. ` +\n          `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n        )\n      }\n    )\n\nconst warnForSyncAccess = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(function getSyncAccessMessage(\n      route: undefined | string,\n      expression: string\n    ) {\n      const prefix = route ? ` In route ${route} a ` : 'A '\n      return (\n        `${prefix}cookie property was accessed directly with \\`${expression}\\`. ` +\n        `\\`cookies()\\` should be awaited before using its value. ` +\n        `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n      )\n    })\n\nfunction polyfilledResponseCookiesIterator(\n  this: ResponseCookies\n): ReturnType<ReadonlyRequestCookies[typeof Symbol.iterator]> {\n  return this.getAll()\n    .map((c) => [c.name, c] as [string, any])\n    .values()\n}\n\nfunction polyfilledResponseCookiesClear(\n  this: ResponseCookies,\n  returnable: Promise<ReadonlyRequestCookies>\n): typeof returnable {\n  for (const cookie of this.getAll()) {\n    this.delete(cookie.name)\n  }\n  return returnable\n}\n\ntype CookieExtensions = {\n  [K in keyof ReadonlyRequestCookies | 'clear']: unknown\n}\n"],"names":["cookies","callingExpression","workStore","workAsyncStorage","getStore","workUnitStore","workUnitAsyncStorage","forceStatic","underlyingCookies","createEmptyCookies","makeUntrackedExoticCookies","type","Error","route","dynamicShouldError","StaticGenBailoutError","makeDynamicallyTrackedExoticCookies","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","trackDynamicDataInDynamicRender","actionStore","actionAsyncStorage","requestStore","getExpectedRequestStore","isAction","isAppRoute","mutableCookies","process","env","NODE_ENV","isPrefetchRequest","makeUntrackedExoticCookiesWithDevWarnings","RequestCookiesAdapter","seal","RequestCookies","Headers","CachedCookies","WeakMap","prerenderStore","cachedPromise","get","promise","makeHangingPromise","set","Object","defineProperties","Symbol","iterator","value","expression","abortAndThrowOnSynchronousDynamicDataAccess","size","arguments","length","describeNameArg","getAll","has","arg","delete","clear","toString","cachedCookies","makeResolvedReactPromise","bind","polyfilledResponseCookiesIterator","polyfilledResponseCookiesClear","warnForSyncIteration","apply","call","writable","warnForSyncAccess","name","noop","__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS","createDedupedByCallsiteServerErrorLoggerDev","getSyncIterationMessage","prefix","getSyncAccessMessage","map","c","values","returnable","cookie"],"mappings":"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"}