{"version":3,"sources":["../../../src/server/use-cache/cache-life.ts"],"sourcesContent":["import { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\n\nexport type CacheLife = {\n  // How long the client can cache a value without checking with the server.\n  stale?: number\n  // How frequently you want the cache to refresh on the server.\n  // Stale values may be served while revalidating.\n  revalidate?: number\n  // In the worst case scenario, where you haven't had traffic in a while,\n  // how stale can a value be until you prefer deopting to dynamic.\n  // Must be longer than revalidate.\n  expire?: number\n}\n// The equivalent header is kind of like:\n// Cache-Control: max-age=[stale],s-max-age=[revalidate],stale-while-revalidate=[expire-revalidate],stale-if-error=[expire-revalidate]\n// Except that stale-while-revalidate/stale-if-error only applies to shared caches - not private caches.\n\nconst cacheLifeProfileMap: Map<string, CacheLife> = new Map()\n\n// The default revalidates relatively frequently but doesn't expire to ensure it's always\n// able to serve fast results but by default doesn't hang.\n\nexport const defaultCacheLife = {\n  stale: Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME),\n  revalidate: 15 * 60, // Note: This is a new take on the defaults.\n  expire: Infinity,\n}\n\ncacheLifeProfileMap.set('default', defaultCacheLife)\n\ntype CacheLifeProfiles = 'default' // TODO: Generate from the config\n\nfunction validateCacheLife(profile: CacheLife) {\n  if (profile.stale !== undefined) {\n    if ((profile.stale as any) === false) {\n      throw new Error(\n        'Pass `Infinity` instead of `false` if you want to cache on the client forever ' +\n          'without checking with the server.'\n      )\n    } else if (typeof profile.stale !== 'number') {\n      throw new Error('The stale option must be a number of seconds.')\n    }\n  }\n  if (profile.revalidate !== undefined) {\n    if ((profile.revalidate as any) === false) {\n      throw new Error(\n        'Pass `Infinity` instead of `false` if you do not want to revalidate by time.'\n      )\n    } else if (typeof profile.revalidate !== 'number') {\n      throw new Error('The revalidate option must be a number of seconds.')\n    }\n  }\n  if (profile.expire !== undefined) {\n    if ((profile.expire as any) === false) {\n      throw new Error(\n        'Pass `Infinity` instead of `false` if you want to cache on the client forever ' +\n          'without checking with the server.'\n      )\n    } else if (typeof profile.expire !== 'number') {\n      throw new Error('The expire option must be a number of seconds.')\n    }\n  }\n\n  if (profile.revalidate !== undefined && profile.expire !== undefined) {\n    if (profile.revalidate > profile.expire) {\n      throw new Error(\n        'If providing both the revalidate and expire options, ' +\n          'the expire option must be greater than the revalidate option.' +\n          'The expire option indicates how many seconds from the start ' +\n          'until it can no longer be used.'\n      )\n    }\n  }\n\n  if (profile.stale !== undefined && profile.expire !== undefined) {\n    if (profile.stale > profile.expire) {\n      throw new Error(\n        'If providing both the stale and expire options, ' +\n          'the expire option must be greater than the stale option.' +\n          'The expire option indicates how many seconds from the start ' +\n          'until it can no longer be used.'\n      )\n    }\n  }\n}\n\nexport function cacheLife(profile: CacheLifeProfiles | CacheLife): void {\n  if (!process.env.__NEXT_DYNAMIC_IO) {\n    throw new Error(\n      'cacheLife() is only available with the experimental.dynamicIO config.'\n    )\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (!workUnitStore || workUnitStore.type !== 'cache') {\n    throw new Error(\n      'cacheLife() can only be called inside a \"use cache\" function.'\n    )\n  }\n\n  if (typeof profile === 'string') {\n    const configuredProfile = cacheLifeProfileMap.get(profile)\n    if (configuredProfile === undefined) {\n      if (cacheLifeProfileMap.has(profile.trim())) {\n        throw new Error(\n          `Unknown cacheLife profile \"${profile}\" is not configured in next.config.js\\n` +\n            `Did you mean \"${profile.trim()}\" without the spaces?`\n        )\n      }\n      throw new Error(\n        `Unknown cacheLife profile \"${profile}\" is not configured in next.config.js\\n` +\n          'module.exports = {\\n' +\n          '  experimental: {\\n' +\n          '    cacheLife: {\\n' +\n          `      \"${profile}\": ...\\n` +\n          '    }\\n' +\n          '  }\\n' +\n          '}'\n      )\n    }\n    profile = configuredProfile\n  } else if (\n    typeof profile !== 'object' ||\n    profile === null ||\n    Array.isArray(profile)\n  ) {\n    throw new Error(\n      'Invalid cacheLife() option. Either pass a profile name or object.'\n    )\n  } else {\n    validateCacheLife(profile)\n  }\n\n  if (profile.revalidate !== undefined) {\n    // Track the explicit revalidate time.\n    if (\n      workUnitStore.explicitRevalidate === undefined ||\n      workUnitStore.explicitRevalidate > profile.revalidate\n    ) {\n      workUnitStore.explicitRevalidate = profile.revalidate\n    }\n  }\n}\n"],"names":["cacheLife","defaultCacheLife","cacheLifeProfileMap","Map","stale","Number","process","env","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","revalidate","expire","Infinity","set","validateCacheLife","profile","undefined","Error","__NEXT_DYNAMIC_IO","workUnitStore","workUnitAsyncStorage","getStore","type","configuredProfile","get","has","trim","Array","isArray","explicitRevalidate"],"mappings":"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"}