"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unstable_after", {
    enumerable: true,
    get: function() {
        return unstable_after;
    }
});
const _workasyncstorageexternal = require("../app-render/work-async-storage.external");
const _workunitasyncstorageexternal = require("../app-render/work-unit-async-storage.external");
const _staticgenerationbailout = require("../../client/components/static-generation-bailout");
const _dynamicrendering = require("../app-render/dynamic-rendering");
function unstable_after(task) {
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (!workStore) {
        // TODO(after): the linked docs page talks about *dynamic* APIs, which unstable_after soon won't be anymore
        throw new Error('`unstable_after` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context');
    }
    const { afterContext } = workStore;
    if (!afterContext) {
        throw new Error('`unstable_after` must be explicitly enabled by setting `experimental.after: true` in your next.config.js.');
    }
    // TODO: After should not cause dynamic.
    const callingExpression = 'unstable_after';
    if (workStore.forceStatic) {
        throw new _staticgenerationbailout.StaticGenBailoutError(`Route ${workStore.route} with \`dynamic = "force-static"\` couldn't be rendered statically because it used \`${callingExpression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
    } else {
        (0, _dynamicrendering.markCurrentScopeAsDynamic)(workStore, workUnitStore, callingExpression);
    }
    afterContext.after(task);
}

//# sourceMappingURL=after.js.map