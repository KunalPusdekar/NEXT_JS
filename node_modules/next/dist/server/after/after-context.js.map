{"version":3,"sources":["../../../src/server/after/after-context.ts"],"sourcesContent":["import PromiseQueue from 'next/dist/compiled/p-queue'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { AfterCallback, AfterTask } from './after'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { withExecuteRevalidates } from './revalidation-utils'\nimport { bindSnapshot } from '../app-render/async-local-storage'\nimport {\n  workUnitAsyncStorage,\n  type WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\n\nexport type AfterContextOpts = {\n  waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  onClose: RequestLifecycleOpts['onClose'] | undefined\n}\n\nexport class AfterContext {\n  private waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  private onClose: RequestLifecycleOpts['onClose'] | undefined\n\n  private runCallbacksOnClosePromise: Promise<void> | undefined\n  private callbackQueue: PromiseQueue\n  private workUnitStores = new Set<WorkUnitStore>()\n\n  constructor({ waitUntil, onClose }: AfterContextOpts) {\n    this.waitUntil = waitUntil\n    this.onClose = onClose\n\n    this.callbackQueue = new PromiseQueue()\n    this.callbackQueue.pause()\n  }\n\n  public after(task: AfterTask): void {\n    if (isThenable(task)) {\n      task.catch(() => {}) // avoid unhandled rejection crashes\n      if (!this.waitUntil) {\n        errorWaitUntilNotAvailable()\n      }\n      this.waitUntil(task)\n    } else if (typeof task === 'function') {\n      // TODO(after): implement tracing\n      this.addCallback(task)\n    } else {\n      throw new Error(\n        '`unstable_after()`: Argument must be a promise or a function'\n      )\n    }\n  }\n\n  private addCallback(callback: AfterCallback) {\n    // if something is wrong, throw synchronously, bubbling up to the `unstable_after` callsite.\n    if (!this.waitUntil) {\n      errorWaitUntilNotAvailable()\n    }\n    if (!this.onClose) {\n      throw new InvariantError(\n        'unstable_after: Missing `onClose` implementation'\n      )\n    }\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (!workUnitStore) {\n      throw new InvariantError(\n        'Missing workUnitStore in AfterContext.addCallback'\n      )\n    }\n    this.workUnitStores.add(workUnitStore)\n\n    // this should only happen once.\n    if (!this.runCallbacksOnClosePromise) {\n      this.runCallbacksOnClosePromise = this.runCallbacksOnClose()\n      this.waitUntil(this.runCallbacksOnClosePromise)\n    }\n\n    // Bind the callback to the current execution context (i.e. preserve all currently available ALS-es).\n    // We do this because we want all of these to be equivalent in every regard except timing:\n    //   after(() => x())\n    //   after(x())\n    //   await x()\n    const wrappedCallback = bindSnapshot(async () => {\n      try {\n        await callback()\n      } catch (err) {\n        // TODO(after): this is fine for now, but will need better intergration with our error reporting.\n        console.error(\n          'An error occurred in a function passed to `unstable_after()`:',\n          err\n        )\n      }\n    })\n\n    this.callbackQueue.add(wrappedCallback)\n  }\n\n  private async runCallbacksOnClose() {\n    await new Promise<void>((resolve) => this.onClose!(resolve))\n    return this.runCallbacks()\n  }\n\n  private async runCallbacks(): Promise<void> {\n    if (this.callbackQueue.size === 0) return\n\n    for (const workUnitStore of this.workUnitStores) {\n      workUnitStore.phase = 'after'\n    }\n\n    const workStore = workAsyncStorage.getStore()\n    if (!workStore) {\n      throw new InvariantError('Missing workStore in AfterContext.runCallbacks')\n    }\n\n    return withExecuteRevalidates(workStore, () => {\n      this.callbackQueue.start()\n      return this.callbackQueue.onIdle()\n    })\n  }\n}\n\nfunction errorWaitUntilNotAvailable(): never {\n  throw new Error(\n    '`unstable_after()` will not work correctly, because `waitUntil` is not available in the current environment.'\n  )\n}\n"],"names":["AfterContext","constructor","waitUntil","onClose","workUnitStores","Set","callbackQueue","PromiseQueue","pause","after","task","isThenable","catch","errorWaitUntilNotAvailable","addCallback","Error","callback","InvariantError","workUnitStore","workUnitAsyncStorage","getStore","add","runCallbacksOnClosePromise","runCallbacksOnClose","wrappedCallback","bindSnapshot","err","console","error","Promise","resolve","runCallbacks","size","phase","workStore","workAsyncStorage","withExecuteRevalidates","start","onIdle"],"mappings":";;;;+BAkBaA;;;eAAAA;;;+DAlBY;gCAGM;4BACJ;0CACM;mCACM;mCACV;8CAItB;;;;;;AAOA,MAAMA;IAQXC,YAAY,EAAEC,SAAS,EAAEC,OAAO,EAAoB,CAAE;aAF9CC,iBAAiB,IAAIC;QAG3B,IAAI,CAACH,SAAS,GAAGA;QACjB,IAAI,CAACC,OAAO,GAAGA;QAEf,IAAI,CAACG,aAAa,GAAG,IAAIC,eAAY;QACrC,IAAI,CAACD,aAAa,CAACE,KAAK;IAC1B;IAEOC,MAAMC,IAAe,EAAQ;QAClC,IAAIC,IAAAA,sBAAU,EAACD,OAAO;YACpBA,KAAKE,KAAK,CAAC,KAAO,GAAG,oCAAoC;;YACzD,IAAI,CAAC,IAAI,CAACV,SAAS,EAAE;gBACnBW;YACF;YACA,IAAI,CAACX,SAAS,CAACQ;QACjB,OAAO,IAAI,OAAOA,SAAS,YAAY;YACrC,iCAAiC;YACjC,IAAI,CAACI,WAAW,CAACJ;QACnB,OAAO;YACL,MAAM,IAAIK,MACR;QAEJ;IACF;IAEQD,YAAYE,QAAuB,EAAE;QAC3C,4FAA4F;QAC5F,IAAI,CAAC,IAAI,CAACd,SAAS,EAAE;YACnBW;QACF;QACA,IAAI,CAAC,IAAI,CAACV,OAAO,EAAE;YACjB,MAAM,IAAIc,8BAAc,CACtB;QAEJ;QAEA,MAAMC,gBAAgBC,kDAAoB,CAACC,QAAQ;QACnD,IAAI,CAACF,eAAe;YAClB,MAAM,IAAID,8BAAc,CACtB;QAEJ;QACA,IAAI,CAACb,cAAc,CAACiB,GAAG,CAACH;QAExB,gCAAgC;QAChC,IAAI,CAAC,IAAI,CAACI,0BAA0B,EAAE;YACpC,IAAI,CAACA,0BAA0B,GAAG,IAAI,CAACC,mBAAmB;YAC1D,IAAI,CAACrB,SAAS,CAAC,IAAI,CAACoB,0BAA0B;QAChD;QAEA,qGAAqG;QACrG,0FAA0F;QAC1F,qBAAqB;QACrB,eAAe;QACf,cAAc;QACd,MAAME,kBAAkBC,IAAAA,+BAAY,EAAC;YACnC,IAAI;gBACF,MAAMT;YACR,EAAE,OAAOU,KAAK;gBACZ,iGAAiG;gBACjGC,QAAQC,KAAK,CACX,iEACAF;YAEJ;QACF;QAEA,IAAI,CAACpB,aAAa,CAACe,GAAG,CAACG;IACzB;IAEA,MAAcD,sBAAsB;QAClC,MAAM,IAAIM,QAAc,CAACC,UAAY,IAAI,CAAC3B,OAAO,CAAE2B;QACnD,OAAO,IAAI,CAACC,YAAY;IAC1B;IAEA,MAAcA,eAA8B;QAC1C,IAAI,IAAI,CAACzB,aAAa,CAAC0B,IAAI,KAAK,GAAG;QAEnC,KAAK,MAAMd,iBAAiB,IAAI,CAACd,cAAc,CAAE;YAC/Cc,cAAce,KAAK,GAAG;QACxB;QAEA,MAAMC,YAAYC,0CAAgB,CAACf,QAAQ;QAC3C,IAAI,CAACc,WAAW;YACd,MAAM,IAAIjB,8BAAc,CAAC;QAC3B;QAEA,OAAOmB,IAAAA,yCAAsB,EAACF,WAAW;YACvC,IAAI,CAAC5B,aAAa,CAAC+B,KAAK;YACxB,OAAO,IAAI,CAAC/B,aAAa,CAACgC,MAAM;QAClC;IACF;AACF;AAEA,SAASzB;IACP,MAAM,IAAIE,MACR;AAEJ"}