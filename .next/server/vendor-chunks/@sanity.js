/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sanity";
exports.ids = ["vendor-chunks/@sanity"];
exports.modules = {

/***/ "(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/native.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/native.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jb21saW5rL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyxpRUFBZTtBQUNmLGNBQWMsK0RBQWlCO0FBQy9CLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95Y19kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jb21saW5rL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzPzZhOTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5leHBvcnQgZGVmYXVsdCB7XG4gIHJhbmRvbVVVSUQ6IGNyeXB0by5yYW5kb21VVUlEXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/regex.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/regex.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jb21saW5rL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyw4RUFBOEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95Y19kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jb21saW5rL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanM/MDZjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLThdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMHxmZmZmZmZmZi1mZmZmLWZmZmYtZmZmZi1mZmZmZmZmZmZmZmYpJC9pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/rng.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/rng.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jb21saW5rL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkM7QUFDZTtBQUNmO0FBQ0EsSUFBSSxpRUFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95Y19kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jb21saW5rL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzP2M3ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5jb25zdCBybmRzOFBvb2wgPSBuZXcgVWludDhBcnJheSgyNTYpOyAvLyAjIG9mIHJhbmRvbSB2YWx1ZXMgdG8gcHJlLWFsbG9jYXRlXG5sZXQgcG9vbFB0ciA9IHJuZHM4UG9vbC5sZW5ndGg7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIGlmIChwb29sUHRyID4gcm5kczhQb29sLmxlbmd0aCAtIDE2KSB7XG4gICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKHJuZHM4UG9vbCk7XG4gICAgcG9vbFB0ciA9IDA7XG4gIH1cbiAgcmV0dXJuIHJuZHM4UG9vbC5zbGljZShwb29sUHRyLCBwb29sUHRyICs9IDE2KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/stringify.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/stringify.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/validate.js\");\n\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jb21saW5rL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWNfZGlyZWN0b3J5Ly4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY29tbGluay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3N0cmluZ2lmeS5qcz9iMDRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5jb25zdCBieXRlVG9IZXggPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICAvL1xuICAvLyBOb3RlIHRvIGZ1dHVyZS1zZWxmOiBObywgeW91IGNhbid0IHJlbW92ZSB0aGUgYHRvTG93ZXJDYXNlKClgIGNhbGwuXG4gIC8vIFJFRjogaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNjc3I2lzc3VlY29tbWVudC0xNzU3MzUxMzUxXG4gIHJldHVybiAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IHV1aWQgPSB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQpO1xuICAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG4gIHJldHVybiB1dWlkO1xufVxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/v4.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/v4.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jb21saW5rL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCO0FBQ2pEO0FBQ0EsTUFBTSxrREFBTTtBQUNaLFdBQVcsa0RBQU07QUFDakI7QUFDQTtBQUNBLGlEQUFpRCwrQ0FBRzs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95Y19kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jb21saW5rL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanM/OWFkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbmF0aXZlIGZyb20gJy4vbmF0aXZlLmpzJztcbmltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKG5hdGl2ZS5yYW5kb21VVUlEICYmICFidWYgJiYgIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmF0aXZlLnJhbmRvbVVVSUQoKTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIHJldHVybiB1bnNhZmVTdHJpbmdpZnkocm5kcyk7XG59XG5leHBvcnQgZGVmYXVsdCB2NDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/validate.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/validate.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/regex.js\");\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jb21saW5rL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7QUFDL0I7QUFDQSxxQ0FBcUMsaURBQUs7QUFDMUM7QUFDQSxpRUFBZSxRQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWNfZGlyZWN0b3J5Ly4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY29tbGluay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZhbGlkYXRlLmpzP2RmZDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/eventsource/node.js":
/*!**************************************************!*\
  !*** ./node_modules/@sanity/eventsource/node.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! eventsource */ \"(ssr)/./node_modules/eventsource/lib/eventsource.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9ldmVudHNvdXJjZS9ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBLDhHQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3ljX2RpcmVjdG9yeS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2V2ZW50c291cmNlL25vZGUuanM/OTY5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/eventsource/node.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@sanity/eventsource/node.js":
/*!**************************************************!*\
  !*** ./node_modules/@sanity/eventsource/node.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! eventsource */ \"(action-browser)/./node_modules/eventsource/lib/eventsource.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2V2ZW50c291cmNlL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUEseUhBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWNfZGlyZWN0b3J5Ly4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvZXZlbnRzb3VyY2Uvbm9kZS5qcz83ZDhkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzb3VyY2UnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@sanity/eventsource/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@sanity/eventsource/node.js":
/*!**************************************************!*\
  !*** ./node_modules/@sanity/eventsource/node.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! eventsource */ \"(rsc)/./node_modules/eventsource/lib/eventsource.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9ldmVudHNvdXJjZS9ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBLDhHQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3ljX2RpcmVjdG9yeS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2V2ZW50c291cmNlL25vZGUuanM/NzQzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@sanity/eventsource/node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js":
/*!************************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DRAFTS_PREFIX: () => (/* binding */ DRAFTS_PREFIX),\n/* harmony export */   createEditUrl: () => (/* binding */ createEditUrl),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getPublishedId: () => (/* binding */ getPublishedId),\n/* harmony export */   jsonPath: () => (/* binding */ jsonPath),\n/* harmony export */   jsonPathToStudioPath: () => (/* binding */ jsonPathToStudioPath),\n/* harmony export */   parseJsonPath: () => (/* binding */ parseJsonPath),\n/* harmony export */   reKeySegment: () => (/* binding */ reKeySegment),\n/* harmony export */   resolveEditInfo: () => (/* binding */ resolveEditInfo),\n/* harmony export */   resolveMapping: () => (/* binding */ resolveMapping),\n/* harmony export */   resolveStudioBaseRoute: () => (/* binding */ resolveStudioBaseRoute),\n/* harmony export */   studioPath: () => (/* binding */ studioPath),\n/* harmony export */   studioPathToJsonPath: () => (/* binding */ studioPathToJsonPath),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   walkMap: () => (/* binding */ walkMap)\n/* harmony export */ });\nconst rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/, reIndexTuple = /^\\d*:\\d*$/;\nfunction isIndexSegment(segment) {\n  return typeof segment == \"number\" || typeof segment == \"string\" && /^\\[\\d+\\]$/.test(segment);\n}\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction isIndexTuple(segment) {\n  if (typeof segment == \"string\" && reIndexTuple.test(segment))\n    return !0;\n  if (!Array.isArray(segment) || segment.length !== 2)\n    return !1;\n  const [from, to] = segment;\n  return (typeof from == \"number\" || from === \"\") && (typeof to == \"number\" || to === \"\");\n}\nfunction get(obj, path, defaultVal) {\n  const select = typeof path == \"string\" ? fromString(path) : path;\n  if (!Array.isArray(select))\n    throw new Error(\"Path must be an array or a string\");\n  let acc = obj;\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i];\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc))\n        return defaultVal;\n      acc = acc[segment];\n    }\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc))\n        return defaultVal;\n      acc = acc.find((item) => item._key === segment._key);\n    }\n    if (typeof segment == \"string\" && (acc = typeof acc == \"object\" && acc !== null ? acc[segment] : void 0), typeof acc > \"u\")\n      return defaultVal;\n  }\n  return acc;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\")\n      return `${target}[${segment}]`;\n    if (segmentType === \"string\")\n      return `${target}${i === 0 ? \"\" : \".\"}${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nfunction fromString(path) {\n  if (typeof path != \"string\")\n    throw new Error(\"Path is not a string\");\n  const segments = path.match(rePropName);\n  if (!segments)\n    throw new Error(\"Invalid path string\");\n  return segments.map(parsePathSegment);\n}\nfunction parsePathSegment(segment) {\n  return isIndexSegment(segment) ? parseIndexSegment(segment) : isKeySegment(segment) ? parseKeySegment(segment) : isIndexTuple(segment) ? parseIndexTupleSegment(segment) : segment;\n}\nfunction parseIndexSegment(segment) {\n  return Number(segment.replace(/[^\\d]/g, \"\"));\n}\nfunction parseKeySegment(segment) {\n  return { _key: segment.match(reKeySegment)[1] };\n}\nfunction parseIndexTupleSegment(segment) {\n  const [from, to] = segment.split(\":\").map((seg) => seg === \"\" ? seg : Number(seg));\n  return [from, to];\n}\nvar studioPath = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  fromString,\n  get,\n  isIndexSegment,\n  isIndexTuple,\n  isKeySegment,\n  reKeySegment,\n  toString\n});\nconst DRAFTS_PREFIX = \"drafts.\";\nfunction getPublishedId(id) {\n  return id.startsWith(DRAFTS_PREFIX) ? id.slice(DRAFTS_PREFIX.length) : id;\n}\nconst ESCAPE = {\n  \"\\f\": \"\\\\f\",\n  \"\\n\": \"\\\\n\",\n  \"\\r\": \"\\\\r\",\n  \"\t\": \"\\\\t\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n}, UNESCAPE = {\n  \"\\\\f\": \"\\f\",\n  \"\\\\n\": `\n`,\n  \"\\\\r\": \"\\r\",\n  \"\\\\t\": \"\t\",\n  \"\\\\'\": \"'\",\n  \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n  return `$${path.map((segment) => typeof segment == \"string\" ? `['${segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => ESCAPE[match])}']` : typeof segment == \"number\" ? `[${segment}]` : segment._key !== \"\" ? `[?(@._key=='${segment._key.replace(/['\\\\]/g, (match) => ESCAPE[match])}')]` : `[${segment._index}]`).join(\"\")}`;\n}\nfunction parseJsonPath(path) {\n  const parsed = [], parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  for (; (match = parseRe.exec(path)) !== null; ) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => UNESCAPE[m]);\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => UNESCAPE[m]);\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._key !== \"\")\n      return { _key: segment._key };\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction studioPathToJsonPath(path) {\n  return (typeof path == \"string\" ? fromString(path) : path).map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (Array.isArray(segment))\n      throw new Error(`IndexTuple segments aren't supported:${JSON.stringify(segment)}`);\n    if (isContentSourceMapParsedPathKeyedSegment(segment))\n      return segment;\n    if (segment._key)\n      return { _key: segment._key, _index: -1 };\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction isContentSourceMapParsedPathKeyedSegment(segment) {\n  return typeof segment == \"object\" && \"_key\" in segment && \"_index\" in segment;\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction resolveMapping(resultPath, csm) {\n  if (!csm?.mappings)\n    return;\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0)\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: \"\"\n    };\n  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);\n  if (mappings.length == 0)\n    return;\n  const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return { mapping, matchedPath, pathSuffix };\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction isRecord(value) {\n  return typeof value == \"object\" && value !== null;\n}\nfunction walkMap(value, mappingFn, path = []) {\n  if (isArray(value))\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v._key;\n        if (typeof _key == \"string\")\n          return walkMap(v, mappingFn, path.concat({ _key, _index: idx }));\n      }\n      return walkMap(v, mappingFn, path.concat(idx));\n    });\n  if (isRecord(value)) {\n    if (value._type === \"block\" || value._type === \"span\") {\n      const result = { ...value };\n      return value._type === \"block\" ? result.children = walkMap(value.children, mappingFn, path.concat(\"children\")) : value._type === \"span\" && (result.text = walkMap(value.text, mappingFn, path.concat(\"text\"))), result;\n    }\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))])\n    );\n  }\n  return mappingFn(value, path);\n}\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path,\n    projectId,\n    dataset\n  } = options;\n  if (!baseUrl)\n    throw new Error(\"baseUrl is required\");\n  if (!path)\n    throw new Error(\"path is required\");\n  if (!_id)\n    throw new Error(\"id is required\");\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\"))\n    throw new Error(\"baseUrl must not end with a slash\");\n  const workspace = _workspace === \"default\" ? void 0 : _workspace, tool = _tool === \"default\" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath\n  });\n  workspace && searchParams.set(\"workspace\", workspace), tool && searchParams.set(\"tool\", tool), projectId && searchParams.set(\"projectId\", projectId), dataset && searchParams.set(\"dataset\", dataset), _id.startsWith(DRAFTS_PREFIX) && searchParams.set(\"isDraft\", \"\");\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  workspace && segments.push(workspace);\n  const routerParams = [\n    \"mode=presentation\",\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`\n  ];\n  return tool && routerParams.push(`tool=${tool}`), segments.push(\"intent\", \"edit\", `${routerParams.join(\";\")}?${searchParams}`), segments.join(\"/\");\n}\nfunction resolveEditInfo(options) {\n  const { resultSourceMap: csm, resultPath } = options, { mapping, pathSuffix } = resolveMapping(resultPath, csm) || {};\n  if (!mapping || mapping.source.type === \"literal\" || mapping.source.type === \"unknown\")\n    return;\n  const sourceDoc = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path];\n  if (sourceDoc && sourcePath) {\n    const { baseUrl, workspace, tool } = resolveStudioBaseRoute(\n      typeof options.studioUrl == \"function\" ? options.studioUrl(sourceDoc) : options.studioUrl\n    );\n    if (!baseUrl)\n      return;\n    const { _id, _type, _projectId, _dataset } = sourceDoc;\n    return {\n      baseUrl,\n      workspace,\n      tool,\n      id: _id,\n      type: _type,\n      path: parseJsonPath(sourcePath + pathSuffix),\n      projectId: _projectId,\n      dataset: _dataset\n    };\n  }\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl == \"string\" ? studioUrl : studioUrl.baseUrl;\n  return baseUrl !== \"/\" && (baseUrl = baseUrl.replace(/\\/$/, \"\")), typeof studioUrl == \"string\" ? { baseUrl } : { ...studioUrl, baseUrl };\n}\n\n//# sourceMappingURL=resolveEditInfo.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzLWVzL3Jlc29sdmVFZGl0SW5mby5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPLEdBQUcsUUFBUTtBQUNsQztBQUNBLGdCQUFnQixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsUUFBUTtBQUN0RDtBQUNBLGdCQUFnQixPQUFPLFVBQVUsYUFBYTtBQUM5QztBQUNBO0FBQ0EsZ0JBQWdCLE9BQU8sR0FBRyxLQUFLLEdBQUcsR0FBRztBQUNyQztBQUNBLGtEQUFrRCx3QkFBd0I7QUFDMUUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdEQUF3RCw0REFBNEQsdUNBQXVDLFFBQVEsMENBQTBDLHlEQUF5RCxXQUFXLGVBQWUsYUFBYTtBQUMxVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdUNBQXVDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx3QkFBd0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLHVDQUF1Qyx3QkFBd0I7QUFDL0QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG1CQUFtQjtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEdBQUc7QUFDYixZQUFZLEtBQUs7QUFDakIsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQSwyQ0FBMkMsS0FBSyx1Q0FBdUMsb0JBQW9CLEdBQUcsR0FBRyxhQUFhO0FBQzlIO0FBQ0E7QUFDQSxVQUFVLG1DQUFtQyxhQUFhLHNCQUFzQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxVQUFVLElBQUk7QUFDbkg7QUFpQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3ljX2RpcmVjdG9yeS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L19jaHVua3MtZXMvcmVzb2x2ZUVkaXRJbmZvLmpzP2MyNzMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZywgcmVLZXlTZWdtZW50ID0gL19rZXlcXHMqPT1cXHMqWydcIl0oLiopWydcIl0vLCByZUluZGV4VHVwbGUgPSAvXlxcZCo6XFxkKiQvO1xuZnVuY3Rpb24gaXNJbmRleFNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiICYmIC9eXFxbXFxkK1xcXSQvLnRlc3Qoc2VnbWVudCk7XG59XG5mdW5jdGlvbiBpc0tleVNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gdHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiA/IHJlS2V5U2VnbWVudC50ZXN0KHNlZ21lbnQudHJpbSgpKSA6IHR5cGVvZiBzZWdtZW50ID09IFwib2JqZWN0XCIgJiYgXCJfa2V5XCIgaW4gc2VnbWVudDtcbn1cbmZ1bmN0aW9uIGlzSW5kZXhUdXBsZShzZWdtZW50KSB7XG4gIGlmICh0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiICYmIHJlSW5kZXhUdXBsZS50ZXN0KHNlZ21lbnQpKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHNlZ21lbnQpIHx8IHNlZ21lbnQubGVuZ3RoICE9PSAyKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgW2Zyb20sIHRvXSA9IHNlZ21lbnQ7XG4gIHJldHVybiAodHlwZW9mIGZyb20gPT0gXCJudW1iZXJcIiB8fCBmcm9tID09PSBcIlwiKSAmJiAodHlwZW9mIHRvID09IFwibnVtYmVyXCIgfHwgdG8gPT09IFwiXCIpO1xufVxuZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCwgZGVmYXVsdFZhbCkge1xuICBjb25zdCBzZWxlY3QgPSB0eXBlb2YgcGF0aCA9PSBcInN0cmluZ1wiID8gZnJvbVN0cmluZyhwYXRoKSA6IHBhdGg7XG4gIGlmICghQXJyYXkuaXNBcnJheShzZWxlY3QpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggbXVzdCBiZSBhbiBhcnJheSBvciBhIHN0cmluZ1wiKTtcbiAgbGV0IGFjYyA9IG9iajtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VsZWN0W2ldO1xuICAgIGlmIChpc0luZGV4U2VnbWVudChzZWdtZW50KSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFjYykpXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsO1xuICAgICAgYWNjID0gYWNjW3NlZ21lbnRdO1xuICAgIH1cbiAgICBpZiAoaXNLZXlTZWdtZW50KHNlZ21lbnQpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWNjKSlcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWw7XG4gICAgICBhY2MgPSBhY2MuZmluZCgoaXRlbSkgPT4gaXRlbS5fa2V5ID09PSBzZWdtZW50Ll9rZXkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiAmJiAoYWNjID0gdHlwZW9mIGFjYyA9PSBcIm9iamVjdFwiICYmIGFjYyAhPT0gbnVsbCA/IGFjY1tzZWdtZW50XSA6IHZvaWQgMCksIHR5cGVvZiBhY2MgPiBcInVcIilcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsO1xuICB9XG4gIHJldHVybiBhY2M7XG59XG5mdW5jdGlvbiB0b1N0cmluZyhwYXRoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIGlzIG5vdCBhbiBhcnJheVwiKTtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKCh0YXJnZXQsIHNlZ21lbnQsIGkpID0+IHtcbiAgICBjb25zdCBzZWdtZW50VHlwZSA9IHR5cGVvZiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50VHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9WyR7c2VnbWVudH1dYDtcbiAgICBpZiAoc2VnbWVudFR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fSR7aSA9PT0gMCA/IFwiXCIgOiBcIi5cIn0ke3NlZ21lbnR9YDtcbiAgICBpZiAoaXNLZXlTZWdtZW50KHNlZ21lbnQpICYmIHNlZ21lbnQuX2tleSlcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9W19rZXk9PVwiJHtzZWdtZW50Ll9rZXl9XCJdYDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZWdtZW50KSkge1xuICAgICAgY29uc3QgW2Zyb20sIHRvXSA9IHNlZ21lbnQ7XG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVske2Zyb219OiR7dG99XWA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGF0aCBzZWdtZW50IFxcYCR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9XFxgYCk7XG4gIH0sIFwiXCIpO1xufVxuZnVuY3Rpb24gZnJvbVN0cmluZyhwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggaXMgbm90IGEgc3RyaW5nXCIpO1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGgubWF0Y2gocmVQcm9wTmFtZSk7XG4gIGlmICghc2VnbWVudHMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXRoIHN0cmluZ1wiKTtcbiAgcmV0dXJuIHNlZ21lbnRzLm1hcChwYXJzZVBhdGhTZWdtZW50KTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGF0aFNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gaXNJbmRleFNlZ21lbnQoc2VnbWVudCkgPyBwYXJzZUluZGV4U2VnbWVudChzZWdtZW50KSA6IGlzS2V5U2VnbWVudChzZWdtZW50KSA/IHBhcnNlS2V5U2VnbWVudChzZWdtZW50KSA6IGlzSW5kZXhUdXBsZShzZWdtZW50KSA/IHBhcnNlSW5kZXhUdXBsZVNlZ21lbnQoc2VnbWVudCkgOiBzZWdtZW50O1xufVxuZnVuY3Rpb24gcGFyc2VJbmRleFNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gTnVtYmVyKHNlZ21lbnQucmVwbGFjZSgvW15cXGRdL2csIFwiXCIpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlS2V5U2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiB7IF9rZXk6IHNlZ21lbnQubWF0Y2gocmVLZXlTZWdtZW50KVsxXSB9O1xufVxuZnVuY3Rpb24gcGFyc2VJbmRleFR1cGxlU2VnbWVudChzZWdtZW50KSB7XG4gIGNvbnN0IFtmcm9tLCB0b10gPSBzZWdtZW50LnNwbGl0KFwiOlwiKS5tYXAoKHNlZykgPT4gc2VnID09PSBcIlwiID8gc2VnIDogTnVtYmVyKHNlZykpO1xuICByZXR1cm4gW2Zyb20sIHRvXTtcbn1cbnZhciBzdHVkaW9QYXRoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGZyb21TdHJpbmcsXG4gIGdldCxcbiAgaXNJbmRleFNlZ21lbnQsXG4gIGlzSW5kZXhUdXBsZSxcbiAgaXNLZXlTZWdtZW50LFxuICByZUtleVNlZ21lbnQsXG4gIHRvU3RyaW5nXG59KTtcbmNvbnN0IERSQUZUU19QUkVGSVggPSBcImRyYWZ0cy5cIjtcbmZ1bmN0aW9uIGdldFB1Ymxpc2hlZElkKGlkKSB7XG4gIHJldHVybiBpZC5zdGFydHNXaXRoKERSQUZUU19QUkVGSVgpID8gaWQuc2xpY2UoRFJBRlRTX1BSRUZJWC5sZW5ndGgpIDogaWQ7XG59XG5jb25zdCBFU0NBUEUgPSB7XG4gIFwiXFxmXCI6IFwiXFxcXGZcIixcbiAgXCJcXG5cIjogXCJcXFxcblwiLFxuICBcIlxcclwiOiBcIlxcXFxyXCIsXG4gIFwiXHRcIjogXCJcXFxcdFwiLFxuICBcIidcIjogXCJcXFxcJ1wiLFxuICBcIlxcXFxcIjogXCJcXFxcXFxcXFwiXG59LCBVTkVTQ0FQRSA9IHtcbiAgXCJcXFxcZlwiOiBcIlxcZlwiLFxuICBcIlxcXFxuXCI6IGBcbmAsXG4gIFwiXFxcXHJcIjogXCJcXHJcIixcbiAgXCJcXFxcdFwiOiBcIlx0XCIsXG4gIFwiXFxcXCdcIjogXCInXCIsXG4gIFwiXFxcXFxcXFxcIjogXCJcXFxcXCJcbn07XG5mdW5jdGlvbiBqc29uUGF0aChwYXRoKSB7XG4gIHJldHVybiBgJCR7cGF0aC5tYXAoKHNlZ21lbnQpID0+IHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgPyBgWycke3NlZ21lbnQucmVwbGFjZSgvW1xcZlxcblxcclxcdCdcXFxcXS9nLCAobWF0Y2gpID0+IEVTQ0FQRVttYXRjaF0pfSddYCA6IHR5cGVvZiBzZWdtZW50ID09IFwibnVtYmVyXCIgPyBgWyR7c2VnbWVudH1dYCA6IHNlZ21lbnQuX2tleSAhPT0gXCJcIiA/IGBbPyhALl9rZXk9PScke3NlZ21lbnQuX2tleS5yZXBsYWNlKC9bJ1xcXFxdL2csIChtYXRjaCkgPT4gRVNDQVBFW21hdGNoXSl9JyldYCA6IGBbJHtzZWdtZW50Ll9pbmRleH1dYCkuam9pbihcIlwiKX1gO1xufVxuZnVuY3Rpb24gcGFyc2VKc29uUGF0aChwYXRoKSB7XG4gIGNvbnN0IHBhcnNlZCA9IFtdLCBwYXJzZVJlID0gL1xcWycoLio/KSdcXF18XFxbKFxcZCspXFxdfFxcW1xcP1xcKEBcXC5fa2V5PT0nKC4qPyknXFwpXFxdL2c7XG4gIGxldCBtYXRjaDtcbiAgZm9yICg7IChtYXRjaCA9IHBhcnNlUmUuZXhlYyhwYXRoKSkgIT09IG51bGw7ICkge1xuICAgIGlmIChtYXRjaFsxXSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBrZXkgPSBtYXRjaFsxXS5yZXBsYWNlKC9cXFxcKFxcXFx8ZnxufHJ8dHwnKS9nLCAobSkgPT4gVU5FU0NBUEVbbV0pO1xuICAgICAgcGFyc2VkLnB1c2goa2V5KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbMl0gIT09IHZvaWQgMCkge1xuICAgICAgcGFyc2VkLnB1c2gocGFyc2VJbnQobWF0Y2hbMl0sIDEwKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzNdICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IF9rZXkgPSBtYXRjaFszXS5yZXBsYWNlKC9cXFxcKFxcXFwnKS9nLCAobSkgPT4gVU5FU0NBUEVbbV0pO1xuICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICBfa2V5LFxuICAgICAgICBfaW5kZXg6IC0xXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuZnVuY3Rpb24ganNvblBhdGhUb1N0dWRpb1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgaWYgKHNlZ21lbnQuX2tleSAhPT0gXCJcIilcbiAgICAgIHJldHVybiB7IF9rZXk6IHNlZ21lbnQuX2tleSB9O1xuICAgIGlmIChzZWdtZW50Ll9pbmRleCAhPT0gLTEpXG4gICAgICByZXR1cm4gc2VnbWVudC5faW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNlZ21lbnQ6JHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1gKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzdHVkaW9QYXRoVG9Kc29uUGF0aChwYXRoKSB7XG4gIHJldHVybiAodHlwZW9mIHBhdGggPT0gXCJzdHJpbmdcIiA/IGZyb21TdHJpbmcocGF0aCkgOiBwYXRoKS5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2VnbWVudCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluZGV4VHVwbGUgc2VnbWVudHMgYXJlbid0IHN1cHBvcnRlZDoke0pTT04uc3RyaW5naWZ5KHNlZ21lbnQpfWApO1xuICAgIGlmIChpc0NvbnRlbnRTb3VyY2VNYXBQYXJzZWRQYXRoS2V5ZWRTZWdtZW50KHNlZ21lbnQpKVxuICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgaWYgKHNlZ21lbnQuX2tleSlcbiAgICAgIHJldHVybiB7IF9rZXk6IHNlZ21lbnQuX2tleSwgX2luZGV4OiAtMSB9O1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzZWdtZW50OiR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9YCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNDb250ZW50U291cmNlTWFwUGFyc2VkUGF0aEtleWVkU2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiB0eXBlb2Ygc2VnbWVudCA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHNlZ21lbnQgJiYgXCJfaW5kZXhcIiBpbiBzZWdtZW50O1xufVxuZnVuY3Rpb24ganNvblBhdGhUb01hcHBpbmdQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubWFwKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50Ll9pbmRleCAhPT0gLTEpXG4gICAgICByZXR1cm4gc2VnbWVudC5faW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNlZ21lbnQ6JHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1gKTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNvbHZlTWFwcGluZyhyZXN1bHRQYXRoLCBjc20pIHtcbiAgaWYgKCFjc20/Lm1hcHBpbmdzKVxuICAgIHJldHVybjtcbiAgY29uc3QgcmVzdWx0TWFwcGluZ1BhdGggPSBqc29uUGF0aChqc29uUGF0aFRvTWFwcGluZ1BhdGgocmVzdWx0UGF0aCkpO1xuICBpZiAoY3NtLm1hcHBpbmdzW3Jlc3VsdE1hcHBpbmdQYXRoXSAhPT0gdm9pZCAwKVxuICAgIHJldHVybiB7XG4gICAgICBtYXBwaW5nOiBjc20ubWFwcGluZ3NbcmVzdWx0TWFwcGluZ1BhdGhdLFxuICAgICAgbWF0Y2hlZFBhdGg6IHJlc3VsdE1hcHBpbmdQYXRoLFxuICAgICAgcGF0aFN1ZmZpeDogXCJcIlxuICAgIH07XG4gIGNvbnN0IG1hcHBpbmdzID0gT2JqZWN0LmVudHJpZXMoY3NtLm1hcHBpbmdzKS5maWx0ZXIoKFtrZXldKSA9PiByZXN1bHRNYXBwaW5nUGF0aC5zdGFydHNXaXRoKGtleSkpLnNvcnQoKFtrZXkxXSwgW2tleTJdKSA9PiBrZXkyLmxlbmd0aCAtIGtleTEubGVuZ3RoKTtcbiAgaWYgKG1hcHBpbmdzLmxlbmd0aCA9PSAwKVxuICAgIHJldHVybjtcbiAgY29uc3QgW21hdGNoZWRQYXRoLCBtYXBwaW5nXSA9IG1hcHBpbmdzWzBdLCBwYXRoU3VmZml4ID0gcmVzdWx0TWFwcGluZ1BhdGguc3Vic3RyaW5nKG1hdGNoZWRQYXRoLmxlbmd0aCk7XG4gIHJldHVybiB7IG1hcHBpbmcsIG1hdGNoZWRQYXRoLCBwYXRoU3VmZml4IH07XG59XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHdhbGtNYXAodmFsdWUsIG1hcHBpbmdGbiwgcGF0aCA9IFtdKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpZHgpID0+IHtcbiAgICAgIGlmIChpc1JlY29yZCh2KSkge1xuICAgICAgICBjb25zdCBfa2V5ID0gdi5fa2V5O1xuICAgICAgICBpZiAodHlwZW9mIF9rZXkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KHsgX2tleSwgX2luZGV4OiBpZHggfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhbGtNYXAodiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChpZHgpKTtcbiAgICB9KTtcbiAgaWYgKGlzUmVjb3JkKHZhbHVlKSkge1xuICAgIGlmICh2YWx1ZS5fdHlwZSA9PT0gXCJibG9ja1wiIHx8IHZhbHVlLl90eXBlID09PSBcInNwYW5cIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0geyAuLi52YWx1ZSB9O1xuICAgICAgcmV0dXJuIHZhbHVlLl90eXBlID09PSBcImJsb2NrXCIgPyByZXN1bHQuY2hpbGRyZW4gPSB3YWxrTWFwKHZhbHVlLmNoaWxkcmVuLCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KFwiY2hpbGRyZW5cIikpIDogdmFsdWUuX3R5cGUgPT09IFwic3BhblwiICYmIChyZXN1bHQudGV4dCA9IHdhbGtNYXAodmFsdWUudGV4dCwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChcInRleHRcIikpKSwgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW2ssIHZdKSA9PiBbaywgd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KGspKV0pXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbWFwcGluZ0ZuKHZhbHVlLCBwYXRoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVkaXRVcmwob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYmFzZVVybCxcbiAgICB3b3Jrc3BhY2U6IF93b3Jrc3BhY2UgPSBcImRlZmF1bHRcIixcbiAgICB0b29sOiBfdG9vbCA9IFwiZGVmYXVsdFwiLFxuICAgIGlkOiBfaWQsXG4gICAgdHlwZSxcbiAgICBwYXRoLFxuICAgIHByb2plY3RJZCxcbiAgICBkYXRhc2V0XG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIWJhc2VVcmwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZVVybCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKCFwYXRoKVxuICAgIHRocm93IG5ldyBFcnJvcihcInBhdGggaXMgcmVxdWlyZWRcIik7XG4gIGlmICghX2lkKVxuICAgIHRocm93IG5ldyBFcnJvcihcImlkIGlzIHJlcXVpcmVkXCIpO1xuICBpZiAoYmFzZVVybCAhPT0gXCIvXCIgJiYgYmFzZVVybC5lbmRzV2l0aChcIi9cIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZVVybCBtdXN0IG5vdCBlbmQgd2l0aCBhIHNsYXNoXCIpO1xuICBjb25zdCB3b3Jrc3BhY2UgPSBfd29ya3NwYWNlID09PSBcImRlZmF1bHRcIiA/IHZvaWQgMCA6IF93b3Jrc3BhY2UsIHRvb2wgPSBfdG9vbCA9PT0gXCJkZWZhdWx0XCIgPyB2b2lkIDAgOiBfdG9vbCwgaWQgPSBnZXRQdWJsaXNoZWRJZChfaWQpLCBzdHJpbmdpZmllZFBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gdG9TdHJpbmcoanNvblBhdGhUb1N0dWRpb1BhdGgocGF0aCkpIDogcGF0aCwgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgYmFzZVVybCxcbiAgICBpZCxcbiAgICB0eXBlLFxuICAgIHBhdGg6IHN0cmluZ2lmaWVkUGF0aFxuICB9KTtcbiAgd29ya3NwYWNlICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJ3b3Jrc3BhY2VcIiwgd29ya3NwYWNlKSwgdG9vbCAmJiBzZWFyY2hQYXJhbXMuc2V0KFwidG9vbFwiLCB0b29sKSwgcHJvamVjdElkICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJwcm9qZWN0SWRcIiwgcHJvamVjdElkKSwgZGF0YXNldCAmJiBzZWFyY2hQYXJhbXMuc2V0KFwiZGF0YXNldFwiLCBkYXRhc2V0KSwgX2lkLnN0YXJ0c1dpdGgoRFJBRlRTX1BSRUZJWCkgJiYgc2VhcmNoUGFyYW1zLnNldChcImlzRHJhZnRcIiwgXCJcIik7XG4gIGNvbnN0IHNlZ21lbnRzID0gW2Jhc2VVcmwgPT09IFwiL1wiID8gXCJcIiA6IGJhc2VVcmxdO1xuICB3b3Jrc3BhY2UgJiYgc2VnbWVudHMucHVzaCh3b3Jrc3BhY2UpO1xuICBjb25zdCByb3V0ZXJQYXJhbXMgPSBbXG4gICAgXCJtb2RlPXByZXNlbnRhdGlvblwiLFxuICAgIGBpZD0ke2lkfWAsXG4gICAgYHR5cGU9JHt0eXBlfWAsXG4gICAgYHBhdGg9JHtlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZpZWRQYXRoKX1gXG4gIF07XG4gIHJldHVybiB0b29sICYmIHJvdXRlclBhcmFtcy5wdXNoKGB0b29sPSR7dG9vbH1gKSwgc2VnbWVudHMucHVzaChcImludGVudFwiLCBcImVkaXRcIiwgYCR7cm91dGVyUGFyYW1zLmpvaW4oXCI7XCIpfT8ke3NlYXJjaFBhcmFtc31gKSwgc2VnbWVudHMuam9pbihcIi9cIik7XG59XG5mdW5jdGlvbiByZXNvbHZlRWRpdEluZm8ob3B0aW9ucykge1xuICBjb25zdCB7IHJlc3VsdFNvdXJjZU1hcDogY3NtLCByZXN1bHRQYXRoIH0gPSBvcHRpb25zLCB7IG1hcHBpbmcsIHBhdGhTdWZmaXggfSA9IHJlc29sdmVNYXBwaW5nKHJlc3VsdFBhdGgsIGNzbSkgfHwge307XG4gIGlmICghbWFwcGluZyB8fCBtYXBwaW5nLnNvdXJjZS50eXBlID09PSBcImxpdGVyYWxcIiB8fCBtYXBwaW5nLnNvdXJjZS50eXBlID09PSBcInVua25vd25cIilcbiAgICByZXR1cm47XG4gIGNvbnN0IHNvdXJjZURvYyA9IGNzbS5kb2N1bWVudHNbbWFwcGluZy5zb3VyY2UuZG9jdW1lbnRdLCBzb3VyY2VQYXRoID0gY3NtLnBhdGhzW21hcHBpbmcuc291cmNlLnBhdGhdO1xuICBpZiAoc291cmNlRG9jICYmIHNvdXJjZVBhdGgpIHtcbiAgICBjb25zdCB7IGJhc2VVcmwsIHdvcmtzcGFjZSwgdG9vbCB9ID0gcmVzb2x2ZVN0dWRpb0Jhc2VSb3V0ZShcbiAgICAgIHR5cGVvZiBvcHRpb25zLnN0dWRpb1VybCA9PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLnN0dWRpb1VybChzb3VyY2VEb2MpIDogb3B0aW9ucy5zdHVkaW9VcmxcbiAgICApO1xuICAgIGlmICghYmFzZVVybClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IF9pZCwgX3R5cGUsIF9wcm9qZWN0SWQsIF9kYXRhc2V0IH0gPSBzb3VyY2VEb2M7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2VVcmwsXG4gICAgICB3b3Jrc3BhY2UsXG4gICAgICB0b29sLFxuICAgICAgaWQ6IF9pZCxcbiAgICAgIHR5cGU6IF90eXBlLFxuICAgICAgcGF0aDogcGFyc2VKc29uUGF0aChzb3VyY2VQYXRoICsgcGF0aFN1ZmZpeCksXG4gICAgICBwcm9qZWN0SWQ6IF9wcm9qZWN0SWQsXG4gICAgICBkYXRhc2V0OiBfZGF0YXNldFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVTdHVkaW9CYXNlUm91dGUoc3R1ZGlvVXJsKSB7XG4gIGxldCBiYXNlVXJsID0gdHlwZW9mIHN0dWRpb1VybCA9PSBcInN0cmluZ1wiID8gc3R1ZGlvVXJsIDogc3R1ZGlvVXJsLmJhc2VVcmw7XG4gIHJldHVybiBiYXNlVXJsICE9PSBcIi9cIiAmJiAoYmFzZVVybCA9IGJhc2VVcmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpKSwgdHlwZW9mIHN0dWRpb1VybCA9PSBcInN0cmluZ1wiID8geyBiYXNlVXJsIH0gOiB7IC4uLnN0dWRpb1VybCwgYmFzZVVybCB9O1xufVxuZXhwb3J0IHtcbiAgRFJBRlRTX1BSRUZJWCxcbiAgY3JlYXRlRWRpdFVybCxcbiAgZ2V0LFxuICBnZXRQdWJsaXNoZWRJZCxcbiAganNvblBhdGgsXG4gIGpzb25QYXRoVG9TdHVkaW9QYXRoLFxuICBwYXJzZUpzb25QYXRoLFxuICByZUtleVNlZ21lbnQsXG4gIHJlc29sdmVFZGl0SW5mbyxcbiAgcmVzb2x2ZU1hcHBpbmcsXG4gIHJlc29sdmVTdHVkaW9CYXNlUm91dGUsXG4gIHN0dWRpb1BhdGgsXG4gIHN0dWRpb1BhdGhUb0pzb25QYXRoLFxuICB0b1N0cmluZyxcbiAgd2Fsa01hcFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVFZGl0SW5mby5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ C),\n/* harmony export */   stegaClean: () => (/* binding */ stegaClean),\n/* harmony export */   vercelStegaCleanAll: () => (/* binding */ vercelStegaCleanAll)\n/* harmony export */ });\nvar s = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, c = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 }, u = new Array(4).fill(String.fromCodePoint(c[0])).join(\"\");\nfunction E(t) {\n  let e = JSON.stringify(t);\n  return `${u}${Array.from(e).map((r) => {\n    let n = r.charCodeAt(0);\n    if (n > 255)\n      throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);\n    return Array.from(n.toString(4).padStart(4, \"0\")).map((o) => String.fromCodePoint(c[o])).join(\"\");\n  }).join(\"\")}`;\n}\nfunction I(t) {\n  return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t) ? !1 : !!Date.parse(t);\n}\nfunction T(t) {\n  try {\n    new URL(t, t.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nfunction C(t, e, r = \"auto\") {\n  return r === !0 || r === \"auto\" && (I(t) || T(t)) ? t : `${t}${E(e)}`;\n}\nObject.fromEntries(Object.entries(c).map((t) => t.reverse()));\nObject.fromEntries(Object.entries(s).map((t) => t.reverse()));\nvar S = `${Object.values(s).map((t) => `\\\\u{${t.toString(16)}}`).join(\"\")}`, f = new RegExp(`[${S}]{4,}`, \"gu\");\nfunction _(t) {\n  var e;\n  return { cleaned: t.replace(f, \"\"), encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || \"\" };\n}\nfunction O(t) {\n  return t && JSON.parse(_(JSON.stringify(t)).cleaned);\n}\nfunction stegaClean(result) {\n  return O(result);\n}\nconst vercelStegaCleanAll = stegaClean;\n\n//# sourceMappingURL=stegaClean.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzLWVzL3N0ZWdhQ2xlYW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsVUFBVSxpS0FBaUssUUFBUSxxQ0FBcUM7QUFDeE47QUFDQTtBQUNBLFlBQVksRUFBRSxFQUFFO0FBQ2hCO0FBQ0E7QUFDQSx5RkFBeUYsR0FBRyxlQUFlLEdBQUcsR0FBRyxFQUFFO0FBQ25IO0FBQ0EsR0FBRyxXQUFXO0FBQ2Q7QUFDQTtBQUNBLDRFQUE0RSxFQUFFLHFCQUFxQixJQUFJO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsRUFBRSxFQUFFLEtBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUMsRUFBRSxnQkFBZ0IsWUFBWSxzQkFBc0IsRUFBRSxFQUFFLEdBQUc7QUFDdkc7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3ljX2RpcmVjdG9yeS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L19jaHVua3MtZXMvc3RlZ2FDbGVhbi5qcz8xM2Y5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBzID0geyAwOiA4MjAzLCAxOiA4MjA0LCAyOiA4MjA1LCAzOiA4MjkwLCA0OiA4MjkxLCA1OiA4Mjg4LCA2OiA2NTI3OSwgNzogODI4OSwgODogMTE5MTU1LCA5OiAxMTkxNTYsIGE6IDExOTE1NywgYjogMTE5MTU4LCBjOiAxMTkxNTksIGQ6IDExOTE2MCwgZTogMTE5MTYxLCBmOiAxMTkxNjIgfSwgYyA9IHsgMDogODIwMywgMTogODIwNCwgMjogODIwNSwgMzogNjUyNzkgfSwgdSA9IG5ldyBBcnJheSg0KS5maWxsKFN0cmluZy5mcm9tQ29kZVBvaW50KGNbMF0pKS5qb2luKFwiXCIpO1xuZnVuY3Rpb24gRSh0KSB7XG4gIGxldCBlID0gSlNPTi5zdHJpbmdpZnkodCk7XG4gIHJldHVybiBgJHt1fSR7QXJyYXkuZnJvbShlKS5tYXAoKHIpID0+IHtcbiAgICBsZXQgbiA9IHIuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAobiA+IDI1NSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSBBU0NJSSBlZGl0IGluZm8gY2FuIGJlIGVuY29kZWQuIEVycm9yIGF0dGVtcHRpbmcgdG8gZW5jb2RlICR7ZX0gb24gY2hhcmFjdGVyICR7cn0gKCR7bn0pYCk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obi50b1N0cmluZyg0KS5wYWRTdGFydCg0LCBcIjBcIikpLm1hcCgobykgPT4gU3RyaW5nLmZyb21Db2RlUG9pbnQoY1tvXSkpLmpvaW4oXCJcIik7XG4gIH0pLmpvaW4oXCJcIil9YDtcbn1cbmZ1bmN0aW9uIEkodCkge1xuICByZXR1cm4gIU51bWJlci5pc05hTihOdW1iZXIodCkpIHx8IC9bYS16XS9pLnRlc3QodCkgJiYgIS9cXGQrKD86Wy06XFwvXVxcZCspezJ9KD86VFxcZCsoPzpbLTpcXC9dXFxkKyl7MSwyfShcXC5cXGQrKT9aPyk/Ly50ZXN0KHQpID8gITEgOiAhIURhdGUucGFyc2UodCk7XG59XG5mdW5jdGlvbiBUKHQpIHtcbiAgdHJ5IHtcbiAgICBuZXcgVVJMKHQsIHQuc3RhcnRzV2l0aChcIi9cIikgPyBcImh0dHBzOi8vYWNtZS5jb21cIiA6IHZvaWQgMCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBDKHQsIGUsIHIgPSBcImF1dG9cIikge1xuICByZXR1cm4gciA9PT0gITAgfHwgciA9PT0gXCJhdXRvXCIgJiYgKEkodCkgfHwgVCh0KSkgPyB0IDogYCR7dH0ke0UoZSl9YDtcbn1cbk9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhjKS5tYXAoKHQpID0+IHQucmV2ZXJzZSgpKSk7XG5PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocykubWFwKCh0KSA9PiB0LnJldmVyc2UoKSkpO1xudmFyIFMgPSBgJHtPYmplY3QudmFsdWVzKHMpLm1hcCgodCkgPT4gYFxcXFx1eyR7dC50b1N0cmluZygxNil9fWApLmpvaW4oXCJcIil9YCwgZiA9IG5ldyBSZWdFeHAoYFske1N9XXs0LH1gLCBcImd1XCIpO1xuZnVuY3Rpb24gXyh0KSB7XG4gIHZhciBlO1xuICByZXR1cm4geyBjbGVhbmVkOiB0LnJlcGxhY2UoZiwgXCJcIiksIGVuY29kZWQ6ICgoZSA9IHQubWF0Y2goZikpID09IG51bGwgPyB2b2lkIDAgOiBlWzBdKSB8fCBcIlwiIH07XG59XG5mdW5jdGlvbiBPKHQpIHtcbiAgcmV0dXJuIHQgJiYgSlNPTi5wYXJzZShfKEpTT04uc3RyaW5naWZ5KHQpKS5jbGVhbmVkKTtcbn1cbmZ1bmN0aW9uIHN0ZWdhQ2xlYW4ocmVzdWx0KSB7XG4gIHJldHVybiBPKHJlc3VsdCk7XG59XG5jb25zdCB2ZXJjZWxTdGVnYUNsZWFuQWxsID0gc3RlZ2FDbGVhbjtcbmV4cG9ydCB7XG4gIEMsXG4gIHN0ZWdhQ2xlYW4sXG4gIHZlcmNlbFN0ZWdhQ2xlYW5BbGxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGVnYUNsZWFuLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeIntoResult: () => (/* binding */ encodeIntoResult),\n/* harmony export */   stegaEncodeSourceMap: () => (/* binding */ stegaEncodeSourceMap),\n/* harmony export */   stegaEncodeSourceMap$1: () => (/* binding */ stegaEncodeSourceMap$1)\n/* harmony export */ });\n/* harmony import */ var _stegaClean_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stegaClean.js */ \"(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\");\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\")\n      return `${target}[${segment}]`;\n    if (segmentType === \"string\")\n      return `${target}${i === 0 ? \"\" : \".\"}${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nconst ESCAPE = {\n  \"\\f\": \"\\\\f\",\n  \"\\n\": \"\\\\n\",\n  \"\\r\": \"\\\\r\",\n  \"\t\": \"\\\\t\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n}, UNESCAPE = {\n  \"\\\\f\": \"\\f\",\n  \"\\\\n\": `\n`,\n  \"\\\\r\": \"\\r\",\n  \"\\\\t\": \"\t\",\n  \"\\\\'\": \"'\",\n  \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n  return `$${path.map((segment) => typeof segment == \"string\" ? `['${segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => ESCAPE[match])}']` : typeof segment == \"number\" ? `[${segment}]` : segment._key !== \"\" ? `[?(@._key=='${segment._key.replace(/['\\\\]/g, (match) => ESCAPE[match])}')]` : `[${segment._index}]`).join(\"\")}`;\n}\nfunction parseJsonPath(path) {\n  const parsed = [], parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  for (; (match = parseRe.exec(path)) !== null; ) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => UNESCAPE[m]);\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => UNESCAPE[m]);\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._key !== \"\")\n      return { _key: segment._key };\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction resolveMapping(resultPath, csm) {\n  if (!csm?.mappings)\n    return;\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0)\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: \"\"\n    };\n  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);\n  if (mappings.length == 0)\n    return;\n  const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return { mapping, matchedPath, pathSuffix };\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction isRecord(value) {\n  return typeof value == \"object\" && value !== null;\n}\nfunction walkMap(value, mappingFn, path = []) {\n  if (isArray(value))\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v._key;\n        if (typeof _key == \"string\")\n          return walkMap(v, mappingFn, path.concat({ _key, _index: idx }));\n      }\n      return walkMap(v, mappingFn, path.concat(idx));\n    });\n  if (isRecord(value)) {\n    if (value._type === \"block\" || value._type === \"span\") {\n      const result = { ...value };\n      return value._type === \"block\" ? result.children = walkMap(value.children, mappingFn, path.concat(\"children\")) : value._type === \"span\" && (result.text = walkMap(value.text, mappingFn, path.concat(\"text\"))), result;\n    }\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))])\n    );\n  }\n  return mappingFn(value, path);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n  return walkMap(result, (value, path) => {\n    if (typeof value != \"string\")\n      return value;\n    const resolveMappingResult = resolveMapping(path, csm);\n    if (!resolveMappingResult)\n      return value;\n    const { mapping, matchedPath } = resolveMappingResult;\n    if (mapping.type !== \"value\" || mapping.source.type !== \"documentValue\")\n      return value;\n    const sourceDocument = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path], matchPathSegments = parseJsonPath(matchedPath), fullSourceSegments = parseJsonPath(sourcePath).concat(path.slice(matchPathSegments.length));\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value\n    });\n  });\n}\nconst DRAFTS_PREFIX = \"drafts.\";\nfunction getPublishedId(id) {\n  return id.startsWith(DRAFTS_PREFIX) ? id.slice(DRAFTS_PREFIX.length) : id;\n}\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path,\n    projectId,\n    dataset\n  } = options;\n  if (!baseUrl)\n    throw new Error(\"baseUrl is required\");\n  if (!path)\n    throw new Error(\"path is required\");\n  if (!_id)\n    throw new Error(\"id is required\");\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\"))\n    throw new Error(\"baseUrl must not end with a slash\");\n  const workspace = _workspace === \"default\" ? void 0 : _workspace, tool = _tool === \"default\" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath\n  });\n  workspace && searchParams.set(\"workspace\", workspace), tool && searchParams.set(\"tool\", tool), projectId && searchParams.set(\"projectId\", projectId), dataset && searchParams.set(\"dataset\", dataset), _id.startsWith(DRAFTS_PREFIX) && searchParams.set(\"isDraft\", \"\");\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  workspace && segments.push(workspace);\n  const routerParams = [\n    \"mode=presentation\",\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`\n  ];\n  return tool && routerParams.push(`tool=${tool}`), segments.push(\"intent\", \"edit\", `${routerParams.join(\";\")}?${searchParams}`), segments.join(\"/\");\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl == \"string\" ? studioUrl : studioUrl.baseUrl;\n  return baseUrl !== \"/\" && (baseUrl = baseUrl.replace(/\\/$/, \"\")), typeof studioUrl == \"string\" ? { baseUrl } : { ...studioUrl, baseUrl };\n}\nconst filterDefault = ({ sourcePath, resultPath, value }) => {\n  if (isValidDate(value) || isValidURL(value))\n    return !1;\n  const endPath = sourcePath.at(-1);\n  return !(sourcePath.at(-2) === \"slug\" && endPath === \"current\" || typeof endPath == \"string\" && (endPath.startsWith(\"_\") || endPath.endsWith(\"Id\")) || sourcePath.some(\n    (path) => path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\"\n  ) || hasTypeLike(sourcePath) || hasTypeLike(resultPath) || typeof endPath == \"string\" && denylist.has(endPath));\n}, denylist = /* @__PURE__ */ new Set([\n  \"color\",\n  \"colour\",\n  \"currency\",\n  \"email\",\n  \"format\",\n  \"gid\",\n  \"hex\",\n  \"href\",\n  \"hsl\",\n  \"hsla\",\n  \"icon\",\n  \"id\",\n  \"index\",\n  \"key\",\n  \"language\",\n  \"layout\",\n  \"link\",\n  \"linkAction\",\n  \"locale\",\n  \"lqip\",\n  \"page\",\n  \"path\",\n  \"ref\",\n  \"rgb\",\n  \"rgba\",\n  \"route\",\n  \"secret\",\n  \"slug\",\n  \"status\",\n  \"tag\",\n  \"template\",\n  \"theme\",\n  \"type\",\n  \"textTheme\",\n  \"unit\",\n  \"url\",\n  \"username\",\n  \"variant\",\n  \"website\"\n]);\nfunction isValidDate(dateString) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? !!Date.parse(dateString) : !1;\n}\nfunction isValidURL(url) {\n  try {\n    new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nfunction hasTypeLike(path) {\n  return path.some((segment) => typeof segment == \"string\" && segment.match(/type/i) !== null);\n}\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n  const { filter, logger, enabled } = config;\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  if (!resultSourceMap)\n    return logger?.error?.(\"[@sanity/client]: Missing Content Source Map from response body\", {\n      result,\n      resultSourceMap,\n      config\n    }), result;\n  if (!config.studioUrl) {\n    const msg = \"config.studioUrl must be defined\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  const report = {\n    encoded: [],\n    skipped: []\n  }, resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({ sourcePath, sourceDocument, resultPath, value }) => {\n      if ((typeof filter == \"function\" ? filter({ sourcePath, resultPath, filterDefault, sourceDocument, value }) : filterDefault({ sourcePath, resultPath, filterDefault, sourceDocument, value })) === !1)\n        return logger && report.skipped.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n          length: value.length\n        }), value;\n      logger && report.encoded.push({\n        path: prettyPathForLogging(sourcePath),\n        value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n        length: value.length\n      });\n      const { baseUrl, workspace, tool } = resolveStudioBaseRoute(\n        typeof config.studioUrl == \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl\n      );\n      if (!baseUrl)\n        return value;\n      const { _id: id, _type: type, _projectId: projectId, _dataset: dataset } = sourceDocument;\n      return (0,_stegaClean_js__WEBPACK_IMPORTED_MODULE_0__.C)(\n        value,\n        {\n          origin: \"sanity.io\",\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n            ...!config.omitCrossDatasetReferenceData && { dataset, projectId }\n          })\n        },\n        // We use custom logic to determine if we should skip encoding\n        !1\n      );\n    }\n  );\n  if (logger) {\n    const isSkipping = report.skipped.length, isEncoding = report.encoded.length;\n    if ((isSkipping || isEncoding) && ((logger?.groupCollapsed || logger.log)?.(\"[@sanity/client]: Encoding source map into result\"), logger.log?.(\n      `[@sanity/client]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`\n    )), report.encoded.length > 0 && (logger?.log?.(\"[@sanity/client]: Table of encoded paths\"), (logger?.table || logger.log)?.(report.encoded)), report.skipped.length > 0) {\n      const skipped = /* @__PURE__ */ new Set();\n      for (const { path } of report.skipped)\n        skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n      logger?.log?.(\"[@sanity/client]: List of skipped paths\", [...skipped.values()]);\n    }\n    (isSkipping || isEncoding) && logger?.groupEnd?.();\n  }\n  return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n  return toString(jsonPathToStudioPath(path));\n}\nvar stegaEncodeSourceMap$1 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  stegaEncodeSourceMap\n});\n\n//# sourceMappingURL=stegaEncodeSourceMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzLWVzL3N0ZWdhRW5jb2RlU291cmNlTWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTyxHQUFHLFFBQVE7QUFDbEM7QUFDQSxnQkFBZ0IsT0FBTyxFQUFFLG1CQUFtQixFQUFFLFFBQVE7QUFDdEQ7QUFDQSxnQkFBZ0IsT0FBTyxVQUFVLGFBQWE7QUFDOUM7QUFDQTtBQUNBLGdCQUFnQixPQUFPLEdBQUcsS0FBSyxHQUFHLEdBQUc7QUFDckM7QUFDQSxrREFBa0Qsd0JBQXdCO0FBQzFFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0RBQXdELDREQUE0RCx1Q0FBdUMsUUFBUSwwQ0FBMEMseURBQXlELFdBQVcsZUFBZSxhQUFhO0FBQzFUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1Q0FBdUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsbUJBQW1CO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRztBQUNiLFlBQVksS0FBSztBQUNqQixZQUFZLG9DQUFvQztBQUNoRDtBQUNBLDJDQUEyQyxLQUFLLHVDQUF1QyxvQkFBb0IsR0FBRyxHQUFHLGFBQWE7QUFDOUg7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLFVBQVUsSUFBSTtBQUNuSDtBQUNBLHlCQUF5QiwrQkFBK0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQztBQUNBO0FBQ0EsK0NBQStDLElBQUksS0FBSyxpQ0FBaUM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSSxLQUFLLGlDQUFpQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsT0FBTywrQ0FBK0M7QUFDdEQsa0RBQWtELDhEQUE4RCxvQkFBb0IsOERBQThEO0FBQ2xNO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDLEVBQUUsNENBQTRDO0FBQ2xHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDLEVBQUUsNENBQTRDO0FBQ2hHO0FBQ0EsT0FBTztBQUNQLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUU7QUFDL0UsYUFBYSxpREFBQztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsYUFBYSxzQkFBc0I7QUFDbkc7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUtDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95Y19kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzLWVzL3N0ZWdhRW5jb2RlU291cmNlTWFwLmpzPzg0ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQyB9IGZyb20gXCIuL3N0ZWdhQ2xlYW4uanNcIjtcbmNvbnN0IHJlS2V5U2VnbWVudCA9IC9fa2V5XFxzKj09XFxzKlsnXCJdKC4qKVsnXCJdLztcbmZ1bmN0aW9uIGlzS2V5U2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiB0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiID8gcmVLZXlTZWdtZW50LnRlc3Qoc2VnbWVudC50cmltKCkpIDogdHlwZW9mIHNlZ21lbnQgPT0gXCJvYmplY3RcIiAmJiBcIl9rZXlcIiBpbiBzZWdtZW50O1xufVxuZnVuY3Rpb24gdG9TdHJpbmcocGF0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0aCBpcyBub3QgYW4gYXJyYXlcIik7XG4gIHJldHVybiBwYXRoLnJlZHVjZSgodGFyZ2V0LCBzZWdtZW50LCBpKSA9PiB7XG4gICAgY29uc3Qgc2VnbWVudFR5cGUgPSB0eXBlb2Ygc2VnbWVudDtcbiAgICBpZiAoc2VnbWVudFR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVske3NlZ21lbnR9XWA7XG4gICAgaWYgKHNlZ21lbnRUeXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIGAke3RhcmdldH0ke2kgPT09IDAgPyBcIlwiIDogXCIuXCJ9JHtzZWdtZW50fWA7XG4gICAgaWYgKGlzS2V5U2VnbWVudChzZWdtZW50KSAmJiBzZWdtZW50Ll9rZXkpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVtfa2V5PT1cIiR7c2VnbWVudC5fa2V5fVwiXWA7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2VnbWVudCkpIHtcbiAgICAgIGNvbnN0IFtmcm9tLCB0b10gPSBzZWdtZW50O1xuICAgICAgcmV0dXJuIGAke3RhcmdldH1bJHtmcm9tfToke3RvfV1gO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhdGggc2VnbWVudCBcXGAke0pTT04uc3RyaW5naWZ5KHNlZ21lbnQpfVxcYGApO1xuICB9LCBcIlwiKTtcbn1cbmNvbnN0IEVTQ0FQRSA9IHtcbiAgXCJcXGZcIjogXCJcXFxcZlwiLFxuICBcIlxcblwiOiBcIlxcXFxuXCIsXG4gIFwiXFxyXCI6IFwiXFxcXHJcIixcbiAgXCJcdFwiOiBcIlxcXFx0XCIsXG4gIFwiJ1wiOiBcIlxcXFwnXCIsXG4gIFwiXFxcXFwiOiBcIlxcXFxcXFxcXCJcbn0sIFVORVNDQVBFID0ge1xuICBcIlxcXFxmXCI6IFwiXFxmXCIsXG4gIFwiXFxcXG5cIjogYFxuYCxcbiAgXCJcXFxcclwiOiBcIlxcclwiLFxuICBcIlxcXFx0XCI6IFwiXHRcIixcbiAgXCJcXFxcJ1wiOiBcIidcIixcbiAgXCJcXFxcXFxcXFwiOiBcIlxcXFxcIlxufTtcbmZ1bmN0aW9uIGpzb25QYXRoKHBhdGgpIHtcbiAgcmV0dXJuIGAkJHtwYXRoLm1hcCgoc2VnbWVudCkgPT4gdHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiA/IGBbJyR7c2VnbWVudC5yZXBsYWNlKC9bXFxmXFxuXFxyXFx0J1xcXFxdL2csIChtYXRjaCkgPT4gRVNDQVBFW21hdGNoXSl9J11gIDogdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIiA/IGBbJHtzZWdtZW50fV1gIDogc2VnbWVudC5fa2V5ICE9PSBcIlwiID8gYFs/KEAuX2tleT09JyR7c2VnbWVudC5fa2V5LnJlcGxhY2UoL1snXFxcXF0vZywgKG1hdGNoKSA9PiBFU0NBUEVbbWF0Y2hdKX0nKV1gIDogYFske3NlZ21lbnQuX2luZGV4fV1gKS5qb2luKFwiXCIpfWA7XG59XG5mdW5jdGlvbiBwYXJzZUpzb25QYXRoKHBhdGgpIHtcbiAgY29uc3QgcGFyc2VkID0gW10sIHBhcnNlUmUgPSAvXFxbJyguKj8pJ1xcXXxcXFsoXFxkKylcXF18XFxbXFw/XFwoQFxcLl9rZXk9PScoLio/KSdcXClcXF0vZztcbiAgbGV0IG1hdGNoO1xuICBmb3IgKDsgKG1hdGNoID0gcGFyc2VSZS5leGVjKHBhdGgpKSAhPT0gbnVsbDsgKSB7XG4gICAgaWYgKG1hdGNoWzFdICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGtleSA9IG1hdGNoWzFdLnJlcGxhY2UoL1xcXFwoXFxcXHxmfG58cnx0fCcpL2csIChtKSA9PiBVTkVTQ0FQRVttXSk7XG4gICAgICBwYXJzZWQucHVzaChrZXkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtYXRjaFsyXSAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXJzZWQucHVzaChwYXJzZUludChtYXRjaFsyXSwgMTApKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbM10gIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgX2tleSA9IG1hdGNoWzNdLnJlcGxhY2UoL1xcXFwoXFxcXCcpL2csIChtKSA9PiBVTkVTQ0FQRVttXSk7XG4gICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgIF9rZXksXG4gICAgICAgIF9pbmRleDogLTFcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5mdW5jdGlvbiBqc29uUGF0aFRvU3R1ZGlvUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBzZWdtZW50ID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gc2VnbWVudDtcbiAgICBpZiAoc2VnbWVudC5fa2V5ICE9PSBcIlwiKVxuICAgICAgcmV0dXJuIHsgX2tleTogc2VnbWVudC5fa2V5IH07XG4gICAgaWYgKHNlZ21lbnQuX2luZGV4ICE9PSAtMSlcbiAgICAgIHJldHVybiBzZWdtZW50Ll9pbmRleDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2VnbWVudDoke0pTT04uc3RyaW5naWZ5KHNlZ21lbnQpfWApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGpzb25QYXRoVG9NYXBwaW5nUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBzZWdtZW50ID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gc2VnbWVudDtcbiAgICBpZiAoc2VnbWVudC5faW5kZXggIT09IC0xKVxuICAgICAgcmV0dXJuIHNlZ21lbnQuX2luZGV4O1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzZWdtZW50OiR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9YCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU1hcHBpbmcocmVzdWx0UGF0aCwgY3NtKSB7XG4gIGlmICghY3NtPy5tYXBwaW5ncylcbiAgICByZXR1cm47XG4gIGNvbnN0IHJlc3VsdE1hcHBpbmdQYXRoID0ganNvblBhdGgoanNvblBhdGhUb01hcHBpbmdQYXRoKHJlc3VsdFBhdGgpKTtcbiAgaWYgKGNzbS5tYXBwaW5nc1tyZXN1bHRNYXBwaW5nUGF0aF0gIT09IHZvaWQgMClcbiAgICByZXR1cm4ge1xuICAgICAgbWFwcGluZzogY3NtLm1hcHBpbmdzW3Jlc3VsdE1hcHBpbmdQYXRoXSxcbiAgICAgIG1hdGNoZWRQYXRoOiByZXN1bHRNYXBwaW5nUGF0aCxcbiAgICAgIHBhdGhTdWZmaXg6IFwiXCJcbiAgICB9O1xuICBjb25zdCBtYXBwaW5ncyA9IE9iamVjdC5lbnRyaWVzKGNzbS5tYXBwaW5ncykuZmlsdGVyKChba2V5XSkgPT4gcmVzdWx0TWFwcGluZ1BhdGguc3RhcnRzV2l0aChrZXkpKS5zb3J0KChba2V5MV0sIFtrZXkyXSkgPT4ga2V5Mi5sZW5ndGggLSBrZXkxLmxlbmd0aCk7XG4gIGlmIChtYXBwaW5ncy5sZW5ndGggPT0gMClcbiAgICByZXR1cm47XG4gIGNvbnN0IFttYXRjaGVkUGF0aCwgbWFwcGluZ10gPSBtYXBwaW5nc1swXSwgcGF0aFN1ZmZpeCA9IHJlc3VsdE1hcHBpbmdQYXRoLnN1YnN0cmluZyhtYXRjaGVkUGF0aC5sZW5ndGgpO1xuICByZXR1cm4geyBtYXBwaW5nLCBtYXRjaGVkUGF0aCwgcGF0aFN1ZmZpeCB9O1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc1JlY29yZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiB3YWxrTWFwKHZhbHVlLCBtYXBwaW5nRm4sIHBhdGggPSBbXSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpXG4gICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaWR4KSA9PiB7XG4gICAgICBpZiAoaXNSZWNvcmQodikpIHtcbiAgICAgICAgY29uc3QgX2tleSA9IHYuX2tleTtcbiAgICAgICAgaWYgKHR5cGVvZiBfa2V5ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuIHdhbGtNYXAodiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdCh7IF9rZXksIF9pbmRleDogaWR4IH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YWxrTWFwKHYsIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoaWR4KSk7XG4gICAgfSk7XG4gIGlmIChpc1JlY29yZCh2YWx1ZSkpIHtcbiAgICBpZiAodmFsdWUuX3R5cGUgPT09IFwiYmxvY2tcIiB8fCB2YWx1ZS5fdHlwZSA9PT0gXCJzcGFuXCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHsgLi4udmFsdWUgfTtcbiAgICAgIHJldHVybiB2YWx1ZS5fdHlwZSA9PT0gXCJibG9ja1wiID8gcmVzdWx0LmNoaWxkcmVuID0gd2Fsa01hcCh2YWx1ZS5jaGlsZHJlbiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChcImNoaWxkcmVuXCIpKSA6IHZhbHVlLl90eXBlID09PSBcInNwYW5cIiAmJiAocmVzdWx0LnRleHQgPSB3YWxrTWFwKHZhbHVlLnRleHQsIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoXCJ0ZXh0XCIpKSksIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5tYXAoKFtrLCB2XSkgPT4gW2ssIHdhbGtNYXAodiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChrKSldKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG1hcHBpbmdGbih2YWx1ZSwgcGF0aCk7XG59XG5mdW5jdGlvbiBlbmNvZGVJbnRvUmVzdWx0KHJlc3VsdCwgY3NtLCBlbmNvZGVyKSB7XG4gIHJldHVybiB3YWxrTWFwKHJlc3VsdCwgKHZhbHVlLCBwYXRoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHJlc29sdmVNYXBwaW5nUmVzdWx0ID0gcmVzb2x2ZU1hcHBpbmcocGF0aCwgY3NtKTtcbiAgICBpZiAoIXJlc29sdmVNYXBwaW5nUmVzdWx0KVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHsgbWFwcGluZywgbWF0Y2hlZFBhdGggfSA9IHJlc29sdmVNYXBwaW5nUmVzdWx0O1xuICAgIGlmIChtYXBwaW5nLnR5cGUgIT09IFwidmFsdWVcIiB8fCBtYXBwaW5nLnNvdXJjZS50eXBlICE9PSBcImRvY3VtZW50VmFsdWVcIilcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCBzb3VyY2VEb2N1bWVudCA9IGNzbS5kb2N1bWVudHNbbWFwcGluZy5zb3VyY2UuZG9jdW1lbnRdLCBzb3VyY2VQYXRoID0gY3NtLnBhdGhzW21hcHBpbmcuc291cmNlLnBhdGhdLCBtYXRjaFBhdGhTZWdtZW50cyA9IHBhcnNlSnNvblBhdGgobWF0Y2hlZFBhdGgpLCBmdWxsU291cmNlU2VnbWVudHMgPSBwYXJzZUpzb25QYXRoKHNvdXJjZVBhdGgpLmNvbmNhdChwYXRoLnNsaWNlKG1hdGNoUGF0aFNlZ21lbnRzLmxlbmd0aCkpO1xuICAgIHJldHVybiBlbmNvZGVyKHtcbiAgICAgIHNvdXJjZVBhdGg6IGZ1bGxTb3VyY2VTZWdtZW50cyxcbiAgICAgIHNvdXJjZURvY3VtZW50LFxuICAgICAgcmVzdWx0UGF0aDogcGF0aCxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH0pO1xufVxuY29uc3QgRFJBRlRTX1BSRUZJWCA9IFwiZHJhZnRzLlwiO1xuZnVuY3Rpb24gZ2V0UHVibGlzaGVkSWQoaWQpIHtcbiAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoRFJBRlRTX1BSRUZJWCkgPyBpZC5zbGljZShEUkFGVFNfUFJFRklYLmxlbmd0aCkgOiBpZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVkaXRVcmwob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYmFzZVVybCxcbiAgICB3b3Jrc3BhY2U6IF93b3Jrc3BhY2UgPSBcImRlZmF1bHRcIixcbiAgICB0b29sOiBfdG9vbCA9IFwiZGVmYXVsdFwiLFxuICAgIGlkOiBfaWQsXG4gICAgdHlwZSxcbiAgICBwYXRoLFxuICAgIHByb2plY3RJZCxcbiAgICBkYXRhc2V0XG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIWJhc2VVcmwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZVVybCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKCFwYXRoKVxuICAgIHRocm93IG5ldyBFcnJvcihcInBhdGggaXMgcmVxdWlyZWRcIik7XG4gIGlmICghX2lkKVxuICAgIHRocm93IG5ldyBFcnJvcihcImlkIGlzIHJlcXVpcmVkXCIpO1xuICBpZiAoYmFzZVVybCAhPT0gXCIvXCIgJiYgYmFzZVVybC5lbmRzV2l0aChcIi9cIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZVVybCBtdXN0IG5vdCBlbmQgd2l0aCBhIHNsYXNoXCIpO1xuICBjb25zdCB3b3Jrc3BhY2UgPSBfd29ya3NwYWNlID09PSBcImRlZmF1bHRcIiA/IHZvaWQgMCA6IF93b3Jrc3BhY2UsIHRvb2wgPSBfdG9vbCA9PT0gXCJkZWZhdWx0XCIgPyB2b2lkIDAgOiBfdG9vbCwgaWQgPSBnZXRQdWJsaXNoZWRJZChfaWQpLCBzdHJpbmdpZmllZFBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gdG9TdHJpbmcoanNvblBhdGhUb1N0dWRpb1BhdGgocGF0aCkpIDogcGF0aCwgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgYmFzZVVybCxcbiAgICBpZCxcbiAgICB0eXBlLFxuICAgIHBhdGg6IHN0cmluZ2lmaWVkUGF0aFxuICB9KTtcbiAgd29ya3NwYWNlICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJ3b3Jrc3BhY2VcIiwgd29ya3NwYWNlKSwgdG9vbCAmJiBzZWFyY2hQYXJhbXMuc2V0KFwidG9vbFwiLCB0b29sKSwgcHJvamVjdElkICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJwcm9qZWN0SWRcIiwgcHJvamVjdElkKSwgZGF0YXNldCAmJiBzZWFyY2hQYXJhbXMuc2V0KFwiZGF0YXNldFwiLCBkYXRhc2V0KSwgX2lkLnN0YXJ0c1dpdGgoRFJBRlRTX1BSRUZJWCkgJiYgc2VhcmNoUGFyYW1zLnNldChcImlzRHJhZnRcIiwgXCJcIik7XG4gIGNvbnN0IHNlZ21lbnRzID0gW2Jhc2VVcmwgPT09IFwiL1wiID8gXCJcIiA6IGJhc2VVcmxdO1xuICB3b3Jrc3BhY2UgJiYgc2VnbWVudHMucHVzaCh3b3Jrc3BhY2UpO1xuICBjb25zdCByb3V0ZXJQYXJhbXMgPSBbXG4gICAgXCJtb2RlPXByZXNlbnRhdGlvblwiLFxuICAgIGBpZD0ke2lkfWAsXG4gICAgYHR5cGU9JHt0eXBlfWAsXG4gICAgYHBhdGg9JHtlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZpZWRQYXRoKX1gXG4gIF07XG4gIHJldHVybiB0b29sICYmIHJvdXRlclBhcmFtcy5wdXNoKGB0b29sPSR7dG9vbH1gKSwgc2VnbWVudHMucHVzaChcImludGVudFwiLCBcImVkaXRcIiwgYCR7cm91dGVyUGFyYW1zLmpvaW4oXCI7XCIpfT8ke3NlYXJjaFBhcmFtc31gKSwgc2VnbWVudHMuam9pbihcIi9cIik7XG59XG5mdW5jdGlvbiByZXNvbHZlU3R1ZGlvQmFzZVJvdXRlKHN0dWRpb1VybCkge1xuICBsZXQgYmFzZVVybCA9IHR5cGVvZiBzdHVkaW9VcmwgPT0gXCJzdHJpbmdcIiA/IHN0dWRpb1VybCA6IHN0dWRpb1VybC5iYXNlVXJsO1xuICByZXR1cm4gYmFzZVVybCAhPT0gXCIvXCIgJiYgKGJhc2VVcmwgPSBiYXNlVXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSksIHR5cGVvZiBzdHVkaW9VcmwgPT0gXCJzdHJpbmdcIiA/IHsgYmFzZVVybCB9IDogeyAuLi5zdHVkaW9VcmwsIGJhc2VVcmwgfTtcbn1cbmNvbnN0IGZpbHRlckRlZmF1bHQgPSAoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCB2YWx1ZSB9KSA9PiB7XG4gIGlmIChpc1ZhbGlkRGF0ZSh2YWx1ZSkgfHwgaXNWYWxpZFVSTCh2YWx1ZSkpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBlbmRQYXRoID0gc291cmNlUGF0aC5hdCgtMSk7XG4gIHJldHVybiAhKHNvdXJjZVBhdGguYXQoLTIpID09PSBcInNsdWdcIiAmJiBlbmRQYXRoID09PSBcImN1cnJlbnRcIiB8fCB0eXBlb2YgZW5kUGF0aCA9PSBcInN0cmluZ1wiICYmIChlbmRQYXRoLnN0YXJ0c1dpdGgoXCJfXCIpIHx8IGVuZFBhdGguZW5kc1dpdGgoXCJJZFwiKSkgfHwgc291cmNlUGF0aC5zb21lKFxuICAgIChwYXRoKSA9PiBwYXRoID09PSBcIm1ldGFcIiB8fCBwYXRoID09PSBcIm1ldGFkYXRhXCIgfHwgcGF0aCA9PT0gXCJvcGVuR3JhcGhcIiB8fCBwYXRoID09PSBcInNlb1wiXG4gICkgfHwgaGFzVHlwZUxpa2Uoc291cmNlUGF0aCkgfHwgaGFzVHlwZUxpa2UocmVzdWx0UGF0aCkgfHwgdHlwZW9mIGVuZFBhdGggPT0gXCJzdHJpbmdcIiAmJiBkZW55bGlzdC5oYXMoZW5kUGF0aCkpO1xufSwgZGVueWxpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiY29sb3JcIixcbiAgXCJjb2xvdXJcIixcbiAgXCJjdXJyZW5jeVwiLFxuICBcImVtYWlsXCIsXG4gIFwiZm9ybWF0XCIsXG4gIFwiZ2lkXCIsXG4gIFwiaGV4XCIsXG4gIFwiaHJlZlwiLFxuICBcImhzbFwiLFxuICBcImhzbGFcIixcbiAgXCJpY29uXCIsXG4gIFwiaWRcIixcbiAgXCJpbmRleFwiLFxuICBcImtleVwiLFxuICBcImxhbmd1YWdlXCIsXG4gIFwibGF5b3V0XCIsXG4gIFwibGlua1wiLFxuICBcImxpbmtBY3Rpb25cIixcbiAgXCJsb2NhbGVcIixcbiAgXCJscWlwXCIsXG4gIFwicGFnZVwiLFxuICBcInBhdGhcIixcbiAgXCJyZWZcIixcbiAgXCJyZ2JcIixcbiAgXCJyZ2JhXCIsXG4gIFwicm91dGVcIixcbiAgXCJzZWNyZXRcIixcbiAgXCJzbHVnXCIsXG4gIFwic3RhdHVzXCIsXG4gIFwidGFnXCIsXG4gIFwidGVtcGxhdGVcIixcbiAgXCJ0aGVtZVwiLFxuICBcInR5cGVcIixcbiAgXCJ0ZXh0VGhlbWVcIixcbiAgXCJ1bml0XCIsXG4gIFwidXJsXCIsXG4gIFwidXNlcm5hbWVcIixcbiAgXCJ2YXJpYW50XCIsXG4gIFwid2Vic2l0ZVwiXG5dKTtcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKGRhdGVTdHJpbmcpIHtcbiAgcmV0dXJuIC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0vLnRlc3QoZGF0ZVN0cmluZykgPyAhIURhdGUucGFyc2UoZGF0ZVN0cmluZykgOiAhMTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRVUkwodXJsKSB7XG4gIHRyeSB7XG4gICAgbmV3IFVSTCh1cmwsIHVybC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiaHR0cHM6Ly9hY21lLmNvbVwiIDogdm9pZCAwKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGhhc1R5cGVMaWtlKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc29tZSgoc2VnbWVudCkgPT4gdHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiAmJiBzZWdtZW50Lm1hdGNoKC90eXBlL2kpICE9PSBudWxsKTtcbn1cbmNvbnN0IFRSVU5DQVRFX0xFTkdUSCA9IDIwO1xuZnVuY3Rpb24gc3RlZ2FFbmNvZGVTb3VyY2VNYXAocmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZykge1xuICBjb25zdCB7IGZpbHRlciwgbG9nZ2VyLCBlbmFibGVkIH0gPSBjb25maWc7XG4gIGlmICghZW5hYmxlZCkge1xuICAgIGNvbnN0IG1zZyA9IFwiY29uZmlnLmVuYWJsZWQgbXVzdCBiZSB0cnVlLCBkb24ndCBjYWxsIHRoaXMgZnVuY3Rpb24gb3RoZXJ3aXNlXCI7XG4gICAgdGhyb3cgbG9nZ2VyPy5lcnJvcj8uKGBbQHNhbml0eS9jbGllbnRdOiAke21zZ31gLCB7IHJlc3VsdCwgcmVzdWx0U291cmNlTWFwLCBjb25maWcgfSksIG5ldyBUeXBlRXJyb3IobXNnKTtcbiAgfVxuICBpZiAoIXJlc3VsdFNvdXJjZU1hcClcbiAgICByZXR1cm4gbG9nZ2VyPy5lcnJvcj8uKFwiW0BzYW5pdHkvY2xpZW50XTogTWlzc2luZyBDb250ZW50IFNvdXJjZSBNYXAgZnJvbSByZXNwb25zZSBib2R5XCIsIHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHJlc3VsdFNvdXJjZU1hcCxcbiAgICAgIGNvbmZpZ1xuICAgIH0pLCByZXN1bHQ7XG4gIGlmICghY29uZmlnLnN0dWRpb1VybCkge1xuICAgIGNvbnN0IG1zZyA9IFwiY29uZmlnLnN0dWRpb1VybCBtdXN0IGJlIGRlZmluZWRcIjtcbiAgICB0aHJvdyBsb2dnZXI/LmVycm9yPy4oYFtAc2FuaXR5L2NsaWVudF06ICR7bXNnfWAsIHsgcmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZyB9KSwgbmV3IFR5cGVFcnJvcihtc2cpO1xuICB9XG4gIGNvbnN0IHJlcG9ydCA9IHtcbiAgICBlbmNvZGVkOiBbXSxcbiAgICBza2lwcGVkOiBbXVxuICB9LCByZXN1bHRXaXRoU3RlZ2EgPSBlbmNvZGVJbnRvUmVzdWx0KFxuICAgIHJlc3VsdCxcbiAgICByZXN1bHRTb3VyY2VNYXAsXG4gICAgKHsgc291cmNlUGF0aCwgc291cmNlRG9jdW1lbnQsIHJlc3VsdFBhdGgsIHZhbHVlIH0pID0+IHtcbiAgICAgIGlmICgodHlwZW9mIGZpbHRlciA9PSBcImZ1bmN0aW9uXCIgPyBmaWx0ZXIoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCBmaWx0ZXJEZWZhdWx0LCBzb3VyY2VEb2N1bWVudCwgdmFsdWUgfSkgOiBmaWx0ZXJEZWZhdWx0KHsgc291cmNlUGF0aCwgcmVzdWx0UGF0aCwgZmlsdGVyRGVmYXVsdCwgc291cmNlRG9jdW1lbnQsIHZhbHVlIH0pKSA9PT0gITEpXG4gICAgICAgIHJldHVybiBsb2dnZXIgJiYgcmVwb3J0LnNraXBwZWQucHVzaCh7XG4gICAgICAgICAgcGF0aDogcHJldHR5UGF0aEZvckxvZ2dpbmcoc291cmNlUGF0aCksXG4gICAgICAgICAgdmFsdWU6IGAke3ZhbHVlLnNsaWNlKDAsIFRSVU5DQVRFX0xFTkdUSCl9JHt2YWx1ZS5sZW5ndGggPiBUUlVOQ0FURV9MRU5HVEggPyBcIi4uLlwiIDogXCJcIn1gLFxuICAgICAgICAgIGxlbmd0aDogdmFsdWUubGVuZ3RoXG4gICAgICAgIH0pLCB2YWx1ZTtcbiAgICAgIGxvZ2dlciAmJiByZXBvcnQuZW5jb2RlZC5wdXNoKHtcbiAgICAgICAgcGF0aDogcHJldHR5UGF0aEZvckxvZ2dpbmcoc291cmNlUGF0aCksXG4gICAgICAgIHZhbHVlOiBgJHt2YWx1ZS5zbGljZSgwLCBUUlVOQ0FURV9MRU5HVEgpfSR7dmFsdWUubGVuZ3RoID4gVFJVTkNBVEVfTEVOR1RIID8gXCIuLi5cIiA6IFwiXCJ9YCxcbiAgICAgICAgbGVuZ3RoOiB2YWx1ZS5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyBiYXNlVXJsLCB3b3Jrc3BhY2UsIHRvb2wgfSA9IHJlc29sdmVTdHVkaW9CYXNlUm91dGUoXG4gICAgICAgIHR5cGVvZiBjb25maWcuc3R1ZGlvVXJsID09IFwiZnVuY3Rpb25cIiA/IGNvbmZpZy5zdHVkaW9Vcmwoc291cmNlRG9jdW1lbnQpIDogY29uZmlnLnN0dWRpb1VybFxuICAgICAgKTtcbiAgICAgIGlmICghYmFzZVVybClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgY29uc3QgeyBfaWQ6IGlkLCBfdHlwZTogdHlwZSwgX3Byb2plY3RJZDogcHJvamVjdElkLCBfZGF0YXNldDogZGF0YXNldCB9ID0gc291cmNlRG9jdW1lbnQ7XG4gICAgICByZXR1cm4gQyhcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW46IFwic2FuaXR5LmlvXCIsXG4gICAgICAgICAgaHJlZjogY3JlYXRlRWRpdFVybCh7XG4gICAgICAgICAgICBiYXNlVXJsLFxuICAgICAgICAgICAgd29ya3NwYWNlLFxuICAgICAgICAgICAgdG9vbCxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHBhdGg6IHNvdXJjZVBhdGgsXG4gICAgICAgICAgICAuLi4hY29uZmlnLm9taXRDcm9zc0RhdGFzZXRSZWZlcmVuY2VEYXRhICYmIHsgZGF0YXNldCwgcHJvamVjdElkIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvLyBXZSB1c2UgY3VzdG9tIGxvZ2ljIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGQgc2tpcCBlbmNvZGluZ1xuICAgICAgICAhMVxuICAgICAgKTtcbiAgICB9XG4gICk7XG4gIGlmIChsb2dnZXIpIHtcbiAgICBjb25zdCBpc1NraXBwaW5nID0gcmVwb3J0LnNraXBwZWQubGVuZ3RoLCBpc0VuY29kaW5nID0gcmVwb3J0LmVuY29kZWQubGVuZ3RoO1xuICAgIGlmICgoaXNTa2lwcGluZyB8fCBpc0VuY29kaW5nKSAmJiAoKGxvZ2dlcj8uZ3JvdXBDb2xsYXBzZWQgfHwgbG9nZ2VyLmxvZyk/LihcIltAc2FuaXR5L2NsaWVudF06IEVuY29kaW5nIHNvdXJjZSBtYXAgaW50byByZXN1bHRcIiksIGxvZ2dlci5sb2c/LihcbiAgICAgIGBbQHNhbml0eS9jbGllbnRdOiBQYXRocyBlbmNvZGVkOiAke3JlcG9ydC5lbmNvZGVkLmxlbmd0aH0sIHNraXBwZWQ6ICR7cmVwb3J0LnNraXBwZWQubGVuZ3RofWBcbiAgICApKSwgcmVwb3J0LmVuY29kZWQubGVuZ3RoID4gMCAmJiAobG9nZ2VyPy5sb2c/LihcIltAc2FuaXR5L2NsaWVudF06IFRhYmxlIG9mIGVuY29kZWQgcGF0aHNcIiksIChsb2dnZXI/LnRhYmxlIHx8IGxvZ2dlci5sb2cpPy4ocmVwb3J0LmVuY29kZWQpKSwgcmVwb3J0LnNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2tpcHBlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IHsgcGF0aCB9IG9mIHJlcG9ydC5za2lwcGVkKVxuICAgICAgICBza2lwcGVkLmFkZChwYXRoLnJlcGxhY2UocmVLZXlTZWdtZW50LCBcIjBcIikucmVwbGFjZSgvXFxbXFxkK1xcXS9nLCBcIltdXCIpKTtcbiAgICAgIGxvZ2dlcj8ubG9nPy4oXCJbQHNhbml0eS9jbGllbnRdOiBMaXN0IG9mIHNraXBwZWQgcGF0aHNcIiwgWy4uLnNraXBwZWQudmFsdWVzKCldKTtcbiAgICB9XG4gICAgKGlzU2tpcHBpbmcgfHwgaXNFbmNvZGluZykgJiYgbG9nZ2VyPy5ncm91cEVuZD8uKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFdpdGhTdGVnYTtcbn1cbmZ1bmN0aW9uIHByZXR0eVBhdGhGb3JMb2dnaW5nKHBhdGgpIHtcbiAgcmV0dXJuIHRvU3RyaW5nKGpzb25QYXRoVG9TdHVkaW9QYXRoKHBhdGgpKTtcbn1cbnZhciBzdGVnYUVuY29kZVNvdXJjZU1hcCQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHN0ZWdhRW5jb2RlU291cmNlTWFwXG59KTtcbmV4cG9ydCB7XG4gIGVuY29kZUludG9SZXN1bHQsXG4gIHN0ZWdhRW5jb2RlU291cmNlTWFwLFxuICBzdGVnYUVuY29kZVNvdXJjZU1hcCQxXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RlZ2FFbmNvZGVTb3VyY2VNYXAuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/client/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@sanity/client/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePatch: () => (/* binding */ BasePatch),\n/* harmony export */   BaseTransaction: () => (/* binding */ BaseTransaction),\n/* harmony export */   ClientError: () => (/* binding */ ClientError),\n/* harmony export */   CorsOriginError: () => (/* binding */ CorsOriginError),\n/* harmony export */   ObservablePatch: () => (/* binding */ ObservablePatch),\n/* harmony export */   ObservableSanityClient: () => (/* binding */ ObservableSanityClient),\n/* harmony export */   ObservableTransaction: () => (/* binding */ ObservableTransaction),\n/* harmony export */   Patch: () => (/* binding */ Patch),\n/* harmony export */   SanityClient: () => (/* binding */ SanityClient),\n/* harmony export */   ServerError: () => (/* binding */ ServerError),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   \"default\": () => (/* binding */ deprecatedCreateClient),\n/* harmony export */   requester: () => (/* binding */ requester),\n/* harmony export */   unstable__adapter: () => (/* reexport safe */ get_it__WEBPACK_IMPORTED_MODULE_7__.a),\n/* harmony export */   unstable__environment: () => (/* reexport safe */ get_it__WEBPACK_IMPORTED_MODULE_0__.environment),\n/* harmony export */   validateApiPerspective: () => (/* binding */ validateApiPerspective)\n/* harmony export */ });\n/* harmony import */ var get_it__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! get-it */ \"(ssr)/./node_modules/get-it/dist/index.js\");\n/* harmony import */ var get_it__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! get-it */ \"(ssr)/./node_modules/get-it/dist/_chunks-es/node-request.js\");\n/* harmony import */ var get_it_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! get-it/middleware */ \"(ssr)/./node_modules/get-it/dist/middleware.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/from.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/lastValueFrom.js\");\n/* harmony import */ var _chunks_es_stegaClean_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_chunks-es/stegaClean.js */ \"(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ \"(ssr)/./node_modules/rxjs/dist/cjs/operators/index.js\");\n\n\n\n\n\n\nclass ClientError extends Error {\n  response;\n  statusCode = 400;\n  responseBody;\n  details;\n  constructor(res) {\n    const props = extractErrorProps(res);\n    super(props.message), Object.assign(this, props);\n  }\n}\nclass ServerError extends Error {\n  response;\n  statusCode = 500;\n  responseBody;\n  details;\n  constructor(res) {\n    const props = extractErrorProps(res);\n    super(props.message), Object.assign(this, props);\n  }\n}\nfunction extractErrorProps(res) {\n  const body = res.body, props = {\n    response: res,\n    statusCode: res.statusCode,\n    responseBody: stringifyBody(body, res),\n    message: \"\",\n    details: void 0\n  };\n  if (body.error && body.message)\n    return props.message = `${body.error} - ${body.message}`, props;\n  if (isMutationError(body) || isActionError(body)) {\n    const allItems = body.error.items || [], items = allItems.slice(0, 5).map((item) => item.error?.description).filter(Boolean);\n    let itemsStr = items.length ? `:\n- ${items.join(`\n- `)}` : \"\";\n    return allItems.length > 5 && (itemsStr += `\n...and ${allItems.length - 5} more`), props.message = `${body.error.description}${itemsStr}`, props.details = body.error, props;\n  }\n  return body.error && body.error.description ? (props.message = body.error.description, props.details = body.error, props) : (props.message = body.error || body.message || httpErrorMessage(res), props);\n}\nfunction isMutationError(body) {\n  return isPlainObject(body) && isPlainObject(body.error) && body.error.type === \"mutationError\" && typeof body.error.description == \"string\";\n}\nfunction isActionError(body) {\n  return isPlainObject(body) && isPlainObject(body.error) && body.error.type === \"actionError\" && typeof body.error.description == \"string\";\n}\nfunction isPlainObject(obj) {\n  return typeof obj == \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction httpErrorMessage(res) {\n  const statusMessage = res.statusMessage ? ` ${res.statusMessage}` : \"\";\n  return `${res.method}-request to ${res.url} resulted in HTTP ${res.statusCode}${statusMessage}`;\n}\nfunction stringifyBody(body, res) {\n  return (res.headers[\"content-type\"] || \"\").toLowerCase().indexOf(\"application/json\") !== -1 ? JSON.stringify(body, null, 2) : body;\n}\nclass CorsOriginError extends Error {\n  projectId;\n  addOriginUrl;\n  constructor({ projectId: projectId2 }) {\n    super(\"CorsOriginError\"), this.name = \"CorsOriginError\", this.projectId = projectId2;\n    const url = new URL(`https://sanity.io/manage/project/${projectId2}/api`);\n    if (typeof location < \"u\") {\n      const { origin } = location;\n      url.searchParams.set(\"cors\", \"add\"), url.searchParams.set(\"origin\", origin), this.addOriginUrl = url, this.message = `The current origin is not allowed to connect to the Live Content API. Add it here: ${url}`;\n    } else\n      this.message = `The current origin is not allowed to connect to the Live Content API. Change your configuration here: ${url}`;\n  }\n}\nconst httpError = {\n  onResponse: (res) => {\n    if (res.statusCode >= 500)\n      throw new ServerError(res);\n    if (res.statusCode >= 400)\n      throw new ClientError(res);\n    return res;\n  }\n}, printWarnings = {\n  onResponse: (res) => {\n    const warn = res.headers[\"x-sanity-warning\"];\n    return (Array.isArray(warn) ? warn : [warn]).filter(Boolean).forEach((msg) => console.warn(msg)), res;\n  }\n};\nfunction defineHttpRequest(envMiddleware) {\n  return (0,get_it__WEBPACK_IMPORTED_MODULE_0__.getIt)([\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.retry)({ shouldRetry }),\n    ...envMiddleware,\n    printWarnings,\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.jsonRequest)(),\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.jsonResponse)(),\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.progress)(),\n    httpError,\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.observable)({ implementation: rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable })\n  ]);\n}\nfunction shouldRetry(err, attempt, options) {\n  if (options.maxRetries === 0)\n    return !1;\n  const isSafe = options.method === \"GET\" || options.method === \"HEAD\", isQuery = (options.uri || options.url).startsWith(\"/data/query\"), isRetriableResponse = err.response && (err.response.statusCode === 429 || err.response.statusCode === 502 || err.response.statusCode === 503);\n  return (isSafe || isQuery) && isRetriableResponse ? !0 : get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.retry.shouldRetry(err, attempt, options);\n}\nconst BASE_URL = \"https://www.sanity.io/help/\";\nfunction generateHelpUrl(slug) {\n  return BASE_URL + slug;\n}\nconst VALID_ASSET_TYPES = [\"image\", \"file\"], VALID_INSERT_LOCATIONS = [\"before\", \"after\", \"replace\"], dataset = (name2) => {\n  if (!/^(~[a-z0-9]{1}[-\\w]{0,63}|[a-z0-9]{1}[-\\w]{0,63})$/.test(name2))\n    throw new Error(\n      \"Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters\"\n    );\n}, projectId = (id) => {\n  if (!/^[-a-z0-9]+$/i.test(id))\n    throw new Error(\"`projectId` can only contain only a-z, 0-9 and dashes\");\n}, validateAssetType = (type) => {\n  if (VALID_ASSET_TYPES.indexOf(type) === -1)\n    throw new Error(`Invalid asset type: ${type}. Must be one of ${VALID_ASSET_TYPES.join(\", \")}`);\n}, validateObject = (op, val) => {\n  if (val === null || typeof val != \"object\" || Array.isArray(val))\n    throw new Error(`${op}() takes an object of properties`);\n}, validateDocumentId = (op, id) => {\n  if (typeof id != \"string\" || !/^[a-z0-9_][a-z0-9_.-]{0,127}$/i.test(id) || id.includes(\"..\"))\n    throw new Error(`${op}(): \"${id}\" is not a valid document ID`);\n}, requireDocumentId = (op, doc) => {\n  if (!doc._id)\n    throw new Error(`${op}() requires that the document contains an ID (\"_id\" property)`);\n  validateDocumentId(op, doc._id);\n}, validateInsert = (at, selector, items) => {\n  const signature = \"insert(at, selector, items)\";\n  if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {\n    const valid = VALID_INSERT_LOCATIONS.map((loc) => `\"${loc}\"`).join(\", \");\n    throw new Error(`${signature} takes an \"at\"-argument which is one of: ${valid}`);\n  }\n  if (typeof selector != \"string\")\n    throw new Error(`${signature} takes a \"selector\"-argument which must be a string`);\n  if (!Array.isArray(items))\n    throw new Error(`${signature} takes an \"items\"-argument which must be an array`);\n}, hasDataset = (config) => {\n  if (!config.dataset)\n    throw new Error(\"`dataset` must be provided to perform queries\");\n  return config.dataset || \"\";\n}, requestTag = (tag) => {\n  if (typeof tag != \"string\" || !/^[a-z0-9._-]{1,75}$/i.test(tag))\n    throw new Error(\n      \"Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.\"\n    );\n  return tag;\n};\nfunction once(fn) {\n  let didCall = !1, returnValue;\n  return (...args) => (didCall || (returnValue = fn(...args), didCall = !0), returnValue);\n}\nconst createWarningPrinter = (message) => (\n  // eslint-disable-next-line no-console\n  once((...args) => console.warn(message.join(\" \"), ...args))\n), printCdnAndWithCredentialsWarning = createWarningPrinter([\n  \"Because you set `withCredentials` to true, we will override your `useCdn`\",\n  \"setting to be false since (cookie-based) credentials are never set on the CDN\"\n]), printCdnWarning = createWarningPrinter([\n  \"Since you haven't set a value for `useCdn`, we will deliver content using our\",\n  \"global, edge-cached API-CDN. If you wish to have content delivered faster, set\",\n  \"`useCdn: false` to use the Live API. Note: You may incur higher costs using the live API.\"\n]), printCdnPreviewDraftsWarning = createWarningPrinter([\n  \"The Sanity client is configured with the `perspective` set to `previewDrafts`, which doesn't support the API-CDN.\",\n  \"The Live API will be used instead. Set `useCdn: false` in your configuration to hide this warning.\"\n]), printBrowserTokenWarning = createWarningPrinter([\n  \"You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.\",\n  `See ${generateHelpUrl(\n    \"js-client-browser-token\"\n  )} for more information and how to hide this warning.`\n]), printNoApiVersionSpecifiedWarning = createWarningPrinter([\n  \"Using the Sanity client without specifying an API version is deprecated.\",\n  `See ${generateHelpUrl(\"js-client-api-version\")}`\n]), printNoDefaultExport = createWarningPrinter([\n  \"The default export of @sanity/client has been deprecated. Use the named export `createClient` instead.\"\n]), defaultCdnHost = \"apicdn.sanity.io\", defaultConfig = {\n  apiHost: \"https://api.sanity.io\",\n  apiVersion: \"1\",\n  useProjectHostname: !0,\n  stega: { enabled: !1 }\n}, LOCALHOSTS = [\"localhost\", \"127.0.0.1\", \"0.0.0.0\"], isLocal = (host) => LOCALHOSTS.indexOf(host) !== -1;\nfunction validateApiVersion(apiVersion) {\n  if (apiVersion === \"1\" || apiVersion === \"X\")\n    return;\n  const apiDate = new Date(apiVersion);\n  if (!(/^\\d{4}-\\d{2}-\\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0))\n    throw new Error(\"Invalid API version string, expected `1` or date in format `YYYY-MM-DD`\");\n}\nfunction validateApiPerspective(perspective) {\n  if (Array.isArray(perspective)) {\n    for (const perspectiveValue of perspective)\n      if (perspectiveValue !== \"published\" && perspectiveValue !== \"drafts\" && !(typeof perspectiveValue == \"string\" && perspectiveValue.startsWith(\"r\") && perspectiveValue !== \"raw\"))\n        throw new TypeError(\n          \"Invalid API perspective value, expected `published`, `drafts` or a valid release identifier string\"\n        );\n    return;\n  }\n  switch (perspective) {\n    case \"previewDrafts\":\n    case \"drafts\":\n    case \"published\":\n    case \"raw\":\n      return;\n    default:\n      throw new TypeError(\n        \"Invalid API perspective string, expected `published`, `previewDrafts` or `raw`\"\n      );\n  }\n}\nconst initConfig = (config, prevConfig) => {\n  const specifiedConfig = {\n    ...prevConfig,\n    ...config,\n    stega: {\n      ...typeof prevConfig.stega == \"boolean\" ? { enabled: prevConfig.stega } : prevConfig.stega || defaultConfig.stega,\n      ...typeof config.stega == \"boolean\" ? { enabled: config.stega } : config.stega || {}\n    }\n  };\n  specifiedConfig.apiVersion || printNoApiVersionSpecifiedWarning();\n  const newConfig = {\n    ...defaultConfig,\n    ...specifiedConfig\n  }, projectBased = newConfig.useProjectHostname;\n  if (typeof Promise > \"u\") {\n    const helpUrl = generateHelpUrl(\"js-client-promise-polyfill\");\n    throw new Error(`No native Promise-implementation found, polyfill needed - see ${helpUrl}`);\n  }\n  if (projectBased && !newConfig.projectId)\n    throw new Error(\"Configuration must contain `projectId`\");\n  if (typeof newConfig.perspective < \"u\" && validateApiPerspective(newConfig.perspective), \"encodeSourceMap\" in newConfig)\n    throw new Error(\n      \"It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMap' is not supported in '@sanity/client'. Did you mean 'stega.enabled'?\"\n    );\n  if (\"encodeSourceMapAtPath\" in newConfig)\n    throw new Error(\n      \"It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMapAtPath' is not supported in '@sanity/client'. Did you mean 'stega.filter'?\"\n    );\n  if (typeof newConfig.stega.enabled != \"boolean\")\n    throw new Error(`stega.enabled must be a boolean, received ${newConfig.stega.enabled}`);\n  if (newConfig.stega.enabled && newConfig.stega.studioUrl === void 0)\n    throw new Error(\"stega.studioUrl must be defined when stega.enabled is true\");\n  if (newConfig.stega.enabled && typeof newConfig.stega.studioUrl != \"string\" && typeof newConfig.stega.studioUrl != \"function\")\n    throw new Error(\n      `stega.studioUrl must be a string or a function, received ${newConfig.stega.studioUrl}`\n    );\n  const isBrowser = typeof window < \"u\" && window.location && window.location.hostname, isLocalhost = isBrowser && isLocal(window.location.hostname);\n  isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== !0 ? printBrowserTokenWarning() : typeof newConfig.useCdn > \"u\" && printCdnWarning(), projectBased && projectId(newConfig.projectId), newConfig.dataset && dataset(newConfig.dataset), \"requestTagPrefix\" in newConfig && (newConfig.requestTagPrefix = newConfig.requestTagPrefix ? requestTag(newConfig.requestTagPrefix).replace(/\\.+$/, \"\") : void 0), newConfig.apiVersion = `${newConfig.apiVersion}`.replace(/^v/, \"\"), newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost, newConfig.useCdn === !0 && newConfig.withCredentials && printCdnAndWithCredentialsWarning(), newConfig.useCdn = newConfig.useCdn !== !1 && !newConfig.withCredentials, validateApiVersion(newConfig.apiVersion);\n  const hostParts = newConfig.apiHost.split(\"://\", 2), protocol = hostParts[0], host = hostParts[1], cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;\n  return newConfig.useProjectHostname ? (newConfig.url = `${protocol}://${newConfig.projectId}.${host}/v${newConfig.apiVersion}`, newConfig.cdnUrl = `${protocol}://${newConfig.projectId}.${cdnHost}/v${newConfig.apiVersion}`) : (newConfig.url = `${newConfig.apiHost}/v${newConfig.apiVersion}`, newConfig.cdnUrl = newConfig.url), newConfig;\n};\nfunction getSelection(sel) {\n  if (typeof sel == \"string\")\n    return { id: sel };\n  if (Array.isArray(sel))\n    return { query: \"*[_id in $ids]\", params: { ids: sel } };\n  if (typeof sel == \"object\" && sel !== null && \"query\" in sel && typeof sel.query == \"string\")\n    return \"params\" in sel && typeof sel.params == \"object\" && sel.params !== null ? { query: sel.query, params: sel.params } : { query: sel.query };\n  const selectionOpts = [\n    \"* Document ID (<docId>)\",\n    \"* Array of document IDs\",\n    \"* Object containing `query`\"\n  ].join(`\n`);\n  throw new Error(`Unknown selection - must be one of:\n\n${selectionOpts}`);\n}\nclass BasePatch {\n  selection;\n  operations;\n  constructor(selection, operations = {}) {\n    this.selection = selection, this.operations = operations;\n  }\n  /**\n   * Sets the given attributes to the document. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */\n  set(attrs) {\n    return this._assign(\"set\", attrs);\n  }\n  /**\n   * Sets the given attributes to the document if they are not currently set. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */\n  setIfMissing(attrs) {\n    return this._assign(\"setIfMissing\", attrs);\n  }\n  /**\n   * Performs a \"diff-match-patch\" operation on the string attributes provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to perform operation on. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"dmp\"\\}\n   */\n  diffMatchPatch(attrs) {\n    return validateObject(\"diffMatchPatch\", attrs), this._assign(\"diffMatchPatch\", attrs);\n  }\n  /**\n   * Unsets the attribute paths provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attribute paths to unset.\n   */\n  unset(attrs) {\n    if (!Array.isArray(attrs))\n      throw new Error(\"unset(attrs) takes an array of attributes to unset, non-array given\");\n    return this.operations = Object.assign({}, this.operations, { unset: attrs }), this;\n  }\n  /**\n   * Increment a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to increment, values representing the number to increment by.\n   */\n  inc(attrs) {\n    return this._assign(\"inc\", attrs);\n  }\n  /**\n   * Decrement a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to decrement, values representing the number to decrement by.\n   */\n  dec(attrs) {\n    return this._assign(\"dec\", attrs);\n  }\n  /**\n   * Provides methods for modifying arrays, by inserting, appending and replacing elements via a JSONPath expression.\n   *\n   * @param at - Location to insert at, relative to the given selector, or 'replace' the matched path\n   * @param selector - JSONPath expression, eg `comments[-1]` or `blocks[_key==\"abc123\"]`\n   * @param items - Array of items to insert/replace\n   */\n  insert(at, selector, items) {\n    return validateInsert(at, selector, items), this._assign(\"insert\", { [at]: selector, items });\n  }\n  /**\n   * Append the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to append to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to append to the array\n   */\n  append(selector, items) {\n    return this.insert(\"after\", `${selector}[-1]`, items);\n  }\n  /**\n   * Prepend the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to prepend to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to prepend to the array\n   */\n  prepend(selector, items) {\n    return this.insert(\"before\", `${selector}[0]`, items);\n  }\n  /**\n   * Change the contents of an array by removing existing elements and/or adding new elements.\n   *\n   * @param selector - Attribute or JSONPath expression for array\n   * @param start - Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.x\n   * @param deleteCount - An integer indicating the number of old array elements to remove.\n   * @param items - The elements to add to the array, beginning at the start index. If you don't specify any elements, splice() will only remove elements from the array.\n   */\n  splice(selector, start, deleteCount, items) {\n    const delAll = typeof deleteCount > \"u\" || deleteCount === -1, startIndex = start < 0 ? start - 1 : start, delCount = delAll ? -1 : Math.max(0, start + deleteCount), delRange = startIndex < 0 && delCount >= 0 ? \"\" : delCount, rangeSelector = `${selector}[${startIndex}:${delRange}]`;\n    return this.insert(\"replace\", rangeSelector, items || []);\n  }\n  /**\n   * Adds a revision clause, preventing the document from being patched if the `_rev` property does not match the given value\n   *\n   * @param rev - Revision to lock the patch to\n   */\n  ifRevisionId(rev) {\n    return this.operations.ifRevisionID = rev, this;\n  }\n  /**\n   * Return a plain JSON representation of the patch\n   */\n  serialize() {\n    return { ...getSelection(this.selection), ...this.operations };\n  }\n  /**\n   * Return a plain JSON representation of the patch\n   */\n  toJSON() {\n    return this.serialize();\n  }\n  /**\n   * Clears the patch of all operations\n   */\n  reset() {\n    return this.operations = {}, this;\n  }\n  _assign(op, props, merge = !0) {\n    return validateObject(op, props), this.operations = Object.assign({}, this.operations, {\n      [op]: Object.assign({}, merge && this.operations[op] || {}, props)\n    }), this;\n  }\n  _set(op, props) {\n    return this._assign(op, props, !1);\n  }\n}\nclass ObservablePatch extends BasePatch {\n  #client;\n  constructor(selection, operations, client) {\n    super(selection, operations), this.#client = client;\n  }\n  /**\n   * Clones the patch\n   */\n  clone() {\n    return new ObservablePatch(this.selection, { ...this.operations }, this.#client);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method\"\n      );\n    const returnFirst = typeof this.selection == \"string\", opts = Object.assign({ returnFirst, returnDocuments: !0 }, options);\n    return this.#client.mutate({ patch: this.serialize() }, opts);\n  }\n}\nclass Patch extends BasePatch {\n  #client;\n  constructor(selection, operations, client) {\n    super(selection, operations), this.#client = client;\n  }\n  /**\n   * Clones the patch\n   */\n  clone() {\n    return new Patch(this.selection, { ...this.operations }, this.#client);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method\"\n      );\n    const returnFirst = typeof this.selection == \"string\", opts = Object.assign({ returnFirst, returnDocuments: !0 }, options);\n    return this.#client.mutate({ patch: this.serialize() }, opts);\n  }\n}\nconst defaultMutateOptions = { returnDocuments: !1 };\nclass BaseTransaction {\n  operations;\n  trxId;\n  constructor(operations = [], transactionId) {\n    this.operations = operations, this.trxId = transactionId;\n  }\n  /**\n   * Creates a new Sanity document. If `_id` is provided and already exists, the mutation will fail. If no `_id` is given, one will automatically be generated by the database.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create. Requires a `_type` property.\n   */\n  create(doc) {\n    return validateObject(\"create\", doc), this._add({ create: doc });\n  }\n  /**\n   * Creates a new Sanity document. If a document with the same `_id` already exists, the create operation will be ignored.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create if it does not already exist. Requires `_id` and `_type` properties.\n   */\n  createIfNotExists(doc) {\n    const op = \"createIfNotExists\";\n    return validateObject(op, doc), requireDocumentId(op, doc), this._add({ [op]: doc });\n  }\n  /**\n   * Creates a new Sanity document, or replaces an existing one if the same `_id` is already used.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create or replace. Requires `_id` and `_type` properties.\n   */\n  createOrReplace(doc) {\n    const op = \"createOrReplace\";\n    return validateObject(op, doc), requireDocumentId(op, doc), this._add({ [op]: doc });\n  }\n  /**\n   * Deletes the document with the given document ID\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param documentId - Document ID to delete\n   */\n  delete(documentId) {\n    return validateDocumentId(\"delete\", documentId), this._add({ delete: { id: documentId } });\n  }\n  transactionId(id) {\n    return id ? (this.trxId = id, this) : this.trxId;\n  }\n  /**\n   * Return a plain JSON representation of the transaction\n   */\n  serialize() {\n    return [...this.operations];\n  }\n  /**\n   * Return a plain JSON representation of the transaction\n   */\n  toJSON() {\n    return this.serialize();\n  }\n  /**\n   * Clears the transaction of all operations\n   */\n  reset() {\n    return this.operations = [], this;\n  }\n  _add(mut) {\n    return this.operations.push(mut), this;\n  }\n}\nclass Transaction extends BaseTransaction {\n  #client;\n  constructor(operations, client, transactionId) {\n    super(operations, transactionId), this.#client = client;\n  }\n  /**\n   * Clones the transaction\n   */\n  clone() {\n    return new Transaction([...this.operations], this.#client, this.trxId);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method\"\n      );\n    return this.#client.mutate(\n      this.serialize(),\n      Object.assign({ transactionId: this.trxId }, defaultMutateOptions, options || {})\n    );\n  }\n  patch(patchOrDocumentId, patchOps) {\n    const isBuilder = typeof patchOps == \"function\";\n    if (typeof patchOrDocumentId != \"string\" && patchOrDocumentId instanceof Patch)\n      return this._add({ patch: patchOrDocumentId.serialize() });\n    if (isBuilder) {\n      const patch = patchOps(new Patch(patchOrDocumentId, {}, this.#client));\n      if (!(patch instanceof Patch))\n        throw new Error(\"function passed to `patch()` must return the patch\");\n      return this._add({ patch: patch.serialize() });\n    }\n    return this._add({ patch: { id: patchOrDocumentId, ...patchOps } });\n  }\n}\nclass ObservableTransaction extends BaseTransaction {\n  #client;\n  constructor(operations, client, transactionId) {\n    super(operations, transactionId), this.#client = client;\n  }\n  /**\n   * Clones the transaction\n   */\n  clone() {\n    return new ObservableTransaction([...this.operations], this.#client, this.trxId);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method\"\n      );\n    return this.#client.mutate(\n      this.serialize(),\n      Object.assign({ transactionId: this.trxId }, defaultMutateOptions, options || {})\n    );\n  }\n  patch(patchOrDocumentId, patchOps) {\n    const isBuilder = typeof patchOps == \"function\";\n    if (typeof patchOrDocumentId != \"string\" && patchOrDocumentId instanceof ObservablePatch)\n      return this._add({ patch: patchOrDocumentId.serialize() });\n    if (isBuilder) {\n      const patch = patchOps(new ObservablePatch(patchOrDocumentId, {}, this.#client));\n      if (!(patch instanceof ObservablePatch))\n        throw new Error(\"function passed to `patch()` must return the patch\");\n      return this._add({ patch: patch.serialize() });\n    }\n    return this._add({ patch: { id: patchOrDocumentId, ...patchOps } });\n  }\n}\nconst projectHeader = \"X-Sanity-Project-ID\";\nfunction requestOptions(config, overrides = {}) {\n  const headers2 = {}, token = overrides.token || config.token;\n  token && (headers2.Authorization = `Bearer ${token}`), !overrides.useGlobalApi && !config.useProjectHostname && config.projectId && (headers2[projectHeader] = config.projectId);\n  const withCredentials = !!(typeof overrides.withCredentials > \"u\" ? config.token || config.withCredentials : overrides.withCredentials), timeout = typeof overrides.timeout > \"u\" ? config.timeout : overrides.timeout;\n  return Object.assign({}, overrides, {\n    headers: Object.assign({}, headers2, overrides.headers || {}),\n    timeout: typeof timeout > \"u\" ? 5 * 60 * 1e3 : timeout,\n    proxy: overrides.proxy || config.proxy,\n    json: !0,\n    withCredentials,\n    fetch: typeof overrides.fetch == \"object\" && typeof config.fetch == \"object\" ? { ...config.fetch, ...overrides.fetch } : overrides.fetch || config.fetch\n  });\n}\nconst encodeQueryString = ({\n  query,\n  params = {},\n  options = {}\n}) => {\n  const searchParams = new URLSearchParams(), { tag, includeMutations, returnQuery, ...opts } = options;\n  tag && searchParams.append(\"tag\", tag), searchParams.append(\"query\", query);\n  for (const [key, value] of Object.entries(params))\n    searchParams.append(`$${key}`, JSON.stringify(value));\n  for (const [key, value] of Object.entries(opts))\n    value && searchParams.append(key, `${value}`);\n  return returnQuery === !1 && searchParams.append(\"returnQuery\", \"false\"), includeMutations === !1 && searchParams.append(\"includeMutations\", \"false\"), `?${searchParams}`;\n}, excludeFalsey = (param, defValue) => param === !1 ? void 0 : typeof param > \"u\" ? defValue : param, getMutationQuery = (options = {}) => ({\n  dryRun: options.dryRun,\n  returnIds: !0,\n  returnDocuments: excludeFalsey(options.returnDocuments, !0),\n  visibility: options.visibility || \"sync\",\n  autoGenerateArrayKeys: options.autoGenerateArrayKeys,\n  skipCrossDatasetReferenceValidation: options.skipCrossDatasetReferenceValidation\n}), isResponse = (event) => event.type === \"response\", getBody = (event) => event.body, indexBy = (docs, attr) => docs.reduce((indexed, doc) => (indexed[attr(doc)] = doc, indexed), /* @__PURE__ */ Object.create(null)), getQuerySizeLimit = 11264;\nfunction _fetch(client, httpRequest, _stega, query, _params = {}, options = {}) {\n  const stega = \"stega\" in options ? {\n    ..._stega || {},\n    ...typeof options.stega == \"boolean\" ? { enabled: options.stega } : options.stega || {}\n  } : _stega, params = stega.enabled ? (0,_chunks_es_stegaClean_js__WEBPACK_IMPORTED_MODULE_3__.stegaClean)(_params) : _params, mapResponse = options.filterResponse === !1 ? (res) => res : (res) => res.result, { cache, next, ...opts } = {\n    // Opt out of setting a `signal` on an internal `fetch` if one isn't provided.\n    // This is necessary in React Server Components to avoid opting out of Request Memoization.\n    useAbortSignal: typeof options.signal < \"u\",\n    // Set `resultSourceMap' when stega is enabled, as it's required for encoding.\n    resultSourceMap: stega.enabled ? \"withKeyArraySelector\" : options.resultSourceMap,\n    ...options,\n    // Default to not returning the query, unless `filterResponse` is `false`,\n    // or `returnQuery` is explicitly set. `true` is the default in Content Lake, so skip if truthy\n    returnQuery: options.filterResponse === !1 && options.returnQuery !== !1\n  }, reqOpts = typeof cache < \"u\" || typeof next < \"u\" ? { ...opts, fetch: { cache, next } } : opts, $request = _dataRequest(client, httpRequest, \"query\", { query, params }, reqOpts);\n  return stega.enabled ? $request.pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.combineLatestWith)(\n      (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.from)(\n        __webpack_require__.e(/*! import() */ \"vendor-chunks/@sanity\").then(__webpack_require__.bind(__webpack_require__, /*! ./_chunks-es/stegaEncodeSourceMap.js */ \"(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\")).then(function(n) {\n          return n.stegaEncodeSourceMap$1;\n        }).then(\n          ({ stegaEncodeSourceMap }) => stegaEncodeSourceMap\n        )\n      )\n    ),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(\n      ([res, stegaEncodeSourceMap]) => {\n        const result = stegaEncodeSourceMap(res.result, res.resultSourceMap, stega);\n        return mapResponse({ ...res, result });\n      }\n    )\n  ) : $request.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(mapResponse));\n}\nfunction _getDocument(client, httpRequest, id, opts = {}) {\n  const options = {\n    uri: _getDataUrl(client, \"doc\", id),\n    json: !0,\n    tag: opts.tag,\n    signal: opts.signal\n  };\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((event) => event.body.documents && event.body.documents[0])\n  );\n}\nfunction _getDocuments(client, httpRequest, ids, opts = {}) {\n  const options = {\n    uri: _getDataUrl(client, \"doc\", ids.join(\",\")),\n    json: !0,\n    tag: opts.tag,\n    signal: opts.signal\n  };\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((event) => {\n      const indexed = indexBy(event.body.documents || [], (doc) => doc._id);\n      return ids.map((id) => indexed[id] || null);\n    })\n  );\n}\nfunction _createIfNotExists(client, httpRequest, doc, options) {\n  return requireDocumentId(\"createIfNotExists\", doc), _create(client, httpRequest, doc, \"createIfNotExists\", options);\n}\nfunction _createOrReplace(client, httpRequest, doc, options) {\n  return requireDocumentId(\"createOrReplace\", doc), _create(client, httpRequest, doc, \"createOrReplace\", options);\n}\nfunction _delete(client, httpRequest, selection, options) {\n  return _dataRequest(\n    client,\n    httpRequest,\n    \"mutate\",\n    { mutations: [{ delete: getSelection(selection) }] },\n    options\n  );\n}\nfunction _mutate(client, httpRequest, mutations, options) {\n  let mut;\n  mutations instanceof Patch || mutations instanceof ObservablePatch ? mut = { patch: mutations.serialize() } : mutations instanceof Transaction || mutations instanceof ObservableTransaction ? mut = mutations.serialize() : mut = mutations;\n  const muts = Array.isArray(mut) ? mut : [mut], transactionId = options && options.transactionId || void 0;\n  return _dataRequest(client, httpRequest, \"mutate\", { mutations: muts, transactionId }, options);\n}\nfunction _action(client, httpRequest, actions, options) {\n  const acts = Array.isArray(actions) ? actions : [actions], transactionId = options && options.transactionId || void 0, skipCrossDatasetReferenceValidation = options && options.skipCrossDatasetReferenceValidation || void 0, dryRun = options && options.dryRun || void 0;\n  return _dataRequest(\n    client,\n    httpRequest,\n    \"actions\",\n    { actions: acts, transactionId, skipCrossDatasetReferenceValidation, dryRun },\n    options\n  );\n}\nfunction _dataRequest(client, httpRequest, endpoint, body, options = {}) {\n  const isMutation = endpoint === \"mutate\", isAction = endpoint === \"actions\", isQuery = endpoint === \"query\", strQuery = isMutation || isAction ? \"\" : encodeQueryString(body), useGet = !isMutation && !isAction && strQuery.length < getQuerySizeLimit, stringQuery = useGet ? strQuery : \"\", returnFirst = options.returnFirst, { timeout, token, tag, headers: headers2, returnQuery, lastLiveEventId, cacheMode } = options, uri = _getDataUrl(client, endpoint, stringQuery), reqOptions = {\n    method: useGet ? \"GET\" : \"POST\",\n    uri,\n    json: !0,\n    body: useGet ? void 0 : body,\n    query: isMutation && getMutationQuery(options),\n    timeout,\n    headers: headers2,\n    token,\n    tag,\n    returnQuery,\n    perspective: options.perspective,\n    resultSourceMap: options.resultSourceMap,\n    lastLiveEventId: Array.isArray(lastLiveEventId) ? lastLiveEventId[0] : lastLiveEventId,\n    cacheMode,\n    canUseCdn: isQuery,\n    signal: options.signal,\n    fetch: options.fetch,\n    useAbortSignal: options.useAbortSignal,\n    useCdn: options.useCdn\n  };\n  return _requestObservable(client, httpRequest, reqOptions).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(getBody),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((res) => {\n      if (!isMutation)\n        return res;\n      const results = res.results || [];\n      if (options.returnDocuments)\n        return returnFirst ? results[0] && results[0].document : results.map((mut) => mut.document);\n      const key = returnFirst ? \"documentId\" : \"documentIds\", ids = returnFirst ? results[0] && results[0].id : results.map((mut) => mut.id);\n      return {\n        transactionId: res.transactionId,\n        results,\n        [key]: ids\n      };\n    })\n  );\n}\nfunction _create(client, httpRequest, doc, op, options = {}) {\n  const mutation = { [op]: doc }, opts = Object.assign({ returnFirst: !0, returnDocuments: !0 }, options);\n  return _dataRequest(client, httpRequest, \"mutate\", { mutations: [mutation] }, opts);\n}\nfunction _requestObservable(client, httpRequest, options) {\n  const uri = options.url || options.uri, config = client.config(), canUseCdn = typeof options.canUseCdn > \"u\" ? [\"GET\", \"HEAD\"].indexOf(options.method || \"GET\") >= 0 && uri.indexOf(\"/data/\") === 0 : options.canUseCdn;\n  let useCdn = (options.useCdn ?? config.useCdn) && canUseCdn;\n  const tag = options.tag && config.requestTagPrefix ? [config.requestTagPrefix, options.tag].join(\".\") : options.tag || config.requestTagPrefix;\n  if (tag && options.tag !== null && (options.query = { tag: requestTag(tag), ...options.query }), [\"GET\", \"HEAD\", \"POST\"].indexOf(options.method || \"GET\") >= 0 && uri.indexOf(\"/data/query/\") === 0) {\n    const resultSourceMap = options.resultSourceMap ?? config.resultSourceMap;\n    resultSourceMap !== void 0 && resultSourceMap !== !1 && (options.query = { resultSourceMap, ...options.query });\n    const perspectiveOption = options.perspective || config.perspective;\n    typeof perspectiveOption < \"u\" && (validateApiPerspective(perspectiveOption), options.query = {\n      perspective: Array.isArray(perspectiveOption) ? perspectiveOption.join(\",\") : perspectiveOption,\n      ...options.query\n    }, perspectiveOption === \"previewDrafts\" && useCdn && (useCdn = !1, printCdnPreviewDraftsWarning())), options.lastLiveEventId && (options.query = { ...options.query, lastLiveEventId: options.lastLiveEventId }), options.returnQuery === !1 && (options.query = { returnQuery: \"false\", ...options.query }), useCdn && options.cacheMode == \"noStale\" && (options.query = { cacheMode: \"noStale\", ...options.query });\n  }\n  const reqOptions = requestOptions(\n    config,\n    Object.assign({}, options, {\n      url: _getUrl(client, uri, useCdn)\n    })\n  ), request = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable(\n    (subscriber) => httpRequest(reqOptions, config.requester).subscribe(subscriber)\n  );\n  return options.signal ? request.pipe(_withAbortSignal(options.signal)) : request;\n}\nfunction _request(client, httpRequest, options) {\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)((event) => event.type === \"response\"),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((event) => event.body)\n  );\n}\nfunction _getDataUrl(client, operation, path) {\n  const config = client.config(), catalog = hasDataset(config), baseUri = `/${operation}/${catalog}`;\n  return `/data${path ? `${baseUri}/${path}` : baseUri}`.replace(/\\/($|\\?)/, \"$1\");\n}\nfunction _getUrl(client, uri, canUseCdn = !1) {\n  const { url, cdnUrl } = client.config();\n  return `${canUseCdn ? cdnUrl : url}/${uri.replace(/^\\//, \"\")}`;\n}\nfunction _withAbortSignal(signal) {\n  return (input) => new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => {\n    const abort = () => observer.error(_createAbortError(signal));\n    if (signal && signal.aborted) {\n      abort();\n      return;\n    }\n    const subscription = input.subscribe(observer);\n    return signal.addEventListener(\"abort\", abort), () => {\n      signal.removeEventListener(\"abort\", abort), subscription.unsubscribe();\n    };\n  });\n}\nconst isDomExceptionSupported = !!globalThis.DOMException;\nfunction _createAbortError(signal) {\n  if (isDomExceptionSupported)\n    return new DOMException(signal?.reason ?? \"The operation was aborted.\", \"AbortError\");\n  const error = new Error(signal?.reason ?? \"The operation was aborted.\");\n  return error.name = \"AbortError\", error;\n}\nclass ObservableAssetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  upload(assetType, body, options) {\n    return _upload(this.#client, this.#httpRequest, assetType, body, options);\n  }\n}\nclass AssetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  upload(assetType, body, options) {\n    const observable2 = _upload(this.#client, this.#httpRequest, assetType, body, options);\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      observable2.pipe(\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)((event) => event.type === \"response\"),\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(\n          (event) => event.body.document\n        )\n      )\n    );\n  }\n}\nfunction _upload(client, httpRequest, assetType, body, opts = {}) {\n  validateAssetType(assetType);\n  let meta = opts.extract || void 0;\n  meta && !meta.length && (meta = [\"none\"]);\n  const dataset2 = hasDataset(client.config()), assetEndpoint = assetType === \"image\" ? \"images\" : \"files\", options = optionsFromFile(opts, body), { tag, label, title, description, creditLine, filename, source } = options, query = {\n    label,\n    title,\n    description,\n    filename,\n    meta,\n    creditLine\n  };\n  return source && (query.sourceId = source.id, query.sourceName = source.name, query.sourceUrl = source.url), _requestObservable(client, httpRequest, {\n    tag,\n    method: \"POST\",\n    timeout: options.timeout || 0,\n    uri: `/assets/${assetEndpoint}/${dataset2}`,\n    headers: options.contentType ? { \"Content-Type\": options.contentType } : {},\n    query,\n    body\n  });\n}\nfunction optionsFromFile(opts, file) {\n  return typeof File > \"u\" || !(file instanceof File) ? opts : Object.assign(\n    {\n      filename: opts.preserveFilename === !1 ? void 0 : file.name,\n      contentType: file.type\n    },\n    opts\n  );\n}\nvar defaults = (obj, defaults2) => Object.keys(defaults2).concat(Object.keys(obj)).reduce((target, prop) => (target[prop] = typeof obj[prop] > \"u\" ? defaults2[prop] : obj[prop], target), {});\nconst pick = (obj, props) => props.reduce((selection, prop) => (typeof obj[prop] > \"u\" || (selection[prop] = obj[prop]), selection), {}), MAX_URL_LENGTH = 14800, possibleOptions = [\n  \"includePreviousRevision\",\n  \"includeResult\",\n  \"includeMutations\",\n  \"visibility\",\n  \"effectFormat\",\n  \"tag\"\n], defaultOptions = {\n  includeResult: !0\n};\nfunction _listen(query, params, opts = {}) {\n  const { url, token, withCredentials, requestTagPrefix } = this.config(), tag = opts.tag && requestTagPrefix ? [requestTagPrefix, opts.tag].join(\".\") : opts.tag, options = { ...defaults(opts, defaultOptions), tag }, listenOpts = pick(options, possibleOptions), qs = encodeQueryString({ query, params, options: { tag, ...listenOpts } }), uri = `${url}${_getDataUrl(this, \"listen\", qs)}`;\n  if (uri.length > MAX_URL_LENGTH)\n    return new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => observer.error(new Error(\"Query too large for listener\")));\n  const listenFor = options.events ? options.events : [\"mutation\"], shouldEmitReconnect = listenFor.indexOf(\"reconnect\") !== -1, esOptions = {};\n  return (token || withCredentials) && (esOptions.withCredentials = !0), token && (esOptions.headers = {\n    Authorization: `Bearer ${token}`\n  }), new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => {\n    let es, reconnectTimer, stopped = !1, unsubscribed = !1;\n    open();\n    function onError() {\n      stopped || (emitReconnect(), !stopped && es.readyState === es.CLOSED && (unsubscribe(), clearTimeout(reconnectTimer), reconnectTimer = setTimeout(open, 100)));\n    }\n    function onChannelError(err) {\n      observer.error(cooerceError(err));\n    }\n    function onMessage(evt) {\n      const event = parseEvent$1(evt);\n      return event instanceof Error ? observer.error(event) : observer.next(event);\n    }\n    function onDisconnect() {\n      stopped = !0, unsubscribe(), observer.complete();\n    }\n    function unsubscribe() {\n      es && (es.removeEventListener(\"error\", onError), es.removeEventListener(\"channelError\", onChannelError), es.removeEventListener(\"disconnect\", onDisconnect), listenFor.forEach((type) => es.removeEventListener(type, onMessage)), es.close());\n    }\n    function emitReconnect() {\n      shouldEmitReconnect && observer.next({ type: \"reconnect\" });\n    }\n    async function getEventSource() {\n      const { default: EventSource2 } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@sanity\"), __webpack_require__.e(\"vendor-chunks/eventsource\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! @sanity/eventsource */ \"(ssr)/./node_modules/@sanity/eventsource/node.js\", 19));\n      if (unsubscribed)\n        return;\n      const evs = new EventSource2(uri, esOptions);\n      return evs.addEventListener(\"error\", onError), evs.addEventListener(\"channelError\", onChannelError), evs.addEventListener(\"disconnect\", onDisconnect), listenFor.forEach((type) => evs.addEventListener(type, onMessage)), evs;\n    }\n    function open() {\n      getEventSource().then((eventSource) => {\n        eventSource && (es = eventSource, unsubscribed && unsubscribe());\n      }).catch((reason) => {\n        observer.error(reason), stop();\n      });\n    }\n    function stop() {\n      stopped = !0, unsubscribe(), unsubscribed = !0;\n    }\n    return stop;\n  });\n}\nfunction parseEvent$1(event) {\n  try {\n    const data = event.data && JSON.parse(event.data) || {};\n    return Object.assign({ type: event.type }, data);\n  } catch (err) {\n    return err;\n  }\n}\nfunction cooerceError(err) {\n  if (err instanceof Error)\n    return err;\n  const evt = parseEvent$1(err);\n  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));\n}\nfunction extractErrorMessage(err) {\n  return err.error ? err.error.description ? err.error.description : typeof err.error == \"string\" ? err.error : JSON.stringify(err.error, null, 2) : err.message || \"Unknown listener error\";\n}\nconst requiredApiVersion = \"2021-03-26\";\nclass LiveClient {\n  #client;\n  constructor(client) {\n    this.#client = client;\n  }\n  /**\n   * Requires `apiVersion` to be `2021-03-26` or later.\n   */\n  events({\n    includeDrafts = !1,\n    tag: _tag\n  } = {}) {\n    const {\n      projectId: projectId2,\n      apiVersion: _apiVersion,\n      token,\n      withCredentials,\n      requestTagPrefix\n    } = this.#client.config(), apiVersion = _apiVersion.replace(/^v/, \"\");\n    if (apiVersion !== \"X\" && apiVersion < requiredApiVersion)\n      throw new Error(\n        `The live events API requires API version ${requiredApiVersion} or later. The current API version is ${apiVersion}. Please update your API version to use this feature.`\n      );\n    if (includeDrafts && !token && !withCredentials)\n      throw new Error(\n        \"The live events API requires a token or withCredentials when 'includeDrafts: true'. Please update your client configuration. The token should have the lowest possible access role.\"\n      );\n    if (includeDrafts && apiVersion !== \"X\")\n      throw new Error(\n        \"The live events API requires API version X when 'includeDrafts: true'. This API is experimental and may change or even be removed.\"\n      );\n    const path = _getDataUrl(this.#client, \"live/events\"), url = new URL(this.#client.getUrl(path, !1)), tag = _tag && requestTagPrefix ? [requestTagPrefix, _tag].join(\".\") : _tag;\n    tag && url.searchParams.set(\"tag\", tag), includeDrafts && url.searchParams.set(\"includeDrafts\", \"true\");\n    const listenFor = [\"restart\", \"message\", \"welcome\", \"reconnect\"], esOptions = {};\n    return includeDrafts && token && (esOptions.headers = {\n      Authorization: `Bearer ${token}`\n    }), includeDrafts && withCredentials && (esOptions.withCredentials = !0), new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => {\n      let es, reconnectTimer, stopped = !1, unsubscribed = !1;\n      open();\n      function onError(evt) {\n        if (!stopped) {\n          if (\"data\" in evt) {\n            const event = parseEvent(evt);\n            observer.error(new Error(event.message, { cause: event }));\n          }\n          es.readyState === es.CLOSED && (unsubscribe(), clearTimeout(reconnectTimer), reconnectTimer = setTimeout(open, 100));\n        }\n      }\n      function onMessage(evt) {\n        const event = parseEvent(evt);\n        return event instanceof Error ? observer.error(event) : observer.next(event);\n      }\n      function unsubscribe() {\n        if (es) {\n          es.removeEventListener(\"error\", onError);\n          for (const type of listenFor)\n            es.removeEventListener(type, onMessage);\n          es.close();\n        }\n      }\n      async function getEventSource() {\n        const EventSourceImplementation = typeof EventSource > \"u\" || esOptions.headers || esOptions.withCredentials ? (await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@sanity\"), __webpack_require__.e(\"vendor-chunks/eventsource\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! @sanity/eventsource */ \"(ssr)/./node_modules/@sanity/eventsource/node.js\", 19))).default : EventSource;\n        if (unsubscribed)\n          return;\n        try {\n          if (await fetch(url, {\n            method: \"OPTIONS\",\n            mode: \"cors\",\n            credentials: esOptions.withCredentials ? \"include\" : \"omit\",\n            headers: esOptions.headers\n          }), unsubscribed)\n            return;\n        } catch {\n          throw new CorsOriginError({ projectId: projectId2 });\n        }\n        const evs = new EventSourceImplementation(url.toString(), esOptions);\n        evs.addEventListener(\"error\", onError);\n        for (const type of listenFor)\n          evs.addEventListener(type, onMessage);\n        return evs;\n      }\n      function open() {\n        getEventSource().then((eventSource) => {\n          eventSource && (es = eventSource, unsubscribed && unsubscribe());\n        }).catch((reason) => {\n          observer.error(reason), stop();\n        });\n      }\n      function stop() {\n        stopped = !0, unsubscribe(), unsubscribed = !0;\n      }\n      return stop;\n    });\n  }\n}\nfunction parseEvent(event) {\n  try {\n    const data = event.data && JSON.parse(event.data) || {};\n    return { type: event.type, id: event.lastEventId, ...data };\n  } catch (err) {\n    return err;\n  }\n}\nclass ObservableDatasetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */\n  create(name2, options) {\n    return _modify(this.#client, this.#httpRequest, \"PUT\", name2, options);\n  }\n  /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */\n  edit(name2, options) {\n    return _modify(this.#client, this.#httpRequest, \"PATCH\", name2, options);\n  }\n  /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */\n  delete(name2) {\n    return _modify(this.#client, this.#httpRequest, \"DELETE\", name2);\n  }\n  /**\n   * Fetch a list of datasets for the configured project\n   */\n  list() {\n    return _request(this.#client, this.#httpRequest, {\n      uri: \"/datasets\",\n      tag: null\n    });\n  }\n}\nclass DatasetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */\n  create(name2, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _modify(this.#client, this.#httpRequest, \"PUT\", name2, options)\n    );\n  }\n  /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */\n  edit(name2, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _modify(this.#client, this.#httpRequest, \"PATCH\", name2, options)\n    );\n  }\n  /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */\n  delete(name2) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_modify(this.#client, this.#httpRequest, \"DELETE\", name2));\n  }\n  /**\n   * Fetch a list of datasets for the configured project\n   */\n  list() {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _request(this.#client, this.#httpRequest, { uri: \"/datasets\", tag: null })\n    );\n  }\n}\nfunction _modify(client, httpRequest, method, name2, options) {\n  return dataset(name2), _request(client, httpRequest, {\n    method,\n    uri: `/datasets/${name2}`,\n    body: options,\n    tag: null\n  });\n}\nclass ObservableProjectsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  list(options) {\n    const uri = options?.includeMembers === !1 ? \"/projects?includeMembers=false\" : \"/projects\";\n    return _request(this.#client, this.#httpRequest, { uri });\n  }\n  /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */\n  getById(projectId2) {\n    return _request(this.#client, this.#httpRequest, { uri: `/projects/${projectId2}` });\n  }\n}\nclass ProjectsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  list(options) {\n    const uri = options?.includeMembers === !1 ? \"/projects?includeMembers=false\" : \"/projects\";\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_request(this.#client, this.#httpRequest, { uri }));\n  }\n  /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */\n  getById(projectId2) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _request(this.#client, this.#httpRequest, { uri: `/projects/${projectId2}` })\n    );\n  }\n}\nclass ObservableUsersClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */\n  getById(id) {\n    return _request(\n      this.#client,\n      this.#httpRequest,\n      { uri: `/users/${id}` }\n    );\n  }\n}\nclass UsersClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */\n  getById(id) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _request(this.#client, this.#httpRequest, {\n        uri: `/users/${id}`\n      })\n    );\n  }\n}\nclass ObservableSanityClient {\n  assets;\n  datasets;\n  live;\n  projects;\n  users;\n  /**\n   * Private properties\n   */\n  #clientConfig;\n  #httpRequest;\n  /**\n   * Instance properties\n   */\n  listen = _listen;\n  constructor(httpRequest, config = defaultConfig) {\n    this.config(config), this.#httpRequest = httpRequest, this.assets = new ObservableAssetsClient(this, this.#httpRequest), this.datasets = new ObservableDatasetsClient(this, this.#httpRequest), this.live = new LiveClient(this), this.projects = new ObservableProjectsClient(this, this.#httpRequest), this.users = new ObservableUsersClient(this, this.#httpRequest);\n  }\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone() {\n    return new ObservableSanityClient(this.#httpRequest, this.config());\n  }\n  config(newConfig) {\n    if (newConfig === void 0)\n      return { ...this.#clientConfig };\n    if (this.#clientConfig && this.#clientConfig.allowReconfigure === !1)\n      throw new Error(\n        \"Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client\"\n      );\n    return this.#clientConfig = initConfig(newConfig, this.#clientConfig || {}), this;\n  }\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig) {\n    const thisConfig = this.config();\n    return new ObservableSanityClient(this.#httpRequest, {\n      ...thisConfig,\n      ...newConfig,\n      stega: {\n        ...thisConfig.stega || {},\n        ...typeof newConfig?.stega == \"boolean\" ? { enabled: newConfig.stega } : newConfig?.stega || {}\n      }\n    });\n  }\n  fetch(query, params, options) {\n    return _fetch(\n      this,\n      this.#httpRequest,\n      this.#clientConfig.stega,\n      query,\n      params,\n      options\n    );\n  }\n  /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */\n  getDocument(id, options) {\n    return _getDocument(this, this.#httpRequest, id, options);\n  }\n  /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */\n  getDocuments(ids, options) {\n    return _getDocuments(this, this.#httpRequest, ids, options);\n  }\n  create(document, options) {\n    return _create(this, this.#httpRequest, document, \"create\", options);\n  }\n  createIfNotExists(document, options) {\n    return _createIfNotExists(this, this.#httpRequest, document, options);\n  }\n  createOrReplace(document, options) {\n    return _createOrReplace(this, this.#httpRequest, document, options);\n  }\n  delete(selection, options) {\n    return _delete(this, this.#httpRequest, selection, options);\n  }\n  mutate(operations, options) {\n    return _mutate(this, this.#httpRequest, operations, options);\n  }\n  /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   * @returns Patch instance - call `.commit()` to perform the operations defined\n   */\n  patch(selection, operations) {\n    return new ObservablePatch(selection, operations, this);\n  }\n  /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */\n  transaction(operations) {\n    return new ObservableTransaction(operations, this);\n  }\n  /**\n   * Perform action operations against the configured dataset\n   *\n   * @param operations - Action operation(s) to execute\n   * @param options - Action options\n   */\n  action(operations, options) {\n    return _action(this, this.#httpRequest, operations, options);\n  }\n  /**\n   * Perform an HTTP request against the Sanity API\n   *\n   * @param options - Request options\n   */\n  request(options) {\n    return _request(this, this.#httpRequest, options);\n  }\n  /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */\n  getUrl(uri, canUseCdn) {\n    return _getUrl(this, uri, canUseCdn);\n  }\n  /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */\n  getDataUrl(operation, path) {\n    return _getDataUrl(this, operation, path);\n  }\n}\nclass SanityClient {\n  assets;\n  datasets;\n  live;\n  projects;\n  users;\n  /**\n   * Observable version of the Sanity client, with the same configuration as the promise-based one\n   */\n  observable;\n  /**\n   * Private properties\n   */\n  #clientConfig;\n  #httpRequest;\n  /**\n   * Instance properties\n   */\n  listen = _listen;\n  constructor(httpRequest, config = defaultConfig) {\n    this.config(config), this.#httpRequest = httpRequest, this.assets = new AssetsClient(this, this.#httpRequest), this.datasets = new DatasetsClient(this, this.#httpRequest), this.live = new LiveClient(this), this.projects = new ProjectsClient(this, this.#httpRequest), this.users = new UsersClient(this, this.#httpRequest), this.observable = new ObservableSanityClient(httpRequest, config);\n  }\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone() {\n    return new SanityClient(this.#httpRequest, this.config());\n  }\n  config(newConfig) {\n    if (newConfig === void 0)\n      return { ...this.#clientConfig };\n    if (this.#clientConfig && this.#clientConfig.allowReconfigure === !1)\n      throw new Error(\n        \"Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client\"\n      );\n    return this.observable && this.observable.config(newConfig), this.#clientConfig = initConfig(newConfig, this.#clientConfig || {}), this;\n  }\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig) {\n    const thisConfig = this.config();\n    return new SanityClient(this.#httpRequest, {\n      ...thisConfig,\n      ...newConfig,\n      stega: {\n        ...thisConfig.stega || {},\n        ...typeof newConfig?.stega == \"boolean\" ? { enabled: newConfig.stega } : newConfig?.stega || {}\n      }\n    });\n  }\n  fetch(query, params, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _fetch(\n        this,\n        this.#httpRequest,\n        this.#clientConfig.stega,\n        query,\n        params,\n        options\n      )\n    );\n  }\n  /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */\n  getDocument(id, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_getDocument(this, this.#httpRequest, id, options));\n  }\n  /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */\n  getDocuments(ids, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_getDocuments(this, this.#httpRequest, ids, options));\n  }\n  create(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _create(this, this.#httpRequest, document, \"create\", options)\n    );\n  }\n  createIfNotExists(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _createIfNotExists(this, this.#httpRequest, document, options)\n    );\n  }\n  createOrReplace(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _createOrReplace(this, this.#httpRequest, document, options)\n    );\n  }\n  delete(selection, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_delete(this, this.#httpRequest, selection, options));\n  }\n  mutate(operations, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_mutate(this, this.#httpRequest, operations, options));\n  }\n  /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   * @returns Patch instance - call `.commit()` to perform the operations defined\n   */\n  patch(documentId, operations) {\n    return new Patch(documentId, operations, this);\n  }\n  /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */\n  transaction(operations) {\n    return new Transaction(operations, this);\n  }\n  /**\n   * Perform action operations against the configured dataset\n   * Returns a promise that resolves to the transaction result\n   *\n   * @param operations - Action operation(s) to execute\n   * @param options - Action options\n   */\n  action(operations, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_action(this, this.#httpRequest, operations, options));\n  }\n  /**\n   * Perform a request against the Sanity API\n   * NOTE: Only use this for Sanity API endpoints, not for your own APIs!\n   *\n   * @param options - Request options\n   * @returns Promise resolving to the response body\n   */\n  request(options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_request(this, this.#httpRequest, options));\n  }\n  /**\n   * Perform an HTTP request a `/data` sub-endpoint\n   * NOTE: Considered internal, thus marked as deprecated. Use `request` instead.\n   *\n   * @deprecated - Use `request()` or your own HTTP library instead\n   * @param endpoint - Endpoint to hit (mutate, query etc)\n   * @param body - Request body\n   * @param options - Request options\n   * @internal\n   */\n  dataRequest(endpoint, body, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_dataRequest(this, this.#httpRequest, endpoint, body, options));\n  }\n  /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */\n  getUrl(uri, canUseCdn) {\n    return _getUrl(this, uri, canUseCdn);\n  }\n  /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */\n  getDataUrl(operation, path) {\n    return _getDataUrl(this, operation, path);\n  }\n}\nfunction defineCreateClientExports(envMiddleware, ClassConstructor) {\n  const defaultRequester = defineHttpRequest(envMiddleware);\n  return { requester: defaultRequester, createClient: (config) => new ClassConstructor(\n    (options, requester2) => (requester2 || defaultRequester)({\n      maxRedirects: 0,\n      maxRetries: config.maxRetries,\n      retryDelay: config.retryDelay,\n      ...options\n    }),\n    config\n  ) };\n}\nfunction defineDeprecatedCreateClient(createClient2) {\n  return function(config) {\n    return printNoDefaultExport(), createClient2(config);\n  };\n}\nvar name = \"@sanity/client\", version = \"6.24.1\";\nconst middleware = [\n  (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.debug)({ verbose: !0, namespace: \"sanity:client\" }),\n  (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.headers)({ \"User-Agent\": `${name} ${version}` }),\n  // Enable keep-alive, and in addition limit the number of sockets that can be opened.\n  // This avoids opening too many connections to the server if someone tries to execute\n  // a bunch of requests in parallel. It's recommended to have a concurrency limit\n  // at a \"higher limit\" (i.e. you shouldn't actually execute hundreds of requests in parallel),\n  // and this is mainly to minimize the impact for the network and server.\n  //\n  // We're currently matching the same defaults as browsers:\n  // https://stackoverflow.com/questions/26003756/is-there-a-limit-practical-or-otherwise-to-the-number-of-web-sockets-a-page-op\n  (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.agent)({\n    keepAlive: !0,\n    maxSockets: 30,\n    maxTotalSockets: 256\n  })\n], exp = defineCreateClientExports(middleware, SanityClient), requester = exp.requester, createClient = exp.createClient, deprecatedCreateClient = defineDeprecatedCreateClient(createClient);\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ2U7QUFDb0U7QUFDM0Q7QUFDQztBQUNRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWSxJQUFJLGFBQWE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEtBQUs7QUFDTDtBQUNBLFNBQVMscUJBQXFCLDJCQUEyQix1QkFBdUIsRUFBRSxTQUFTO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtCQUFrQjtBQUNsRSxZQUFZLFdBQVcsY0FBYyxTQUFTLG1CQUFtQixlQUFlLEVBQUUsY0FBYztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQSw0REFBNEQsV0FBVztBQUN2RTtBQUNBLGNBQWMsU0FBUztBQUN2QixpTkFBaU4sSUFBSTtBQUNyTixNQUFNO0FBQ04sOEhBQThILElBQUk7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2Q0FBSztBQUNkLElBQUksd0RBQUssR0FBRyxhQUFhO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLDhEQUFXO0FBQ2YsSUFBSSwrREFBWTtBQUNoQixJQUFJLDJEQUFRO0FBQ1o7QUFDQSxJQUFJLDZEQUFVLEdBQUcsZ0JB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QUFDQSxXQUFXLG1EQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsd0RBQUssR0FBRyx5Q0FBeUM7QUFDbkQsRUFBRSwwREFBTyxHQUFHLGlCQUFpQixNQUFNLEVBQUUsUUFBUSxHQUFHO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHdEQUFLO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBbUJFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95Y19kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9pbmRleC5qcz9lYjc4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEl0IH0gZnJvbSBcImdldC1pdFwiO1xuaW1wb3J0IHsgYWRhcHRlciwgZW52aXJvbm1lbnQgfSBmcm9tIFwiZ2V0LWl0XCI7XG5pbXBvcnQgeyByZXRyeSwganNvblJlcXVlc3QsIGpzb25SZXNwb25zZSwgcHJvZ3Jlc3MsIG9ic2VydmFibGUsIGRlYnVnLCBoZWFkZXJzLCBhZ2VudCB9IGZyb20gXCJnZXQtaXQvbWlkZGxld2FyZVwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZnJvbSwgbGFzdFZhbHVlRnJvbSB9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgeyBzdGVnYUNsZWFuIH0gZnJvbSBcIi4vX2NodW5rcy1lcy9zdGVnYUNsZWFuLmpzXCI7XG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0V2l0aCwgbWFwLCBmaWx0ZXIgfSBmcm9tIFwicnhqcy9vcGVyYXRvcnNcIjtcbmNsYXNzIENsaWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZXNwb25zZTtcbiAgc3RhdHVzQ29kZSA9IDQwMDtcbiAgcmVzcG9uc2VCb2R5O1xuICBkZXRhaWxzO1xuICBjb25zdHJ1Y3RvcihyZXMpIHtcbiAgICBjb25zdCBwcm9wcyA9IGV4dHJhY3RFcnJvclByb3BzKHJlcyk7XG4gICAgc3VwZXIocHJvcHMubWVzc2FnZSksIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcHMpO1xuICB9XG59XG5jbGFzcyBTZXJ2ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcmVzcG9uc2U7XG4gIHN0YXR1c0NvZGUgPSA1MDA7XG4gIHJlc3BvbnNlQm9keTtcbiAgZGV0YWlscztcbiAgY29uc3RydWN0b3IocmVzKSB7XG4gICAgY29uc3QgcHJvcHMgPSBleHRyYWN0RXJyb3JQcm9wcyhyZXMpO1xuICAgIHN1cGVyKHByb3BzLm1lc3NhZ2UpLCBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXh0cmFjdEVycm9yUHJvcHMocmVzKSB7XG4gIGNvbnN0IGJvZHkgPSByZXMuYm9keSwgcHJvcHMgPSB7XG4gICAgcmVzcG9uc2U6IHJlcyxcbiAgICBzdGF0dXNDb2RlOiByZXMuc3RhdHVzQ29kZSxcbiAgICByZXNwb25zZUJvZHk6IHN0cmluZ2lmeUJvZHkoYm9keSwgcmVzKSxcbiAgICBtZXNzYWdlOiBcIlwiLFxuICAgIGRldGFpbHM6IHZvaWQgMFxuICB9O1xuICBpZiAoYm9keS5lcnJvciAmJiBib2R5Lm1lc3NhZ2UpXG4gICAgcmV0dXJuIHByb3BzLm1lc3NhZ2UgPSBgJHtib2R5LmVycm9yfSAtICR7Ym9keS5tZXNzYWdlfWAsIHByb3BzO1xuICBpZiAoaXNNdXRhdGlvbkVycm9yKGJvZHkpIHx8IGlzQWN0aW9uRXJyb3IoYm9keSkpIHtcbiAgICBjb25zdCBhbGxJdGVtcyA9IGJvZHkuZXJyb3IuaXRlbXMgfHwgW10sIGl0ZW1zID0gYWxsSXRlbXMuc2xpY2UoMCwgNSkubWFwKChpdGVtKSA9PiBpdGVtLmVycm9yPy5kZXNjcmlwdGlvbikuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGxldCBpdGVtc1N0ciA9IGl0ZW1zLmxlbmd0aCA/IGA6XG4tICR7aXRlbXMuam9pbihgXG4tIGApfWAgOiBcIlwiO1xuICAgIHJldHVybiBhbGxJdGVtcy5sZW5ndGggPiA1ICYmIChpdGVtc1N0ciArPSBgXG4uLi5hbmQgJHthbGxJdGVtcy5sZW5ndGggLSA1fSBtb3JlYCksIHByb3BzLm1lc3NhZ2UgPSBgJHtib2R5LmVycm9yLmRlc2NyaXB0aW9ufSR7aXRlbXNTdHJ9YCwgcHJvcHMuZGV0YWlscyA9IGJvZHkuZXJyb3IsIHByb3BzO1xuICB9XG4gIHJldHVybiBib2R5LmVycm9yICYmIGJvZHkuZXJyb3IuZGVzY3JpcHRpb24gPyAocHJvcHMubWVzc2FnZSA9IGJvZHkuZXJyb3IuZGVzY3JpcHRpb24sIHByb3BzLmRldGFpbHMgPSBib2R5LmVycm9yLCBwcm9wcykgOiAocHJvcHMubWVzc2FnZSA9IGJvZHkuZXJyb3IgfHwgYm9keS5tZXNzYWdlIHx8IGh0dHBFcnJvck1lc3NhZ2UocmVzKSwgcHJvcHMpO1xufVxuZnVuY3Rpb24gaXNNdXRhdGlvbkVycm9yKGJvZHkpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoYm9keSkgJiYgaXNQbGFpbk9iamVjdChib2R5LmVycm9yKSAmJiBib2R5LmVycm9yLnR5cGUgPT09IFwibXV0YXRpb25FcnJvclwiICYmIHR5cGVvZiBib2R5LmVycm9yLmRlc2NyaXB0aW9uID09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0FjdGlvbkVycm9yKGJvZHkpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoYm9keSkgJiYgaXNQbGFpbk9iamVjdChib2R5LmVycm9yKSAmJiBib2R5LmVycm9yLnR5cGUgPT09IFwiYWN0aW9uRXJyb3JcIiAmJiB0eXBlb2YgYm9keS5lcnJvci5kZXNjcmlwdGlvbiA9PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn1cbmZ1bmN0aW9uIGh0dHBFcnJvck1lc3NhZ2UocmVzKSB7XG4gIGNvbnN0IHN0YXR1c01lc3NhZ2UgPSByZXMuc3RhdHVzTWVzc2FnZSA/IGAgJHtyZXMuc3RhdHVzTWVzc2FnZX1gIDogXCJcIjtcbiAgcmV0dXJuIGAke3Jlcy5tZXRob2R9LXJlcXVlc3QgdG8gJHtyZXMudXJsfSByZXN1bHRlZCBpbiBIVFRQICR7cmVzLnN0YXR1c0NvZGV9JHtzdGF0dXNNZXNzYWdlfWA7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlCb2R5KGJvZHksIHJlcykge1xuICByZXR1cm4gKHJlcy5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikgIT09IC0xID8gSlNPTi5zdHJpbmdpZnkoYm9keSwgbnVsbCwgMikgOiBib2R5O1xufVxuY2xhc3MgQ29yc09yaWdpbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwcm9qZWN0SWQ7XG4gIGFkZE9yaWdpblVybDtcbiAgY29uc3RydWN0b3IoeyBwcm9qZWN0SWQ6IHByb2plY3RJZDIgfSkge1xuICAgIHN1cGVyKFwiQ29yc09yaWdpbkVycm9yXCIpLCB0aGlzLm5hbWUgPSBcIkNvcnNPcmlnaW5FcnJvclwiLCB0aGlzLnByb2plY3RJZCA9IHByb2plY3RJZDI7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChgaHR0cHM6Ly9zYW5pdHkuaW8vbWFuYWdlL3Byb2plY3QvJHtwcm9qZWN0SWQyfS9hcGlgKTtcbiAgICBpZiAodHlwZW9mIGxvY2F0aW9uIDwgXCJ1XCIpIHtcbiAgICAgIGNvbnN0IHsgb3JpZ2luIH0gPSBsb2NhdGlvbjtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiY29yc1wiLCBcImFkZFwiKSwgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJvcmlnaW5cIiwgb3JpZ2luKSwgdGhpcy5hZGRPcmlnaW5VcmwgPSB1cmwsIHRoaXMubWVzc2FnZSA9IGBUaGUgY3VycmVudCBvcmlnaW4gaXMgbm90IGFsbG93ZWQgdG8gY29ubmVjdCB0byB0aGUgTGl2ZSBDb250ZW50IEFQSS4gQWRkIGl0IGhlcmU6ICR7dXJsfWA7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLm1lc3NhZ2UgPSBgVGhlIGN1cnJlbnQgb3JpZ2luIGlzIG5vdCBhbGxvd2VkIHRvIGNvbm5lY3QgdG8gdGhlIExpdmUgQ29udGVudCBBUEkuIENoYW5nZSB5b3VyIGNvbmZpZ3VyYXRpb24gaGVyZTogJHt1cmx9YDtcbiAgfVxufVxuY29uc3QgaHR0cEVycm9yID0ge1xuICBvblJlc3BvbnNlOiAocmVzKSA9PiB7XG4gICAgaWYgKHJlcy5zdGF0dXNDb2RlID49IDUwMClcbiAgICAgIHRocm93IG5ldyBTZXJ2ZXJFcnJvcihyZXMpO1xuICAgIGlmIChyZXMuc3RhdHVzQ29kZSA+PSA0MDApXG4gICAgICB0aHJvdyBuZXcgQ2xpZW50RXJyb3IocmVzKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG59LCBwcmludFdhcm5pbmdzID0ge1xuICBvblJlc3BvbnNlOiAocmVzKSA9PiB7XG4gICAgY29uc3Qgd2FybiA9IHJlcy5oZWFkZXJzW1wieC1zYW5pdHktd2FybmluZ1wiXTtcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkod2FybikgPyB3YXJuIDogW3dhcm5dKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaCgobXNnKSA9PiBjb25zb2xlLndhcm4obXNnKSksIHJlcztcbiAgfVxufTtcbmZ1bmN0aW9uIGRlZmluZUh0dHBSZXF1ZXN0KGVudk1pZGRsZXdhcmUpIHtcbiAgcmV0dXJuIGdldEl0KFtcbiAgICByZXRyeSh7IHNob3VsZFJldHJ5IH0pLFxuICAgIC4uLmVudk1pZGRsZXdhcmUsXG4gICAgcHJpbnRXYXJuaW5ncyxcbiAgICBqc29uUmVxdWVzdCgpLFxuICAgIGpzb25SZXNwb25zZSgpLFxuICAgIHByb2dyZXNzKCksXG4gICAgaHR0cEVycm9yLFxuICAgIG9ic2VydmFibGUoeyBpbXBsZW1lbnRhdGlvbjogT2JzZXJ2YWJsZSB9KVxuICBdKTtcbn1cbmZ1bmN0aW9uIHNob3VsZFJldHJ5KGVyciwgYXR0ZW1wdCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5tYXhSZXRyaWVzID09PSAwKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgaXNTYWZlID0gb3B0aW9ucy5tZXRob2QgPT09IFwiR0VUXCIgfHwgb3B0aW9ucy5tZXRob2QgPT09IFwiSEVBRFwiLCBpc1F1ZXJ5ID0gKG9wdGlvbnMudXJpIHx8IG9wdGlvbnMudXJsKS5zdGFydHNXaXRoKFwiL2RhdGEvcXVlcnlcIiksIGlzUmV0cmlhYmxlUmVzcG9uc2UgPSBlcnIucmVzcG9uc2UgJiYgKGVyci5yZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkgfHwgZXJyLnJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDUwMiB8fCBlcnIucmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNTAzKTtcbiAgcmV0dXJuIChpc1NhZmUgfHwgaXNRdWVyeSkgJiYgaXNSZXRyaWFibGVSZXNwb25zZSA/ICEwIDogcmV0cnkuc2hvdWxkUmV0cnkoZXJyLCBhdHRlbXB0LCBvcHRpb25zKTtcbn1cbmNvbnN0IEJBU0VfVVJMID0gXCJodHRwczovL3d3dy5zYW5pdHkuaW8vaGVscC9cIjtcbmZ1bmN0aW9uIGdlbmVyYXRlSGVscFVybChzbHVnKSB7XG4gIHJldHVybiBCQVNFX1VSTCArIHNsdWc7XG59XG5jb25zdCBWQUxJRF9BU1NFVF9UWVBFUyA9IFtcImltYWdlXCIsIFwiZmlsZVwiXSwgVkFMSURfSU5TRVJUX0xPQ0FUSU9OUyA9IFtcImJlZm9yZVwiLCBcImFmdGVyXCIsIFwicmVwbGFjZVwiXSwgZGF0YXNldCA9IChuYW1lMikgPT4ge1xuICBpZiAoIS9eKH5bYS16MC05XXsxfVstXFx3XXswLDYzfXxbYS16MC05XXsxfVstXFx3XXswLDYzfSkkLy50ZXN0KG5hbWUyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkRhdGFzZXRzIGNhbiBvbmx5IGNvbnRhaW4gbG93ZXJjYXNlIGNoYXJhY3RlcnMsIG51bWJlcnMsIHVuZGVyc2NvcmVzIGFuZCBkYXNoZXMsIGFuZCBzdGFydCB3aXRoIHRpbGRlLCBhbmQgYmUgbWF4aW11bSA2NCBjaGFyYWN0ZXJzXCJcbiAgICApO1xufSwgcHJvamVjdElkID0gKGlkKSA9PiB7XG4gIGlmICghL15bLWEtejAtOV0rJC9pLnRlc3QoaWQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImBwcm9qZWN0SWRgIGNhbiBvbmx5IGNvbnRhaW4gb25seSBhLXosIDAtOSBhbmQgZGFzaGVzXCIpO1xufSwgdmFsaWRhdGVBc3NldFR5cGUgPSAodHlwZSkgPT4ge1xuICBpZiAoVkFMSURfQVNTRVRfVFlQRVMuaW5kZXhPZih0eXBlKSA9PT0gLTEpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzc2V0IHR5cGU6ICR7dHlwZX0uIE11c3QgYmUgb25lIG9mICR7VkFMSURfQVNTRVRfVFlQRVMuam9pbihcIiwgXCIpfWApO1xufSwgdmFsaWRhdGVPYmplY3QgPSAob3AsIHZhbCkgPT4ge1xuICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgIT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke29wfSgpIHRha2VzIGFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzYCk7XG59LCB2YWxpZGF0ZURvY3VtZW50SWQgPSAob3AsIGlkKSA9PiB7XG4gIGlmICh0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIiB8fCAhL15bYS16MC05X11bYS16MC05Xy4tXXswLDEyN30kL2kudGVzdChpZCkgfHwgaWQuaW5jbHVkZXMoXCIuLlwiKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3B9KCk6IFwiJHtpZH1cIiBpcyBub3QgYSB2YWxpZCBkb2N1bWVudCBJRGApO1xufSwgcmVxdWlyZURvY3VtZW50SWQgPSAob3AsIGRvYykgPT4ge1xuICBpZiAoIWRvYy5faWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke29wfSgpIHJlcXVpcmVzIHRoYXQgdGhlIGRvY3VtZW50IGNvbnRhaW5zIGFuIElEIChcIl9pZFwiIHByb3BlcnR5KWApO1xuICB2YWxpZGF0ZURvY3VtZW50SWQob3AsIGRvYy5faWQpO1xufSwgdmFsaWRhdGVJbnNlcnQgPSAoYXQsIHNlbGVjdG9yLCBpdGVtcykgPT4ge1xuICBjb25zdCBzaWduYXR1cmUgPSBcImluc2VydChhdCwgc2VsZWN0b3IsIGl0ZW1zKVwiO1xuICBpZiAoVkFMSURfSU5TRVJUX0xPQ0FUSU9OUy5pbmRleE9mKGF0KSA9PT0gLTEpIHtcbiAgICBjb25zdCB2YWxpZCA9IFZBTElEX0lOU0VSVF9MT0NBVElPTlMubWFwKChsb2MpID0+IGBcIiR7bG9jfVwiYCkuam9pbihcIiwgXCIpO1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtzaWduYXR1cmV9IHRha2VzIGFuIFwiYXRcIi1hcmd1bWVudCB3aGljaCBpcyBvbmUgb2Y6ICR7dmFsaWR9YCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzaWduYXR1cmV9IHRha2VzIGEgXCJzZWxlY3RvclwiLWFyZ3VtZW50IHdoaWNoIG11c3QgYmUgYSBzdHJpbmdgKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c2lnbmF0dXJlfSB0YWtlcyBhbiBcIml0ZW1zXCItYXJndW1lbnQgd2hpY2ggbXVzdCBiZSBhbiBhcnJheWApO1xufSwgaGFzRGF0YXNldCA9IChjb25maWcpID0+IHtcbiAgaWYgKCFjb25maWcuZGF0YXNldClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZGF0YXNldGAgbXVzdCBiZSBwcm92aWRlZCB0byBwZXJmb3JtIHF1ZXJpZXNcIik7XG4gIHJldHVybiBjb25maWcuZGF0YXNldCB8fCBcIlwiO1xufSwgcmVxdWVzdFRhZyA9ICh0YWcpID0+IHtcbiAgaWYgKHR5cGVvZiB0YWcgIT0gXCJzdHJpbmdcIiB8fCAhL15bYS16MC05Ll8tXXsxLDc1fSQvaS50ZXN0KHRhZykpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUYWcgY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycywgdW5kZXJzY29yZXMsIGRhc2hlcyBhbmQgZG90cywgYW5kIGJlIGJldHdlZW4gb25lIGFuZCA3NSBjaGFyYWN0ZXJzIGxvbmcuXCJcbiAgICApO1xuICByZXR1cm4gdGFnO1xufTtcbmZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgbGV0IGRpZENhbGwgPSAhMSwgcmV0dXJuVmFsdWU7XG4gIHJldHVybiAoLi4uYXJncykgPT4gKGRpZENhbGwgfHwgKHJldHVyblZhbHVlID0gZm4oLi4uYXJncyksIGRpZENhbGwgPSAhMCksIHJldHVyblZhbHVlKTtcbn1cbmNvbnN0IGNyZWF0ZVdhcm5pbmdQcmludGVyID0gKG1lc3NhZ2UpID0+IChcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgb25jZSgoLi4uYXJncykgPT4gY29uc29sZS53YXJuKG1lc3NhZ2Uuam9pbihcIiBcIiksIC4uLmFyZ3MpKVxuKSwgcHJpbnRDZG5BbmRXaXRoQ3JlZGVudGlhbHNXYXJuaW5nID0gY3JlYXRlV2FybmluZ1ByaW50ZXIoW1xuICBcIkJlY2F1c2UgeW91IHNldCBgd2l0aENyZWRlbnRpYWxzYCB0byB0cnVlLCB3ZSB3aWxsIG92ZXJyaWRlIHlvdXIgYHVzZUNkbmBcIixcbiAgXCJzZXR0aW5nIHRvIGJlIGZhbHNlIHNpbmNlIChjb29raWUtYmFzZWQpIGNyZWRlbnRpYWxzIGFyZSBuZXZlciBzZXQgb24gdGhlIENETlwiXG5dKSwgcHJpbnRDZG5XYXJuaW5nID0gY3JlYXRlV2FybmluZ1ByaW50ZXIoW1xuICBcIlNpbmNlIHlvdSBoYXZlbid0IHNldCBhIHZhbHVlIGZvciBgdXNlQ2RuYCwgd2Ugd2lsbCBkZWxpdmVyIGNvbnRlbnQgdXNpbmcgb3VyXCIsXG4gIFwiZ2xvYmFsLCBlZGdlLWNhY2hlZCBBUEktQ0ROLiBJZiB5b3Ugd2lzaCB0byBoYXZlIGNvbnRlbnQgZGVsaXZlcmVkIGZhc3Rlciwgc2V0XCIsXG4gIFwiYHVzZUNkbjogZmFsc2VgIHRvIHVzZSB0aGUgTGl2ZSBBUEkuIE5vdGU6IFlvdSBtYXkgaW5jdXIgaGlnaGVyIGNvc3RzIHVzaW5nIHRoZSBsaXZlIEFQSS5cIlxuXSksIHByaW50Q2RuUHJldmlld0RyYWZ0c1dhcm5pbmcgPSBjcmVhdGVXYXJuaW5nUHJpbnRlcihbXG4gIFwiVGhlIFNhbml0eSBjbGllbnQgaXMgY29uZmlndXJlZCB3aXRoIHRoZSBgcGVyc3BlY3RpdmVgIHNldCB0byBgcHJldmlld0RyYWZ0c2AsIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgQVBJLUNETi5cIixcbiAgXCJUaGUgTGl2ZSBBUEkgd2lsbCBiZSB1c2VkIGluc3RlYWQuIFNldCBgdXNlQ2RuOiBmYWxzZWAgaW4geW91ciBjb25maWd1cmF0aW9uIHRvIGhpZGUgdGhpcyB3YXJuaW5nLlwiXG5dKSwgcHJpbnRCcm93c2VyVG9rZW5XYXJuaW5nID0gY3JlYXRlV2FybmluZ1ByaW50ZXIoW1xuICBcIllvdSBoYXZlIGNvbmZpZ3VyZWQgU2FuaXR5IGNsaWVudCB0byB1c2UgYSB0b2tlbiBpbiB0aGUgYnJvd3Nlci4gVGhpcyBtYXkgY2F1c2UgdW5pbnRlbnRpb25hbCBzZWN1cml0eSBpc3N1ZXMuXCIsXG4gIGBTZWUgJHtnZW5lcmF0ZUhlbHBVcmwoXG4gICAgXCJqcy1jbGllbnQtYnJvd3Nlci10b2tlblwiXG4gICl9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBob3cgdG8gaGlkZSB0aGlzIHdhcm5pbmcuYFxuXSksIHByaW50Tm9BcGlWZXJzaW9uU3BlY2lmaWVkV2FybmluZyA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFtcbiAgXCJVc2luZyB0aGUgU2FuaXR5IGNsaWVudCB3aXRob3V0IHNwZWNpZnlpbmcgYW4gQVBJIHZlcnNpb24gaXMgZGVwcmVjYXRlZC5cIixcbiAgYFNlZSAke2dlbmVyYXRlSGVscFVybChcImpzLWNsaWVudC1hcGktdmVyc2lvblwiKX1gXG5dKSwgcHJpbnROb0RlZmF1bHRFeHBvcnQgPSBjcmVhdGVXYXJuaW5nUHJpbnRlcihbXG4gIFwiVGhlIGRlZmF1bHQgZXhwb3J0IG9mIEBzYW5pdHkvY2xpZW50IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSB0aGUgbmFtZWQgZXhwb3J0IGBjcmVhdGVDbGllbnRgIGluc3RlYWQuXCJcbl0pLCBkZWZhdWx0Q2RuSG9zdCA9IFwiYXBpY2RuLnNhbml0eS5pb1wiLCBkZWZhdWx0Q29uZmlnID0ge1xuICBhcGlIb3N0OiBcImh0dHBzOi8vYXBpLnNhbml0eS5pb1wiLFxuICBhcGlWZXJzaW9uOiBcIjFcIixcbiAgdXNlUHJvamVjdEhvc3RuYW1lOiAhMCxcbiAgc3RlZ2E6IHsgZW5hYmxlZDogITEgfVxufSwgTE9DQUxIT1NUUyA9IFtcImxvY2FsaG9zdFwiLCBcIjEyNy4wLjAuMVwiLCBcIjAuMC4wLjBcIl0sIGlzTG9jYWwgPSAoaG9zdCkgPT4gTE9DQUxIT1NUUy5pbmRleE9mKGhvc3QpICE9PSAtMTtcbmZ1bmN0aW9uIHZhbGlkYXRlQXBpVmVyc2lvbihhcGlWZXJzaW9uKSB7XG4gIGlmIChhcGlWZXJzaW9uID09PSBcIjFcIiB8fCBhcGlWZXJzaW9uID09PSBcIlhcIilcbiAgICByZXR1cm47XG4gIGNvbnN0IGFwaURhdGUgPSBuZXcgRGF0ZShhcGlWZXJzaW9uKTtcbiAgaWYgKCEoL15cXGR7NH0tXFxkezJ9LVxcZHsyfSQvLnRlc3QoYXBpVmVyc2lvbikgJiYgYXBpRGF0ZSBpbnN0YW5jZW9mIERhdGUgJiYgYXBpRGF0ZS5nZXRUaW1lKCkgPiAwKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEFQSSB2ZXJzaW9uIHN0cmluZywgZXhwZWN0ZWQgYDFgIG9yIGRhdGUgaW4gZm9ybWF0IGBZWVlZLU1NLUREYFwiKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXBpUGVyc3BlY3RpdmUocGVyc3BlY3RpdmUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGVyc3BlY3RpdmUpKSB7XG4gICAgZm9yIChjb25zdCBwZXJzcGVjdGl2ZVZhbHVlIG9mIHBlcnNwZWN0aXZlKVxuICAgICAgaWYgKHBlcnNwZWN0aXZlVmFsdWUgIT09IFwicHVibGlzaGVkXCIgJiYgcGVyc3BlY3RpdmVWYWx1ZSAhPT0gXCJkcmFmdHNcIiAmJiAhKHR5cGVvZiBwZXJzcGVjdGl2ZVZhbHVlID09IFwic3RyaW5nXCIgJiYgcGVyc3BlY3RpdmVWYWx1ZS5zdGFydHNXaXRoKFwiclwiKSAmJiBwZXJzcGVjdGl2ZVZhbHVlICE9PSBcInJhd1wiKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgQVBJIHBlcnNwZWN0aXZlIHZhbHVlLCBleHBlY3RlZCBgcHVibGlzaGVkYCwgYGRyYWZ0c2Agb3IgYSB2YWxpZCByZWxlYXNlIGlkZW50aWZpZXIgc3RyaW5nXCJcbiAgICAgICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgc3dpdGNoIChwZXJzcGVjdGl2ZSkge1xuICAgIGNhc2UgXCJwcmV2aWV3RHJhZnRzXCI6XG4gICAgY2FzZSBcImRyYWZ0c1wiOlxuICAgIGNhc2UgXCJwdWJsaXNoZWRcIjpcbiAgICBjYXNlIFwicmF3XCI6XG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBBUEkgcGVyc3BlY3RpdmUgc3RyaW5nLCBleHBlY3RlZCBgcHVibGlzaGVkYCwgYHByZXZpZXdEcmFmdHNgIG9yIGByYXdgXCJcbiAgICAgICk7XG4gIH1cbn1cbmNvbnN0IGluaXRDb25maWcgPSAoY29uZmlnLCBwcmV2Q29uZmlnKSA9PiB7XG4gIGNvbnN0IHNwZWNpZmllZENvbmZpZyA9IHtcbiAgICAuLi5wcmV2Q29uZmlnLFxuICAgIC4uLmNvbmZpZyxcbiAgICBzdGVnYToge1xuICAgICAgLi4udHlwZW9mIHByZXZDb25maWcuc3RlZ2EgPT0gXCJib29sZWFuXCIgPyB7IGVuYWJsZWQ6IHByZXZDb25maWcuc3RlZ2EgfSA6IHByZXZDb25maWcuc3RlZ2EgfHwgZGVmYXVsdENvbmZpZy5zdGVnYSxcbiAgICAgIC4uLnR5cGVvZiBjb25maWcuc3RlZ2EgPT0gXCJib29sZWFuXCIgPyB7IGVuYWJsZWQ6IGNvbmZpZy5zdGVnYSB9IDogY29uZmlnLnN0ZWdhIHx8IHt9XG4gICAgfVxuICB9O1xuICBzcGVjaWZpZWRDb25maWcuYXBpVmVyc2lvbiB8fCBwcmludE5vQXBpVmVyc2lvblNwZWNpZmllZFdhcm5pbmcoKTtcbiAgY29uc3QgbmV3Q29uZmlnID0ge1xuICAgIC4uLmRlZmF1bHRDb25maWcsXG4gICAgLi4uc3BlY2lmaWVkQ29uZmlnXG4gIH0sIHByb2plY3RCYXNlZCA9IG5ld0NvbmZpZy51c2VQcm9qZWN0SG9zdG5hbWU7XG4gIGlmICh0eXBlb2YgUHJvbWlzZSA+IFwidVwiKSB7XG4gICAgY29uc3QgaGVscFVybCA9IGdlbmVyYXRlSGVscFVybChcImpzLWNsaWVudC1wcm9taXNlLXBvbHlmaWxsXCIpO1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gbmF0aXZlIFByb21pc2UtaW1wbGVtZW50YXRpb24gZm91bmQsIHBvbHlmaWxsIG5lZWRlZCAtIHNlZSAke2hlbHBVcmx9YCk7XG4gIH1cbiAgaWYgKHByb2plY3RCYXNlZCAmJiAhbmV3Q29uZmlnLnByb2plY3RJZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25maWd1cmF0aW9uIG11c3QgY29udGFpbiBgcHJvamVjdElkYFwiKTtcbiAgaWYgKHR5cGVvZiBuZXdDb25maWcucGVyc3BlY3RpdmUgPCBcInVcIiAmJiB2YWxpZGF0ZUFwaVBlcnNwZWN0aXZlKG5ld0NvbmZpZy5wZXJzcGVjdGl2ZSksIFwiZW5jb2RlU291cmNlTWFwXCIgaW4gbmV3Q29uZmlnKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSXQgbG9va3MgbGlrZSB5b3UncmUgdXNpbmcgb3B0aW9ucyBtZWFudCBmb3IgJ0BzYW5pdHkvcHJldmlldy1raXQvY2xpZW50Jy4gJ2VuY29kZVNvdXJjZU1hcCcgaXMgbm90IHN1cHBvcnRlZCBpbiAnQHNhbml0eS9jbGllbnQnLiBEaWQgeW91IG1lYW4gJ3N0ZWdhLmVuYWJsZWQnP1wiXG4gICAgKTtcbiAgaWYgKFwiZW5jb2RlU291cmNlTWFwQXRQYXRoXCIgaW4gbmV3Q29uZmlnKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSXQgbG9va3MgbGlrZSB5b3UncmUgdXNpbmcgb3B0aW9ucyBtZWFudCBmb3IgJ0BzYW5pdHkvcHJldmlldy1raXQvY2xpZW50Jy4gJ2VuY29kZVNvdXJjZU1hcEF0UGF0aCcgaXMgbm90IHN1cHBvcnRlZCBpbiAnQHNhbml0eS9jbGllbnQnLiBEaWQgeW91IG1lYW4gJ3N0ZWdhLmZpbHRlcic/XCJcbiAgICApO1xuICBpZiAodHlwZW9mIG5ld0NvbmZpZy5zdGVnYS5lbmFibGVkICE9IFwiYm9vbGVhblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihgc3RlZ2EuZW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbiwgcmVjZWl2ZWQgJHtuZXdDb25maWcuc3RlZ2EuZW5hYmxlZH1gKTtcbiAgaWYgKG5ld0NvbmZpZy5zdGVnYS5lbmFibGVkICYmIG5ld0NvbmZpZy5zdGVnYS5zdHVkaW9VcmwgPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdGVnYS5zdHVkaW9VcmwgbXVzdCBiZSBkZWZpbmVkIHdoZW4gc3RlZ2EuZW5hYmxlZCBpcyB0cnVlXCIpO1xuICBpZiAobmV3Q29uZmlnLnN0ZWdhLmVuYWJsZWQgJiYgdHlwZW9mIG5ld0NvbmZpZy5zdGVnYS5zdHVkaW9VcmwgIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgbmV3Q29uZmlnLnN0ZWdhLnN0dWRpb1VybCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHN0ZWdhLnN0dWRpb1VybCBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24sIHJlY2VpdmVkICR7bmV3Q29uZmlnLnN0ZWdhLnN0dWRpb1VybH1gXG4gICAgKTtcbiAgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsIGlzTG9jYWxob3N0ID0gaXNCcm93c2VyICYmIGlzTG9jYWwod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgaXNCcm93c2VyICYmIGlzTG9jYWxob3N0ICYmIG5ld0NvbmZpZy50b2tlbiAmJiBuZXdDb25maWcuaWdub3JlQnJvd3NlclRva2VuV2FybmluZyAhPT0gITAgPyBwcmludEJyb3dzZXJUb2tlbldhcm5pbmcoKSA6IHR5cGVvZiBuZXdDb25maWcudXNlQ2RuID4gXCJ1XCIgJiYgcHJpbnRDZG5XYXJuaW5nKCksIHByb2plY3RCYXNlZCAmJiBwcm9qZWN0SWQobmV3Q29uZmlnLnByb2plY3RJZCksIG5ld0NvbmZpZy5kYXRhc2V0ICYmIGRhdGFzZXQobmV3Q29uZmlnLmRhdGFzZXQpLCBcInJlcXVlc3RUYWdQcmVmaXhcIiBpbiBuZXdDb25maWcgJiYgKG5ld0NvbmZpZy5yZXF1ZXN0VGFnUHJlZml4ID0gbmV3Q29uZmlnLnJlcXVlc3RUYWdQcmVmaXggPyByZXF1ZXN0VGFnKG5ld0NvbmZpZy5yZXF1ZXN0VGFnUHJlZml4KS5yZXBsYWNlKC9cXC4rJC8sIFwiXCIpIDogdm9pZCAwKSwgbmV3Q29uZmlnLmFwaVZlcnNpb24gPSBgJHtuZXdDb25maWcuYXBpVmVyc2lvbn1gLnJlcGxhY2UoL152LywgXCJcIiksIG5ld0NvbmZpZy5pc0RlZmF1bHRBcGkgPSBuZXdDb25maWcuYXBpSG9zdCA9PT0gZGVmYXVsdENvbmZpZy5hcGlIb3N0LCBuZXdDb25maWcudXNlQ2RuID09PSAhMCAmJiBuZXdDb25maWcud2l0aENyZWRlbnRpYWxzICYmIHByaW50Q2RuQW5kV2l0aENyZWRlbnRpYWxzV2FybmluZygpLCBuZXdDb25maWcudXNlQ2RuID0gbmV3Q29uZmlnLnVzZUNkbiAhPT0gITEgJiYgIW5ld0NvbmZpZy53aXRoQ3JlZGVudGlhbHMsIHZhbGlkYXRlQXBpVmVyc2lvbihuZXdDb25maWcuYXBpVmVyc2lvbik7XG4gIGNvbnN0IGhvc3RQYXJ0cyA9IG5ld0NvbmZpZy5hcGlIb3N0LnNwbGl0KFwiOi8vXCIsIDIpLCBwcm90b2NvbCA9IGhvc3RQYXJ0c1swXSwgaG9zdCA9IGhvc3RQYXJ0c1sxXSwgY2RuSG9zdCA9IG5ld0NvbmZpZy5pc0RlZmF1bHRBcGkgPyBkZWZhdWx0Q2RuSG9zdCA6IGhvc3Q7XG4gIHJldHVybiBuZXdDb25maWcudXNlUHJvamVjdEhvc3RuYW1lID8gKG5ld0NvbmZpZy51cmwgPSBgJHtwcm90b2NvbH06Ly8ke25ld0NvbmZpZy5wcm9qZWN0SWR9LiR7aG9zdH0vdiR7bmV3Q29uZmlnLmFwaVZlcnNpb259YCwgbmV3Q29uZmlnLmNkblVybCA9IGAke3Byb3RvY29sfTovLyR7bmV3Q29uZmlnLnByb2plY3RJZH0uJHtjZG5Ib3N0fS92JHtuZXdDb25maWcuYXBpVmVyc2lvbn1gKSA6IChuZXdDb25maWcudXJsID0gYCR7bmV3Q29uZmlnLmFwaUhvc3R9L3Yke25ld0NvbmZpZy5hcGlWZXJzaW9ufWAsIG5ld0NvbmZpZy5jZG5VcmwgPSBuZXdDb25maWcudXJsKSwgbmV3Q29uZmlnO1xufTtcbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihzZWwpIHtcbiAgaWYgKHR5cGVvZiBzZWwgPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4geyBpZDogc2VsIH07XG4gIGlmIChBcnJheS5pc0FycmF5KHNlbCkpXG4gICAgcmV0dXJuIHsgcXVlcnk6IFwiKltfaWQgaW4gJGlkc11cIiwgcGFyYW1zOiB7IGlkczogc2VsIH0gfTtcbiAgaWYgKHR5cGVvZiBzZWwgPT0gXCJvYmplY3RcIiAmJiBzZWwgIT09IG51bGwgJiYgXCJxdWVyeVwiIGluIHNlbCAmJiB0eXBlb2Ygc2VsLnF1ZXJ5ID09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIFwicGFyYW1zXCIgaW4gc2VsICYmIHR5cGVvZiBzZWwucGFyYW1zID09IFwib2JqZWN0XCIgJiYgc2VsLnBhcmFtcyAhPT0gbnVsbCA/IHsgcXVlcnk6IHNlbC5xdWVyeSwgcGFyYW1zOiBzZWwucGFyYW1zIH0gOiB7IHF1ZXJ5OiBzZWwucXVlcnkgfTtcbiAgY29uc3Qgc2VsZWN0aW9uT3B0cyA9IFtcbiAgICBcIiogRG9jdW1lbnQgSUQgKDxkb2NJZD4pXCIsXG4gICAgXCIqIEFycmF5IG9mIGRvY3VtZW50IElEc1wiLFxuICAgIFwiKiBPYmplY3QgY29udGFpbmluZyBgcXVlcnlgXCJcbiAgXS5qb2luKGBcbmApO1xuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc2VsZWN0aW9uIC0gbXVzdCBiZSBvbmUgb2Y6XG5cbiR7c2VsZWN0aW9uT3B0c31gKTtcbn1cbmNsYXNzIEJhc2VQYXRjaCB7XG4gIHNlbGVjdGlvbjtcbiAgb3BlcmF0aW9ucztcbiAgY29uc3RydWN0b3Ioc2VsZWN0aW9uLCBvcGVyYXRpb25zID0ge30pIHtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbiwgdGhpcy5vcGVyYXRpb25zID0gb3BlcmF0aW9ucztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyB0byB0aGUgZG9jdW1lbnQuIERvZXMgTk9UIG1lcmdlIG9iamVjdHMuXG4gICAqIFRoZSBvcGVyYXRpb24gaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnQgcGF0Y2gsIHJlYWR5IHRvIGJlIGNvbW1pdGVkIGJ5IGBjb21taXQoKWBcbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIC0gQXR0cmlidXRlcyB0byBzZXQuIFRvIHNldCBhIGRlZXAgYXR0cmlidXRlLCB1c2UgSlNPTk1hdGNoLCBlZzogXFx7XCJuZXN0ZWQucHJvcFwiOiBcInZhbHVlXCJcXH1cbiAgICovXG4gIHNldChhdHRycykge1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24oXCJzZXRcIiwgYXR0cnMpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIHRvIHRoZSBkb2N1bWVudCBpZiB0aGV5IGFyZSBub3QgY3VycmVudGx5IHNldC4gRG9lcyBOT1QgbWVyZ2Ugb2JqZWN0cy5cbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCBwYXRjaCwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgLSBBdHRyaWJ1dGVzIHRvIHNldC4gVG8gc2V0IGEgZGVlcCBhdHRyaWJ1dGUsIHVzZSBKU09OTWF0Y2gsIGVnOiBcXHtcIm5lc3RlZC5wcm9wXCI6IFwidmFsdWVcIlxcfVxuICAgKi9cbiAgc2V0SWZNaXNzaW5nKGF0dHJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihcInNldElmTWlzc2luZ1wiLCBhdHRycyk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgXCJkaWZmLW1hdGNoLXBhdGNoXCIgb3BlcmF0aW9uIG9uIHRoZSBzdHJpbmcgYXR0cmlidXRlcyBwcm92aWRlZC5cbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCBwYXRjaCwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgLSBBdHRyaWJ1dGVzIHRvIHBlcmZvcm0gb3BlcmF0aW9uIG9uLiBUbyBzZXQgYSBkZWVwIGF0dHJpYnV0ZSwgdXNlIEpTT05NYXRjaCwgZWc6IFxce1wibmVzdGVkLnByb3BcIjogXCJkbXBcIlxcfVxuICAgKi9cbiAgZGlmZk1hdGNoUGF0Y2goYXR0cnMpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoXCJkaWZmTWF0Y2hQYXRjaFwiLCBhdHRycyksIHRoaXMuX2Fzc2lnbihcImRpZmZNYXRjaFBhdGNoXCIsIGF0dHJzKTtcbiAgfVxuICAvKipcbiAgICogVW5zZXRzIHRoZSBhdHRyaWJ1dGUgcGF0aHMgcHJvdmlkZWQuXG4gICAqIFRoZSBvcGVyYXRpb24gaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnQgcGF0Y2gsIHJlYWR5IHRvIGJlIGNvbW1pdGVkIGJ5IGBjb21taXQoKWBcbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIC0gQXR0cmlidXRlIHBhdGhzIHRvIHVuc2V0LlxuICAgKi9cbiAgdW5zZXQoYXR0cnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXR0cnMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zZXQoYXR0cnMpIHRha2VzIGFuIGFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gdW5zZXQsIG5vbi1hcnJheSBnaXZlblwiKTtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcGVyYXRpb25zLCB7IHVuc2V0OiBhdHRycyB9KSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogSW5jcmVtZW50IGEgbnVtZXJpYyB2YWx1ZS4gRWFjaCBlbnRyeSBpbiB0aGUgYXJndW1lbnQgaXMgZWl0aGVyIGFuIGF0dHJpYnV0ZSBvciBhIEpTT04gcGF0aC4gVGhlIHZhbHVlIG1heSBiZSBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuIFRoZSBvcGVyYXRpb24gd2lsbCBmYWlsIGlmIHRhcmdldCB2YWx1ZSBpcyBub3QgYSBudW1lcmljIHZhbHVlLCBvciBkb2Vzbid0IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgLSBPYmplY3Qgb2YgYXR0cmlidXRlIHBhdGhzIHRvIGluY3JlbWVudCwgdmFsdWVzIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIHRvIGluY3JlbWVudCBieS5cbiAgICovXG4gIGluYyhhdHRycykge1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24oXCJpbmNcIiwgYXR0cnMpO1xuICB9XG4gIC8qKlxuICAgKiBEZWNyZW1lbnQgYSBudW1lcmljIHZhbHVlLiBFYWNoIGVudHJ5IGluIHRoZSBhcmd1bWVudCBpcyBlaXRoZXIgYW4gYXR0cmlidXRlIG9yIGEgSlNPTiBwYXRoLiBUaGUgdmFsdWUgbWF5IGJlIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS4gVGhlIG9wZXJhdGlvbiB3aWxsIGZhaWwgaWYgdGFyZ2V0IHZhbHVlIGlzIG5vdCBhIG51bWVyaWMgdmFsdWUsIG9yIGRvZXNuJ3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyAtIE9iamVjdCBvZiBhdHRyaWJ1dGUgcGF0aHMgdG8gZGVjcmVtZW50LCB2YWx1ZXMgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgdG8gZGVjcmVtZW50IGJ5LlxuICAgKi9cbiAgZGVjKGF0dHJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihcImRlY1wiLCBhdHRycyk7XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIG1ldGhvZHMgZm9yIG1vZGlmeWluZyBhcnJheXMsIGJ5IGluc2VydGluZywgYXBwZW5kaW5nIGFuZCByZXBsYWNpbmcgZWxlbWVudHMgdmlhIGEgSlNPTlBhdGggZXhwcmVzc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIGF0IC0gTG9jYXRpb24gdG8gaW5zZXJ0IGF0LCByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gc2VsZWN0b3IsIG9yICdyZXBsYWNlJyB0aGUgbWF0Y2hlZCBwYXRoXG4gICAqIEBwYXJhbSBzZWxlY3RvciAtIEpTT05QYXRoIGV4cHJlc3Npb24sIGVnIGBjb21tZW50c1stMV1gIG9yIGBibG9ja3NbX2tleT09XCJhYmMxMjNcIl1gXG4gICAqIEBwYXJhbSBpdGVtcyAtIEFycmF5IG9mIGl0ZW1zIHRvIGluc2VydC9yZXBsYWNlXG4gICAqL1xuICBpbnNlcnQoYXQsIHNlbGVjdG9yLCBpdGVtcykge1xuICAgIHJldHVybiB2YWxpZGF0ZUluc2VydChhdCwgc2VsZWN0b3IsIGl0ZW1zKSwgdGhpcy5fYXNzaWduKFwiaW5zZXJ0XCIsIHsgW2F0XTogc2VsZWN0b3IsIGl0ZW1zIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmQgdGhlIGdpdmVuIGl0ZW1zIHRvIHRoZSBhcnJheSBhdCB0aGUgZ2l2ZW4gSlNPTlBhdGhcbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdG9yIC0gQXR0cmlidXRlL3BhdGggdG8gYXBwZW5kIHRvLCBlZyBgY29tbWVudHNgIG9yIGBwZXJzb24uaG9iYmllc2BcbiAgICogQHBhcmFtIGl0ZW1zIC0gQXJyYXkgb2YgaXRlbXMgdG8gYXBwZW5kIHRvIHRoZSBhcnJheVxuICAgKi9cbiAgYXBwZW5kKHNlbGVjdG9yLCBpdGVtcykge1xuICAgIHJldHVybiB0aGlzLmluc2VydChcImFmdGVyXCIsIGAke3NlbGVjdG9yfVstMV1gLCBpdGVtcyk7XG4gIH1cbiAgLyoqXG4gICAqIFByZXBlbmQgdGhlIGdpdmVuIGl0ZW1zIHRvIHRoZSBhcnJheSBhdCB0aGUgZ2l2ZW4gSlNPTlBhdGhcbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdG9yIC0gQXR0cmlidXRlL3BhdGggdG8gcHJlcGVuZCB0bywgZWcgYGNvbW1lbnRzYCBvciBgcGVyc29uLmhvYmJpZXNgXG4gICAqIEBwYXJhbSBpdGVtcyAtIEFycmF5IG9mIGl0ZW1zIHRvIHByZXBlbmQgdG8gdGhlIGFycmF5XG4gICAqL1xuICBwcmVwZW5kKHNlbGVjdG9yLCBpdGVtcykge1xuICAgIHJldHVybiB0aGlzLmluc2VydChcImJlZm9yZVwiLCBgJHtzZWxlY3Rvcn1bMF1gLCBpdGVtcyk7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgY29udGVudHMgb2YgYW4gYXJyYXkgYnkgcmVtb3ZpbmcgZXhpc3RpbmcgZWxlbWVudHMgYW5kL29yIGFkZGluZyBuZXcgZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3RvciAtIEF0dHJpYnV0ZSBvciBKU09OUGF0aCBleHByZXNzaW9uIGZvciBhcnJheVxuICAgKiBAcGFyYW0gc3RhcnQgLSBJbmRleCBhdCB3aGljaCB0byBzdGFydCBjaGFuZ2luZyB0aGUgYXJyYXkgKHdpdGggb3JpZ2luIDApLiBJZiBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXksIGFjdHVhbCBzdGFydGluZyBpbmRleCB3aWxsIGJlIHNldCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS4gSWYgbmVnYXRpdmUsIHdpbGwgYmVnaW4gdGhhdCBtYW55IGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkgKHdpdGggb3JpZ2luIC0xKSBhbmQgd2lsbCBiZSBzZXQgdG8gMCBpZiBhYnNvbHV0ZSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkueFxuICAgKiBAcGFyYW0gZGVsZXRlQ291bnQgLSBBbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG51bWJlciBvZiBvbGQgYXJyYXkgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0gaXRlbXMgLSBUaGUgZWxlbWVudHMgdG8gYWRkIHRvIHRoZSBhcnJheSwgYmVnaW5uaW5nIGF0IHRoZSBzdGFydCBpbmRleC4gSWYgeW91IGRvbid0IHNwZWNpZnkgYW55IGVsZW1lbnRzLCBzcGxpY2UoKSB3aWxsIG9ubHkgcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGFycmF5LlxuICAgKi9cbiAgc3BsaWNlKHNlbGVjdG9yLCBzdGFydCwgZGVsZXRlQ291bnQsIGl0ZW1zKSB7XG4gICAgY29uc3QgZGVsQWxsID0gdHlwZW9mIGRlbGV0ZUNvdW50ID4gXCJ1XCIgfHwgZGVsZXRlQ291bnQgPT09IC0xLCBzdGFydEluZGV4ID0gc3RhcnQgPCAwID8gc3RhcnQgLSAxIDogc3RhcnQsIGRlbENvdW50ID0gZGVsQWxsID8gLTEgOiBNYXRoLm1heCgwLCBzdGFydCArIGRlbGV0ZUNvdW50KSwgZGVsUmFuZ2UgPSBzdGFydEluZGV4IDwgMCAmJiBkZWxDb3VudCA+PSAwID8gXCJcIiA6IGRlbENvdW50LCByYW5nZVNlbGVjdG9yID0gYCR7c2VsZWN0b3J9WyR7c3RhcnRJbmRleH06JHtkZWxSYW5nZX1dYDtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoXCJyZXBsYWNlXCIsIHJhbmdlU2VsZWN0b3IsIGl0ZW1zIHx8IFtdKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJldmlzaW9uIGNsYXVzZSwgcHJldmVudGluZyB0aGUgZG9jdW1lbnQgZnJvbSBiZWluZyBwYXRjaGVkIGlmIHRoZSBgX3JldmAgcHJvcGVydHkgZG9lcyBub3QgbWF0Y2ggdGhlIGdpdmVuIHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSByZXYgLSBSZXZpc2lvbiB0byBsb2NrIHRoZSBwYXRjaCB0b1xuICAgKi9cbiAgaWZSZXZpc2lvbklkKHJldikge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnMuaWZSZXZpc2lvbklEID0gcmV2LCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwbGFpbiBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXRjaFxuICAgKi9cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiB7IC4uLmdldFNlbGVjdGlvbih0aGlzLnNlbGVjdGlvbiksIC4uLnRoaXMub3BlcmF0aW9ucyB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwbGFpbiBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXRjaFxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIHBhdGNoIG9mIGFsbCBvcGVyYXRpb25zXG4gICAqL1xuICByZXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zID0ge30sIHRoaXM7XG4gIH1cbiAgX2Fzc2lnbihvcCwgcHJvcHMsIG1lcmdlID0gITApIHtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qob3AsIHByb3BzKSwgdGhpcy5vcGVyYXRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcGVyYXRpb25zLCB7XG4gICAgICBbb3BdOiBPYmplY3QuYXNzaWduKHt9LCBtZXJnZSAmJiB0aGlzLm9wZXJhdGlvbnNbb3BdIHx8IHt9LCBwcm9wcylcbiAgICB9KSwgdGhpcztcbiAgfVxuICBfc2V0KG9wLCBwcm9wcykge1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24ob3AsIHByb3BzLCAhMSk7XG4gIH1cbn1cbmNsYXNzIE9ic2VydmFibGVQYXRjaCBleHRlbmRzIEJhc2VQYXRjaCB7XG4gICNjbGllbnQ7XG4gIGNvbnN0cnVjdG9yKHNlbGVjdGlvbiwgb3BlcmF0aW9ucywgY2xpZW50KSB7XG4gICAgc3VwZXIoc2VsZWN0aW9uLCBvcGVyYXRpb25zKSwgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHBhdGNoXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVQYXRjaCh0aGlzLnNlbGVjdGlvbiwgeyAuLi50aGlzLm9wZXJhdGlvbnMgfSwgdGhpcy4jY2xpZW50KTtcbiAgfVxuICBjb21taXQob3B0aW9ucykge1xuICAgIGlmICghdGhpcy4jY2xpZW50KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIk5vIGBjbGllbnRgIHBhc3NlZCB0byBwYXRjaCwgZWl0aGVyIHByb3ZpZGUgb25lIG9yIHBhc3MgdGhlIHBhdGNoIHRvIGEgY2xpZW50cyBgbXV0YXRlKClgIG1ldGhvZFwiXG4gICAgICApO1xuICAgIGNvbnN0IHJldHVybkZpcnN0ID0gdHlwZW9mIHRoaXMuc2VsZWN0aW9uID09IFwic3RyaW5nXCIsIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgcmV0dXJuRmlyc3QsIHJldHVybkRvY3VtZW50czogITAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuI2NsaWVudC5tdXRhdGUoeyBwYXRjaDogdGhpcy5zZXJpYWxpemUoKSB9LCBvcHRzKTtcbiAgfVxufVxuY2xhc3MgUGF0Y2ggZXh0ZW5kcyBCYXNlUGF0Y2gge1xuICAjY2xpZW50O1xuICBjb25zdHJ1Y3RvcihzZWxlY3Rpb24sIG9wZXJhdGlvbnMsIGNsaWVudCkge1xuICAgIHN1cGVyKHNlbGVjdGlvbiwgb3BlcmF0aW9ucyksIHRoaXMuI2NsaWVudCA9IGNsaWVudDtcbiAgfVxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBwYXRjaFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBQYXRjaCh0aGlzLnNlbGVjdGlvbiwgeyAuLi50aGlzLm9wZXJhdGlvbnMgfSwgdGhpcy4jY2xpZW50KTtcbiAgfVxuICBjb21taXQob3B0aW9ucykge1xuICAgIGlmICghdGhpcy4jY2xpZW50KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIk5vIGBjbGllbnRgIHBhc3NlZCB0byBwYXRjaCwgZWl0aGVyIHByb3ZpZGUgb25lIG9yIHBhc3MgdGhlIHBhdGNoIHRvIGEgY2xpZW50cyBgbXV0YXRlKClgIG1ldGhvZFwiXG4gICAgICApO1xuICAgIGNvbnN0IHJldHVybkZpcnN0ID0gdHlwZW9mIHRoaXMuc2VsZWN0aW9uID09IFwic3RyaW5nXCIsIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgcmV0dXJuRmlyc3QsIHJldHVybkRvY3VtZW50czogITAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuI2NsaWVudC5tdXRhdGUoeyBwYXRjaDogdGhpcy5zZXJpYWxpemUoKSB9LCBvcHRzKTtcbiAgfVxufVxuY29uc3QgZGVmYXVsdE11dGF0ZU9wdGlvbnMgPSB7IHJldHVybkRvY3VtZW50czogITEgfTtcbmNsYXNzIEJhc2VUcmFuc2FjdGlvbiB7XG4gIG9wZXJhdGlvbnM7XG4gIHRyeElkO1xuICBjb25zdHJ1Y3RvcihvcGVyYXRpb25zID0gW10sIHRyYW5zYWN0aW9uSWQpIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMgPSBvcGVyYXRpb25zLCB0aGlzLnRyeElkID0gdHJhbnNhY3Rpb25JZDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTYW5pdHkgZG9jdW1lbnQuIElmIGBfaWRgIGlzIHByb3ZpZGVkIGFuZCBhbHJlYWR5IGV4aXN0cywgdGhlIG11dGF0aW9uIHdpbGwgZmFpbC4gSWYgbm8gYF9pZGAgaXMgZ2l2ZW4sIG9uZSB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZ2VuZXJhdGVkIGJ5IHRoZSBkYXRhYmFzZS5cbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gZG9jIC0gRG9jdW1lbnQgdG8gY3JlYXRlLiBSZXF1aXJlcyBhIGBfdHlwZWAgcHJvcGVydHkuXG4gICAqL1xuICBjcmVhdGUoZG9jKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KFwiY3JlYXRlXCIsIGRvYyksIHRoaXMuX2FkZCh7IGNyZWF0ZTogZG9jIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNhbml0eSBkb2N1bWVudC4gSWYgYSBkb2N1bWVudCB3aXRoIHRoZSBzYW1lIGBfaWRgIGFscmVhZHkgZXhpc3RzLCB0aGUgY3JlYXRlIG9wZXJhdGlvbiB3aWxsIGJlIGlnbm9yZWQuXG4gICAqIFRoZSBvcGVyYXRpb24gaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24sIHJlYWR5IHRvIGJlIGNvbW1pdGVkIGJ5IGBjb21taXQoKWBcbiAgICpcbiAgICogQHBhcmFtIGRvYyAtIERvY3VtZW50IHRvIGNyZWF0ZSBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LiBSZXF1aXJlcyBgX2lkYCBhbmQgYF90eXBlYCBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgY3JlYXRlSWZOb3RFeGlzdHMoZG9jKSB7XG4gICAgY29uc3Qgb3AgPSBcImNyZWF0ZUlmTm90RXhpc3RzXCI7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KG9wLCBkb2MpLCByZXF1aXJlRG9jdW1lbnRJZChvcCwgZG9jKSwgdGhpcy5fYWRkKHsgW29wXTogZG9jIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNhbml0eSBkb2N1bWVudCwgb3IgcmVwbGFjZXMgYW4gZXhpc3Rpbmcgb25lIGlmIHRoZSBzYW1lIGBfaWRgIGlzIGFscmVhZHkgdXNlZC5cbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gZG9jIC0gRG9jdW1lbnQgdG8gY3JlYXRlIG9yIHJlcGxhY2UuIFJlcXVpcmVzIGBfaWRgIGFuZCBgX3R5cGVgIHByb3BlcnRpZXMuXG4gICAqL1xuICBjcmVhdGVPclJlcGxhY2UoZG9jKSB7XG4gICAgY29uc3Qgb3AgPSBcImNyZWF0ZU9yUmVwbGFjZVwiO1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChvcCwgZG9jKSwgcmVxdWlyZURvY3VtZW50SWQob3AsIGRvYyksIHRoaXMuX2FkZCh7IFtvcF06IGRvYyB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gZG9jdW1lbnQgSURcbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gZG9jdW1lbnRJZCAtIERvY3VtZW50IElEIHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKGRvY3VtZW50SWQpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVEb2N1bWVudElkKFwiZGVsZXRlXCIsIGRvY3VtZW50SWQpLCB0aGlzLl9hZGQoeyBkZWxldGU6IHsgaWQ6IGRvY3VtZW50SWQgfSB9KTtcbiAgfVxuICB0cmFuc2FjdGlvbklkKGlkKSB7XG4gICAgcmV0dXJuIGlkID8gKHRoaXMudHJ4SWQgPSBpZCwgdGhpcykgOiB0aGlzLnRyeElkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwbGFpbiBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5vcGVyYXRpb25zXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgcGxhaW4gSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHRoZSB0cmFuc2FjdGlvbiBvZiBhbGwgb3BlcmF0aW9uc1xuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3BlcmF0aW9ucyA9IFtdLCB0aGlzO1xuICB9XG4gIF9hZGQobXV0KSB7XG4gICAgcmV0dXJuIHRoaXMub3BlcmF0aW9ucy5wdXNoKG11dCksIHRoaXM7XG4gIH1cbn1cbmNsYXNzIFRyYW5zYWN0aW9uIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uIHtcbiAgI2NsaWVudDtcbiAgY29uc3RydWN0b3Iob3BlcmF0aW9ucywgY2xpZW50LCB0cmFuc2FjdGlvbklkKSB7XG4gICAgc3VwZXIob3BlcmF0aW9ucywgdHJhbnNhY3Rpb25JZCksIHRoaXMuI2NsaWVudCA9IGNsaWVudDtcbiAgfVxuICAvKipcbiAgICogQ2xvbmVzIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbihbLi4udGhpcy5vcGVyYXRpb25zXSwgdGhpcy4jY2xpZW50LCB0aGlzLnRyeElkKTtcbiAgfVxuICBjb21taXQob3B0aW9ucykge1xuICAgIGlmICghdGhpcy4jY2xpZW50KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIk5vIGBjbGllbnRgIHBhc3NlZCB0byB0cmFuc2FjdGlvbiwgZWl0aGVyIHByb3ZpZGUgb25lIG9yIHBhc3MgdGhlIHRyYW5zYWN0aW9uIHRvIGEgY2xpZW50cyBgbXV0YXRlKClgIG1ldGhvZFwiXG4gICAgICApO1xuICAgIHJldHVybiB0aGlzLiNjbGllbnQubXV0YXRlKFxuICAgICAgdGhpcy5zZXJpYWxpemUoKSxcbiAgICAgIE9iamVjdC5hc3NpZ24oeyB0cmFuc2FjdGlvbklkOiB0aGlzLnRyeElkIH0sIGRlZmF1bHRNdXRhdGVPcHRpb25zLCBvcHRpb25zIHx8IHt9KVxuICAgICk7XG4gIH1cbiAgcGF0Y2gocGF0Y2hPckRvY3VtZW50SWQsIHBhdGNoT3BzKSB7XG4gICAgY29uc3QgaXNCdWlsZGVyID0gdHlwZW9mIHBhdGNoT3BzID09IFwiZnVuY3Rpb25cIjtcbiAgICBpZiAodHlwZW9mIHBhdGNoT3JEb2N1bWVudElkICE9IFwic3RyaW5nXCIgJiYgcGF0Y2hPckRvY3VtZW50SWQgaW5zdGFuY2VvZiBQYXRjaClcbiAgICAgIHJldHVybiB0aGlzLl9hZGQoeyBwYXRjaDogcGF0Y2hPckRvY3VtZW50SWQuc2VyaWFsaXplKCkgfSk7XG4gICAgaWYgKGlzQnVpbGRlcikge1xuICAgICAgY29uc3QgcGF0Y2ggPSBwYXRjaE9wcyhuZXcgUGF0Y2gocGF0Y2hPckRvY3VtZW50SWQsIHt9LCB0aGlzLiNjbGllbnQpKTtcbiAgICAgIGlmICghKHBhdGNoIGluc3RhbmNlb2YgUGF0Y2gpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmdW5jdGlvbiBwYXNzZWQgdG8gYHBhdGNoKClgIG11c3QgcmV0dXJuIHRoZSBwYXRjaFwiKTtcbiAgICAgIHJldHVybiB0aGlzLl9hZGQoeyBwYXRjaDogcGF0Y2guc2VyaWFsaXplKCkgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hZGQoeyBwYXRjaDogeyBpZDogcGF0Y2hPckRvY3VtZW50SWQsIC4uLnBhdGNoT3BzIH0gfSk7XG4gIH1cbn1cbmNsYXNzIE9ic2VydmFibGVUcmFuc2FjdGlvbiBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbiB7XG4gICNjbGllbnQ7XG4gIGNvbnN0cnVjdG9yKG9wZXJhdGlvbnMsIGNsaWVudCwgdHJhbnNhY3Rpb25JZCkge1xuICAgIHN1cGVyKG9wZXJhdGlvbnMsIHRyYW5zYWN0aW9uSWQpLCB0aGlzLiNjbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVRyYW5zYWN0aW9uKFsuLi50aGlzLm9wZXJhdGlvbnNdLCB0aGlzLiNjbGllbnQsIHRoaXMudHJ4SWQpO1xuICB9XG4gIGNvbW1pdChvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLiNjbGllbnQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiTm8gYGNsaWVudGAgcGFzc2VkIHRvIHRyYW5zYWN0aW9uLCBlaXRoZXIgcHJvdmlkZSBvbmUgb3IgcGFzcyB0aGUgdHJhbnNhY3Rpb24gdG8gYSBjbGllbnRzIGBtdXRhdGUoKWAgbWV0aG9kXCJcbiAgICAgICk7XG4gICAgcmV0dXJuIHRoaXMuI2NsaWVudC5tdXRhdGUoXG4gICAgICB0aGlzLnNlcmlhbGl6ZSgpLFxuICAgICAgT2JqZWN0LmFzc2lnbih7IHRyYW5zYWN0aW9uSWQ6IHRoaXMudHJ4SWQgfSwgZGVmYXVsdE11dGF0ZU9wdGlvbnMsIG9wdGlvbnMgfHwge30pXG4gICAgKTtcbiAgfVxuICBwYXRjaChwYXRjaE9yRG9jdW1lbnRJZCwgcGF0Y2hPcHMpIHtcbiAgICBjb25zdCBpc0J1aWxkZXIgPSB0eXBlb2YgcGF0Y2hPcHMgPT0gXCJmdW5jdGlvblwiO1xuICAgIGlmICh0eXBlb2YgcGF0Y2hPckRvY3VtZW50SWQgIT0gXCJzdHJpbmdcIiAmJiBwYXRjaE9yRG9jdW1lbnRJZCBpbnN0YW5jZW9mIE9ic2VydmFibGVQYXRjaClcbiAgICAgIHJldHVybiB0aGlzLl9hZGQoeyBwYXRjaDogcGF0Y2hPckRvY3VtZW50SWQuc2VyaWFsaXplKCkgfSk7XG4gICAgaWYgKGlzQnVpbGRlcikge1xuICAgICAgY29uc3QgcGF0Y2ggPSBwYXRjaE9wcyhuZXcgT2JzZXJ2YWJsZVBhdGNoKHBhdGNoT3JEb2N1bWVudElkLCB7fSwgdGhpcy4jY2xpZW50KSk7XG4gICAgICBpZiAoIShwYXRjaCBpbnN0YW5jZW9mIE9ic2VydmFibGVQYXRjaCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZ1bmN0aW9uIHBhc3NlZCB0byBgcGF0Y2goKWAgbXVzdCByZXR1cm4gdGhlIHBhdGNoXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZCh7IHBhdGNoOiBwYXRjaC5zZXJpYWxpemUoKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FkZCh7IHBhdGNoOiB7IGlkOiBwYXRjaE9yRG9jdW1lbnRJZCwgLi4ucGF0Y2hPcHMgfSB9KTtcbiAgfVxufVxuY29uc3QgcHJvamVjdEhlYWRlciA9IFwiWC1TYW5pdHktUHJvamVjdC1JRFwiO1xuZnVuY3Rpb24gcmVxdWVzdE9wdGlvbnMoY29uZmlnLCBvdmVycmlkZXMgPSB7fSkge1xuICBjb25zdCBoZWFkZXJzMiA9IHt9LCB0b2tlbiA9IG92ZXJyaWRlcy50b2tlbiB8fCBjb25maWcudG9rZW47XG4gIHRva2VuICYmIChoZWFkZXJzMi5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWApLCAhb3ZlcnJpZGVzLnVzZUdsb2JhbEFwaSAmJiAhY29uZmlnLnVzZVByb2plY3RIb3N0bmFtZSAmJiBjb25maWcucHJvamVjdElkICYmIChoZWFkZXJzMltwcm9qZWN0SGVhZGVyXSA9IGNvbmZpZy5wcm9qZWN0SWQpO1xuICBjb25zdCB3aXRoQ3JlZGVudGlhbHMgPSAhISh0eXBlb2Ygb3ZlcnJpZGVzLndpdGhDcmVkZW50aWFscyA+IFwidVwiID8gY29uZmlnLnRva2VuIHx8IGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgOiBvdmVycmlkZXMud2l0aENyZWRlbnRpYWxzKSwgdGltZW91dCA9IHR5cGVvZiBvdmVycmlkZXMudGltZW91dCA+IFwidVwiID8gY29uZmlnLnRpbWVvdXQgOiBvdmVycmlkZXMudGltZW91dDtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlcywge1xuICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIGhlYWRlcnMyLCBvdmVycmlkZXMuaGVhZGVycyB8fCB7fSksXG4gICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPiBcInVcIiA/IDUgKiA2MCAqIDFlMyA6IHRpbWVvdXQsXG4gICAgcHJveHk6IG92ZXJyaWRlcy5wcm94eSB8fCBjb25maWcucHJveHksXG4gICAganNvbjogITAsXG4gICAgd2l0aENyZWRlbnRpYWxzLFxuICAgIGZldGNoOiB0eXBlb2Ygb3ZlcnJpZGVzLmZldGNoID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNvbmZpZy5mZXRjaCA9PSBcIm9iamVjdFwiID8geyAuLi5jb25maWcuZmV0Y2gsIC4uLm92ZXJyaWRlcy5mZXRjaCB9IDogb3ZlcnJpZGVzLmZldGNoIHx8IGNvbmZpZy5mZXRjaFxuICB9KTtcbn1cbmNvbnN0IGVuY29kZVF1ZXJ5U3RyaW5nID0gKHtcbiAgcXVlcnksXG4gIHBhcmFtcyA9IHt9LFxuICBvcHRpb25zID0ge31cbn0pID0+IHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpLCB7IHRhZywgaW5jbHVkZU11dGF0aW9ucywgcmV0dXJuUXVlcnksIC4uLm9wdHMgfSA9IG9wdGlvbnM7XG4gIHRhZyAmJiBzZWFyY2hQYXJhbXMuYXBwZW5kKFwidGFnXCIsIHRhZyksIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJxdWVyeVwiLCBxdWVyeSk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpXG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChgJCR7a2V5fWAsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdHMpKVxuICAgIHZhbHVlICYmIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBgJHt2YWx1ZX1gKTtcbiAgcmV0dXJuIHJldHVyblF1ZXJ5ID09PSAhMSAmJiBzZWFyY2hQYXJhbXMuYXBwZW5kKFwicmV0dXJuUXVlcnlcIiwgXCJmYWxzZVwiKSwgaW5jbHVkZU11dGF0aW9ucyA9PT0gITEgJiYgc2VhcmNoUGFyYW1zLmFwcGVuZChcImluY2x1ZGVNdXRhdGlvbnNcIiwgXCJmYWxzZVwiKSwgYD8ke3NlYXJjaFBhcmFtc31gO1xufSwgZXhjbHVkZUZhbHNleSA9IChwYXJhbSwgZGVmVmFsdWUpID0+IHBhcmFtID09PSAhMSA/IHZvaWQgMCA6IHR5cGVvZiBwYXJhbSA+IFwidVwiID8gZGVmVmFsdWUgOiBwYXJhbSwgZ2V0TXV0YXRpb25RdWVyeSA9IChvcHRpb25zID0ge30pID0+ICh7XG4gIGRyeVJ1bjogb3B0aW9ucy5kcnlSdW4sXG4gIHJldHVybklkczogITAsXG4gIHJldHVybkRvY3VtZW50czogZXhjbHVkZUZhbHNleShvcHRpb25zLnJldHVybkRvY3VtZW50cywgITApLFxuICB2aXNpYmlsaXR5OiBvcHRpb25zLnZpc2liaWxpdHkgfHwgXCJzeW5jXCIsXG4gIGF1dG9HZW5lcmF0ZUFycmF5S2V5czogb3B0aW9ucy5hdXRvR2VuZXJhdGVBcnJheUtleXMsXG4gIHNraXBDcm9zc0RhdGFzZXRSZWZlcmVuY2VWYWxpZGF0aW9uOiBvcHRpb25zLnNraXBDcm9zc0RhdGFzZXRSZWZlcmVuY2VWYWxpZGF0aW9uXG59KSwgaXNSZXNwb25zZSA9IChldmVudCkgPT4gZXZlbnQudHlwZSA9PT0gXCJyZXNwb25zZVwiLCBnZXRCb2R5ID0gKGV2ZW50KSA9PiBldmVudC5ib2R5LCBpbmRleEJ5ID0gKGRvY3MsIGF0dHIpID0+IGRvY3MucmVkdWNlKChpbmRleGVkLCBkb2MpID0+IChpbmRleGVkW2F0dHIoZG9jKV0gPSBkb2MsIGluZGV4ZWQpLCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSksIGdldFF1ZXJ5U2l6ZUxpbWl0ID0gMTEyNjQ7XG5mdW5jdGlvbiBfZmV0Y2goY2xpZW50LCBodHRwUmVxdWVzdCwgX3N0ZWdhLCBxdWVyeSwgX3BhcmFtcyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgc3RlZ2EgPSBcInN0ZWdhXCIgaW4gb3B0aW9ucyA/IHtcbiAgICAuLi5fc3RlZ2EgfHwge30sXG4gICAgLi4udHlwZW9mIG9wdGlvbnMuc3RlZ2EgPT0gXCJib29sZWFuXCIgPyB7IGVuYWJsZWQ6IG9wdGlvbnMuc3RlZ2EgfSA6IG9wdGlvbnMuc3RlZ2EgfHwge31cbiAgfSA6IF9zdGVnYSwgcGFyYW1zID0gc3RlZ2EuZW5hYmxlZCA/IHN0ZWdhQ2xlYW4oX3BhcmFtcykgOiBfcGFyYW1zLCBtYXBSZXNwb25zZSA9IG9wdGlvbnMuZmlsdGVyUmVzcG9uc2UgPT09ICExID8gKHJlcykgPT4gcmVzIDogKHJlcykgPT4gcmVzLnJlc3VsdCwgeyBjYWNoZSwgbmV4dCwgLi4ub3B0cyB9ID0ge1xuICAgIC8vIE9wdCBvdXQgb2Ygc2V0dGluZyBhIGBzaWduYWxgIG9uIGFuIGludGVybmFsIGBmZXRjaGAgaWYgb25lIGlzbid0IHByb3ZpZGVkLlxuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGluIFJlYWN0IFNlcnZlciBDb21wb25lbnRzIHRvIGF2b2lkIG9wdGluZyBvdXQgb2YgUmVxdWVzdCBNZW1vaXphdGlvbi5cbiAgICB1c2VBYm9ydFNpZ25hbDogdHlwZW9mIG9wdGlvbnMuc2lnbmFsIDwgXCJ1XCIsXG4gICAgLy8gU2V0IGByZXN1bHRTb3VyY2VNYXAnIHdoZW4gc3RlZ2EgaXMgZW5hYmxlZCwgYXMgaXQncyByZXF1aXJlZCBmb3IgZW5jb2RpbmcuXG4gICAgcmVzdWx0U291cmNlTWFwOiBzdGVnYS5lbmFibGVkID8gXCJ3aXRoS2V5QXJyYXlTZWxlY3RvclwiIDogb3B0aW9ucy5yZXN1bHRTb3VyY2VNYXAsXG4gICAgLi4ub3B0aW9ucyxcbiAgICAvLyBEZWZhdWx0IHRvIG5vdCByZXR1cm5pbmcgdGhlIHF1ZXJ5LCB1bmxlc3MgYGZpbHRlclJlc3BvbnNlYCBpcyBgZmFsc2VgLFxuICAgIC8vIG9yIGByZXR1cm5RdWVyeWAgaXMgZXhwbGljaXRseSBzZXQuIGB0cnVlYCBpcyB0aGUgZGVmYXVsdCBpbiBDb250ZW50IExha2UsIHNvIHNraXAgaWYgdHJ1dGh5XG4gICAgcmV0dXJuUXVlcnk6IG9wdGlvbnMuZmlsdGVyUmVzcG9uc2UgPT09ICExICYmIG9wdGlvbnMucmV0dXJuUXVlcnkgIT09ICExXG4gIH0sIHJlcU9wdHMgPSB0eXBlb2YgY2FjaGUgPCBcInVcIiB8fCB0eXBlb2YgbmV4dCA8IFwidVwiID8geyAuLi5vcHRzLCBmZXRjaDogeyBjYWNoZSwgbmV4dCB9IH0gOiBvcHRzLCAkcmVxdWVzdCA9IF9kYXRhUmVxdWVzdChjbGllbnQsIGh0dHBSZXF1ZXN0LCBcInF1ZXJ5XCIsIHsgcXVlcnksIHBhcmFtcyB9LCByZXFPcHRzKTtcbiAgcmV0dXJuIHN0ZWdhLmVuYWJsZWQgPyAkcmVxdWVzdC5waXBlKFxuICAgIGNvbWJpbmVMYXRlc3RXaXRoKFxuICAgICAgZnJvbShcbiAgICAgICAgaW1wb3J0KFwiLi9fY2h1bmtzLWVzL3N0ZWdhRW5jb2RlU291cmNlTWFwLmpzXCIpLnRoZW4oZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBuLnN0ZWdhRW5jb2RlU291cmNlTWFwJDE7XG4gICAgICAgIH0pLnRoZW4oXG4gICAgICAgICAgKHsgc3RlZ2FFbmNvZGVTb3VyY2VNYXAgfSkgPT4gc3RlZ2FFbmNvZGVTb3VyY2VNYXBcbiAgICAgICAgKVxuICAgICAgKVxuICAgICksXG4gICAgbWFwKFxuICAgICAgKFtyZXMsIHN0ZWdhRW5jb2RlU291cmNlTWFwXSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdGVnYUVuY29kZVNvdXJjZU1hcChyZXMucmVzdWx0LCByZXMucmVzdWx0U291cmNlTWFwLCBzdGVnYSk7XG4gICAgICAgIHJldHVybiBtYXBSZXNwb25zZSh7IC4uLnJlcywgcmVzdWx0IH0pO1xuICAgICAgfVxuICAgIClcbiAgKSA6ICRyZXF1ZXN0LnBpcGUobWFwKG1hcFJlc3BvbnNlKSk7XG59XG5mdW5jdGlvbiBfZ2V0RG9jdW1lbnQoY2xpZW50LCBodHRwUmVxdWVzdCwgaWQsIG9wdHMgPSB7fSkge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIHVyaTogX2dldERhdGFVcmwoY2xpZW50LCBcImRvY1wiLCBpZCksXG4gICAganNvbjogITAsXG4gICAgdGFnOiBvcHRzLnRhZyxcbiAgICBzaWduYWw6IG9wdHMuc2lnbmFsXG4gIH07XG4gIHJldHVybiBfcmVxdWVzdE9ic2VydmFibGUoY2xpZW50LCBodHRwUmVxdWVzdCwgb3B0aW9ucykucGlwZShcbiAgICBmaWx0ZXIoaXNSZXNwb25zZSksXG4gICAgbWFwKChldmVudCkgPT4gZXZlbnQuYm9keS5kb2N1bWVudHMgJiYgZXZlbnQuYm9keS5kb2N1bWVudHNbMF0pXG4gICk7XG59XG5mdW5jdGlvbiBfZ2V0RG9jdW1lbnRzKGNsaWVudCwgaHR0cFJlcXVlc3QsIGlkcywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgdXJpOiBfZ2V0RGF0YVVybChjbGllbnQsIFwiZG9jXCIsIGlkcy5qb2luKFwiLFwiKSksXG4gICAganNvbjogITAsXG4gICAgdGFnOiBvcHRzLnRhZyxcbiAgICBzaWduYWw6IG9wdHMuc2lnbmFsXG4gIH07XG4gIHJldHVybiBfcmVxdWVzdE9ic2VydmFibGUoY2xpZW50LCBodHRwUmVxdWVzdCwgb3B0aW9ucykucGlwZShcbiAgICBmaWx0ZXIoaXNSZXNwb25zZSksXG4gICAgbWFwKChldmVudCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXhlZCA9IGluZGV4QnkoZXZlbnQuYm9keS5kb2N1bWVudHMgfHwgW10sIChkb2MpID0+IGRvYy5faWQpO1xuICAgICAgcmV0dXJuIGlkcy5tYXAoKGlkKSA9PiBpbmRleGVkW2lkXSB8fCBudWxsKTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUlmTm90RXhpc3RzKGNsaWVudCwgaHR0cFJlcXVlc3QsIGRvYywgb3B0aW9ucykge1xuICByZXR1cm4gcmVxdWlyZURvY3VtZW50SWQoXCJjcmVhdGVJZk5vdEV4aXN0c1wiLCBkb2MpLCBfY3JlYXRlKGNsaWVudCwgaHR0cFJlcXVlc3QsIGRvYywgXCJjcmVhdGVJZk5vdEV4aXN0c1wiLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVPclJlcGxhY2UoY2xpZW50LCBodHRwUmVxdWVzdCwgZG9jLCBvcHRpb25zKSB7XG4gIHJldHVybiByZXF1aXJlRG9jdW1lbnRJZChcImNyZWF0ZU9yUmVwbGFjZVwiLCBkb2MpLCBfY3JlYXRlKGNsaWVudCwgaHR0cFJlcXVlc3QsIGRvYywgXCJjcmVhdGVPclJlcGxhY2VcIiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBfZGVsZXRlKGNsaWVudCwgaHR0cFJlcXVlc3QsIHNlbGVjdGlvbiwgb3B0aW9ucykge1xuICByZXR1cm4gX2RhdGFSZXF1ZXN0KFxuICAgIGNsaWVudCxcbiAgICBodHRwUmVxdWVzdCxcbiAgICBcIm11dGF0ZVwiLFxuICAgIHsgbXV0YXRpb25zOiBbeyBkZWxldGU6IGdldFNlbGVjdGlvbihzZWxlY3Rpb24pIH1dIH0sXG4gICAgb3B0aW9uc1xuICApO1xufVxuZnVuY3Rpb24gX211dGF0ZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBtdXRhdGlvbnMsIG9wdGlvbnMpIHtcbiAgbGV0IG11dDtcbiAgbXV0YXRpb25zIGluc3RhbmNlb2YgUGF0Y2ggfHwgbXV0YXRpb25zIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVBhdGNoID8gbXV0ID0geyBwYXRjaDogbXV0YXRpb25zLnNlcmlhbGl6ZSgpIH0gOiBtdXRhdGlvbnMgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbiB8fCBtdXRhdGlvbnMgaW5zdGFuY2VvZiBPYnNlcnZhYmxlVHJhbnNhY3Rpb24gPyBtdXQgPSBtdXRhdGlvbnMuc2VyaWFsaXplKCkgOiBtdXQgPSBtdXRhdGlvbnM7XG4gIGNvbnN0IG11dHMgPSBBcnJheS5pc0FycmF5KG11dCkgPyBtdXQgOiBbbXV0XSwgdHJhbnNhY3Rpb25JZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50cmFuc2FjdGlvbklkIHx8IHZvaWQgMDtcbiAgcmV0dXJuIF9kYXRhUmVxdWVzdChjbGllbnQsIGh0dHBSZXF1ZXN0LCBcIm11dGF0ZVwiLCB7IG11dGF0aW9uczogbXV0cywgdHJhbnNhY3Rpb25JZCB9LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIF9hY3Rpb24oY2xpZW50LCBodHRwUmVxdWVzdCwgYWN0aW9ucywgb3B0aW9ucykge1xuICBjb25zdCBhY3RzID0gQXJyYXkuaXNBcnJheShhY3Rpb25zKSA/IGFjdGlvbnMgOiBbYWN0aW9uc10sIHRyYW5zYWN0aW9uSWQgPSBvcHRpb25zICYmIG9wdGlvbnMudHJhbnNhY3Rpb25JZCB8fCB2b2lkIDAsIHNraXBDcm9zc0RhdGFzZXRSZWZlcmVuY2VWYWxpZGF0aW9uID0gb3B0aW9ucyAmJiBvcHRpb25zLnNraXBDcm9zc0RhdGFzZXRSZWZlcmVuY2VWYWxpZGF0aW9uIHx8IHZvaWQgMCwgZHJ5UnVuID0gb3B0aW9ucyAmJiBvcHRpb25zLmRyeVJ1biB8fCB2b2lkIDA7XG4gIHJldHVybiBfZGF0YVJlcXVlc3QoXG4gICAgY2xpZW50LFxuICAgIGh0dHBSZXF1ZXN0LFxuICAgIFwiYWN0aW9uc1wiLFxuICAgIHsgYWN0aW9uczogYWN0cywgdHJhbnNhY3Rpb25JZCwgc2tpcENyb3NzRGF0YXNldFJlZmVyZW5jZVZhbGlkYXRpb24sIGRyeVJ1biB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbmZ1bmN0aW9uIF9kYXRhUmVxdWVzdChjbGllbnQsIGh0dHBSZXF1ZXN0LCBlbmRwb2ludCwgYm9keSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGlzTXV0YXRpb24gPSBlbmRwb2ludCA9PT0gXCJtdXRhdGVcIiwgaXNBY3Rpb24gPSBlbmRwb2ludCA9PT0gXCJhY3Rpb25zXCIsIGlzUXVlcnkgPSBlbmRwb2ludCA9PT0gXCJxdWVyeVwiLCBzdHJRdWVyeSA9IGlzTXV0YXRpb24gfHwgaXNBY3Rpb24gPyBcIlwiIDogZW5jb2RlUXVlcnlTdHJpbmcoYm9keSksIHVzZUdldCA9ICFpc011dGF0aW9uICYmICFpc0FjdGlvbiAmJiBzdHJRdWVyeS5sZW5ndGggPCBnZXRRdWVyeVNpemVMaW1pdCwgc3RyaW5nUXVlcnkgPSB1c2VHZXQgPyBzdHJRdWVyeSA6IFwiXCIsIHJldHVybkZpcnN0ID0gb3B0aW9ucy5yZXR1cm5GaXJzdCwgeyB0aW1lb3V0LCB0b2tlbiwgdGFnLCBoZWFkZXJzOiBoZWFkZXJzMiwgcmV0dXJuUXVlcnksIGxhc3RMaXZlRXZlbnRJZCwgY2FjaGVNb2RlIH0gPSBvcHRpb25zLCB1cmkgPSBfZ2V0RGF0YVVybChjbGllbnQsIGVuZHBvaW50LCBzdHJpbmdRdWVyeSksIHJlcU9wdGlvbnMgPSB7XG4gICAgbWV0aG9kOiB1c2VHZXQgPyBcIkdFVFwiIDogXCJQT1NUXCIsXG4gICAgdXJpLFxuICAgIGpzb246ICEwLFxuICAgIGJvZHk6IHVzZUdldCA/IHZvaWQgMCA6IGJvZHksXG4gICAgcXVlcnk6IGlzTXV0YXRpb24gJiYgZ2V0TXV0YXRpb25RdWVyeShvcHRpb25zKSxcbiAgICB0aW1lb3V0LFxuICAgIGhlYWRlcnM6IGhlYWRlcnMyLFxuICAgIHRva2VuLFxuICAgIHRhZyxcbiAgICByZXR1cm5RdWVyeSxcbiAgICBwZXJzcGVjdGl2ZTogb3B0aW9ucy5wZXJzcGVjdGl2ZSxcbiAgICByZXN1bHRTb3VyY2VNYXA6IG9wdGlvbnMucmVzdWx0U291cmNlTWFwLFxuICAgIGxhc3RMaXZlRXZlbnRJZDogQXJyYXkuaXNBcnJheShsYXN0TGl2ZUV2ZW50SWQpID8gbGFzdExpdmVFdmVudElkWzBdIDogbGFzdExpdmVFdmVudElkLFxuICAgIGNhY2hlTW9kZSxcbiAgICBjYW5Vc2VDZG46IGlzUXVlcnksXG4gICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCxcbiAgICB1c2VBYm9ydFNpZ25hbDogb3B0aW9ucy51c2VBYm9ydFNpZ25hbCxcbiAgICB1c2VDZG46IG9wdGlvbnMudXNlQ2RuXG4gIH07XG4gIHJldHVybiBfcmVxdWVzdE9ic2VydmFibGUoY2xpZW50LCBodHRwUmVxdWVzdCwgcmVxT3B0aW9ucykucGlwZShcbiAgICBmaWx0ZXIoaXNSZXNwb25zZSksXG4gICAgbWFwKGdldEJvZHkpLFxuICAgIG1hcCgocmVzKSA9PiB7XG4gICAgICBpZiAoIWlzTXV0YXRpb24pXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICBjb25zdCByZXN1bHRzID0gcmVzLnJlc3VsdHMgfHwgW107XG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5Eb2N1bWVudHMpXG4gICAgICAgIHJldHVybiByZXR1cm5GaXJzdCA/IHJlc3VsdHNbMF0gJiYgcmVzdWx0c1swXS5kb2N1bWVudCA6IHJlc3VsdHMubWFwKChtdXQpID0+IG11dC5kb2N1bWVudCk7XG4gICAgICBjb25zdCBrZXkgPSByZXR1cm5GaXJzdCA/IFwiZG9jdW1lbnRJZFwiIDogXCJkb2N1bWVudElkc1wiLCBpZHMgPSByZXR1cm5GaXJzdCA/IHJlc3VsdHNbMF0gJiYgcmVzdWx0c1swXS5pZCA6IHJlc3VsdHMubWFwKChtdXQpID0+IG11dC5pZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFuc2FjdGlvbklkOiByZXMudHJhbnNhY3Rpb25JZCxcbiAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgW2tleV06IGlkc1xuICAgICAgfTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gX2NyZWF0ZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBkb2MsIG9wLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgbXV0YXRpb24gPSB7IFtvcF06IGRvYyB9LCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHJldHVybkZpcnN0OiAhMCwgcmV0dXJuRG9jdW1lbnRzOiAhMCB9LCBvcHRpb25zKTtcbiAgcmV0dXJuIF9kYXRhUmVxdWVzdChjbGllbnQsIGh0dHBSZXF1ZXN0LCBcIm11dGF0ZVwiLCB7IG11dGF0aW9uczogW211dGF0aW9uXSB9LCBvcHRzKTtcbn1cbmZ1bmN0aW9uIF9yZXF1ZXN0T2JzZXJ2YWJsZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHVyaSA9IG9wdGlvbnMudXJsIHx8IG9wdGlvbnMudXJpLCBjb25maWcgPSBjbGllbnQuY29uZmlnKCksIGNhblVzZUNkbiA9IHR5cGVvZiBvcHRpb25zLmNhblVzZUNkbiA+IFwidVwiID8gW1wiR0VUXCIsIFwiSEVBRFwiXS5pbmRleE9mKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIpID49IDAgJiYgdXJpLmluZGV4T2YoXCIvZGF0YS9cIikgPT09IDAgOiBvcHRpb25zLmNhblVzZUNkbjtcbiAgbGV0IHVzZUNkbiA9IChvcHRpb25zLnVzZUNkbiA/PyBjb25maWcudXNlQ2RuKSAmJiBjYW5Vc2VDZG47XG4gIGNvbnN0IHRhZyA9IG9wdGlvbnMudGFnICYmIGNvbmZpZy5yZXF1ZXN0VGFnUHJlZml4ID8gW2NvbmZpZy5yZXF1ZXN0VGFnUHJlZml4LCBvcHRpb25zLnRhZ10uam9pbihcIi5cIikgOiBvcHRpb25zLnRhZyB8fCBjb25maWcucmVxdWVzdFRhZ1ByZWZpeDtcbiAgaWYgKHRhZyAmJiBvcHRpb25zLnRhZyAhPT0gbnVsbCAmJiAob3B0aW9ucy5xdWVyeSA9IHsgdGFnOiByZXF1ZXN0VGFnKHRhZyksIC4uLm9wdGlvbnMucXVlcnkgfSksIFtcIkdFVFwiLCBcIkhFQURcIiwgXCJQT1NUXCJdLmluZGV4T2Yob3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIikgPj0gMCAmJiB1cmkuaW5kZXhPZihcIi9kYXRhL3F1ZXJ5L1wiKSA9PT0gMCkge1xuICAgIGNvbnN0IHJlc3VsdFNvdXJjZU1hcCA9IG9wdGlvbnMucmVzdWx0U291cmNlTWFwID8/IGNvbmZpZy5yZXN1bHRTb3VyY2VNYXA7XG4gICAgcmVzdWx0U291cmNlTWFwICE9PSB2b2lkIDAgJiYgcmVzdWx0U291cmNlTWFwICE9PSAhMSAmJiAob3B0aW9ucy5xdWVyeSA9IHsgcmVzdWx0U291cmNlTWFwLCAuLi5vcHRpb25zLnF1ZXJ5IH0pO1xuICAgIGNvbnN0IHBlcnNwZWN0aXZlT3B0aW9uID0gb3B0aW9ucy5wZXJzcGVjdGl2ZSB8fCBjb25maWcucGVyc3BlY3RpdmU7XG4gICAgdHlwZW9mIHBlcnNwZWN0aXZlT3B0aW9uIDwgXCJ1XCIgJiYgKHZhbGlkYXRlQXBpUGVyc3BlY3RpdmUocGVyc3BlY3RpdmVPcHRpb24pLCBvcHRpb25zLnF1ZXJ5ID0ge1xuICAgICAgcGVyc3BlY3RpdmU6IEFycmF5LmlzQXJyYXkocGVyc3BlY3RpdmVPcHRpb24pID8gcGVyc3BlY3RpdmVPcHRpb24uam9pbihcIixcIikgOiBwZXJzcGVjdGl2ZU9wdGlvbixcbiAgICAgIC4uLm9wdGlvbnMucXVlcnlcbiAgICB9LCBwZXJzcGVjdGl2ZU9wdGlvbiA9PT0gXCJwcmV2aWV3RHJhZnRzXCIgJiYgdXNlQ2RuICYmICh1c2VDZG4gPSAhMSwgcHJpbnRDZG5QcmV2aWV3RHJhZnRzV2FybmluZygpKSksIG9wdGlvbnMubGFzdExpdmVFdmVudElkICYmIChvcHRpb25zLnF1ZXJ5ID0geyAuLi5vcHRpb25zLnF1ZXJ5LCBsYXN0TGl2ZUV2ZW50SWQ6IG9wdGlvbnMubGFzdExpdmVFdmVudElkIH0pLCBvcHRpb25zLnJldHVyblF1ZXJ5ID09PSAhMSAmJiAob3B0aW9ucy5xdWVyeSA9IHsgcmV0dXJuUXVlcnk6IFwiZmFsc2VcIiwgLi4ub3B0aW9ucy5xdWVyeSB9KSwgdXNlQ2RuICYmIG9wdGlvbnMuY2FjaGVNb2RlID09IFwibm9TdGFsZVwiICYmIChvcHRpb25zLnF1ZXJ5ID0geyBjYWNoZU1vZGU6IFwibm9TdGFsZVwiLCAuLi5vcHRpb25zLnF1ZXJ5IH0pO1xuICB9XG4gIGNvbnN0IHJlcU9wdGlvbnMgPSByZXF1ZXN0T3B0aW9ucyhcbiAgICBjb25maWcsXG4gICAgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgdXJsOiBfZ2V0VXJsKGNsaWVudCwgdXJpLCB1c2VDZG4pXG4gICAgfSlcbiAgKSwgcmVxdWVzdCA9IG5ldyBPYnNlcnZhYmxlKFxuICAgIChzdWJzY3JpYmVyKSA9PiBodHRwUmVxdWVzdChyZXFPcHRpb25zLCBjb25maWcucmVxdWVzdGVyKS5zdWJzY3JpYmUoc3Vic2NyaWJlcilcbiAgKTtcbiAgcmV0dXJuIG9wdGlvbnMuc2lnbmFsID8gcmVxdWVzdC5waXBlKF93aXRoQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwpKSA6IHJlcXVlc3Q7XG59XG5mdW5jdGlvbiBfcmVxdWVzdChjbGllbnQsIGh0dHBSZXF1ZXN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBfcmVxdWVzdE9ic2VydmFibGUoY2xpZW50LCBodHRwUmVxdWVzdCwgb3B0aW9ucykucGlwZShcbiAgICBmaWx0ZXIoKGV2ZW50KSA9PiBldmVudC50eXBlID09PSBcInJlc3BvbnNlXCIpLFxuICAgIG1hcCgoZXZlbnQpID0+IGV2ZW50LmJvZHkpXG4gICk7XG59XG5mdW5jdGlvbiBfZ2V0RGF0YVVybChjbGllbnQsIG9wZXJhdGlvbiwgcGF0aCkge1xuICBjb25zdCBjb25maWcgPSBjbGllbnQuY29uZmlnKCksIGNhdGFsb2cgPSBoYXNEYXRhc2V0KGNvbmZpZyksIGJhc2VVcmkgPSBgLyR7b3BlcmF0aW9ufS8ke2NhdGFsb2d9YDtcbiAgcmV0dXJuIGAvZGF0YSR7cGF0aCA/IGAke2Jhc2VVcml9LyR7cGF0aH1gIDogYmFzZVVyaX1gLnJlcGxhY2UoL1xcLygkfFxcPykvLCBcIiQxXCIpO1xufVxuZnVuY3Rpb24gX2dldFVybChjbGllbnQsIHVyaSwgY2FuVXNlQ2RuID0gITEpIHtcbiAgY29uc3QgeyB1cmwsIGNkblVybCB9ID0gY2xpZW50LmNvbmZpZygpO1xuICByZXR1cm4gYCR7Y2FuVXNlQ2RuID8gY2RuVXJsIDogdXJsfS8ke3VyaS5yZXBsYWNlKC9eXFwvLywgXCJcIil9YDtcbn1cbmZ1bmN0aW9uIF93aXRoQWJvcnRTaWduYWwoc2lnbmFsKSB7XG4gIHJldHVybiAoaW5wdXQpID0+IG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgIGNvbnN0IGFib3J0ID0gKCkgPT4gb2JzZXJ2ZXIuZXJyb3IoX2NyZWF0ZUFib3J0RXJyb3Ioc2lnbmFsKSk7XG4gICAgaWYgKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgYWJvcnQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gaW5wdXQuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICByZXR1cm4gc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydCksICgpID0+IHtcbiAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnQpLCBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9KTtcbn1cbmNvbnN0IGlzRG9tRXhjZXB0aW9uU3VwcG9ydGVkID0gISFnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbjtcbmZ1bmN0aW9uIF9jcmVhdGVBYm9ydEVycm9yKHNpZ25hbCkge1xuICBpZiAoaXNEb21FeGNlcHRpb25TdXBwb3J0ZWQpXG4gICAgcmV0dXJuIG5ldyBET01FeGNlcHRpb24oc2lnbmFsPy5yZWFzb24gPz8gXCJUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLlwiLCBcIkFib3J0RXJyb3JcIik7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHNpZ25hbD8ucmVhc29uID8/IFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIik7XG4gIHJldHVybiBlcnJvci5uYW1lID0gXCJBYm9ydEVycm9yXCIsIGVycm9yO1xufVxuY2xhc3MgT2JzZXJ2YWJsZUFzc2V0c0NsaWVudCB7XG4gICNjbGllbnQ7XG4gICNodHRwUmVxdWVzdDtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdDtcbiAgfVxuICB1cGxvYWQoYXNzZXRUeXBlLCBib2R5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF91cGxvYWQodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgYXNzZXRUeXBlLCBib2R5LCBvcHRpb25zKTtcbiAgfVxufVxuY2xhc3MgQXNzZXRzQ2xpZW50IHtcbiAgI2NsaWVudDtcbiAgI2h0dHBSZXF1ZXN0O1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGh0dHBSZXF1ZXN0KSB7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0O1xuICB9XG4gIHVwbG9hZChhc3NldFR5cGUsIGJvZHksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvYnNlcnZhYmxlMiA9IF91cGxvYWQodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgYXNzZXRUeXBlLCBib2R5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIG9ic2VydmFibGUyLnBpcGUoXG4gICAgICAgIGZpbHRlcigoZXZlbnQpID0+IGV2ZW50LnR5cGUgPT09IFwicmVzcG9uc2VcIiksXG4gICAgICAgIG1hcChcbiAgICAgICAgICAoZXZlbnQpID0+IGV2ZW50LmJvZHkuZG9jdW1lbnRcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIF91cGxvYWQoY2xpZW50LCBodHRwUmVxdWVzdCwgYXNzZXRUeXBlLCBib2R5LCBvcHRzID0ge30pIHtcbiAgdmFsaWRhdGVBc3NldFR5cGUoYXNzZXRUeXBlKTtcbiAgbGV0IG1ldGEgPSBvcHRzLmV4dHJhY3QgfHwgdm9pZCAwO1xuICBtZXRhICYmICFtZXRhLmxlbmd0aCAmJiAobWV0YSA9IFtcIm5vbmVcIl0pO1xuICBjb25zdCBkYXRhc2V0MiA9IGhhc0RhdGFzZXQoY2xpZW50LmNvbmZpZygpKSwgYXNzZXRFbmRwb2ludCA9IGFzc2V0VHlwZSA9PT0gXCJpbWFnZVwiID8gXCJpbWFnZXNcIiA6IFwiZmlsZXNcIiwgb3B0aW9ucyA9IG9wdGlvbnNGcm9tRmlsZShvcHRzLCBib2R5KSwgeyB0YWcsIGxhYmVsLCB0aXRsZSwgZGVzY3JpcHRpb24sIGNyZWRpdExpbmUsIGZpbGVuYW1lLCBzb3VyY2UgfSA9IG9wdGlvbnMsIHF1ZXJ5ID0ge1xuICAgIGxhYmVsLFxuICAgIHRpdGxlLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIGZpbGVuYW1lLFxuICAgIG1ldGEsXG4gICAgY3JlZGl0TGluZVxuICB9O1xuICByZXR1cm4gc291cmNlICYmIChxdWVyeS5zb3VyY2VJZCA9IHNvdXJjZS5pZCwgcXVlcnkuc291cmNlTmFtZSA9IHNvdXJjZS5uYW1lLCBxdWVyeS5zb3VyY2VVcmwgPSBzb3VyY2UudXJsKSwgX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIHtcbiAgICB0YWcsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQgfHwgMCxcbiAgICB1cmk6IGAvYXNzZXRzLyR7YXNzZXRFbmRwb2ludH0vJHtkYXRhc2V0Mn1gLFxuICAgIGhlYWRlcnM6IG9wdGlvbnMuY29udGVudFR5cGUgPyB7IFwiQ29udGVudC1UeXBlXCI6IG9wdGlvbnMuY29udGVudFR5cGUgfSA6IHt9LFxuICAgIHF1ZXJ5LFxuICAgIGJvZHlcbiAgfSk7XG59XG5mdW5jdGlvbiBvcHRpb25zRnJvbUZpbGUob3B0cywgZmlsZSkge1xuICByZXR1cm4gdHlwZW9mIEZpbGUgPiBcInVcIiB8fCAhKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSA/IG9wdHMgOiBPYmplY3QuYXNzaWduKFxuICAgIHtcbiAgICAgIGZpbGVuYW1lOiBvcHRzLnByZXNlcnZlRmlsZW5hbWUgPT09ICExID8gdm9pZCAwIDogZmlsZS5uYW1lLFxuICAgICAgY29udGVudFR5cGU6IGZpbGUudHlwZVxuICAgIH0sXG4gICAgb3B0c1xuICApO1xufVxudmFyIGRlZmF1bHRzID0gKG9iaiwgZGVmYXVsdHMyKSA9PiBPYmplY3Qua2V5cyhkZWZhdWx0czIpLmNvbmNhdChPYmplY3Qua2V5cyhvYmopKS5yZWR1Y2UoKHRhcmdldCwgcHJvcCkgPT4gKHRhcmdldFtwcm9wXSA9IHR5cGVvZiBvYmpbcHJvcF0gPiBcInVcIiA/IGRlZmF1bHRzMltwcm9wXSA6IG9ialtwcm9wXSwgdGFyZ2V0KSwge30pO1xuY29uc3QgcGljayA9IChvYmosIHByb3BzKSA9PiBwcm9wcy5yZWR1Y2UoKHNlbGVjdGlvbiwgcHJvcCkgPT4gKHR5cGVvZiBvYmpbcHJvcF0gPiBcInVcIiB8fCAoc2VsZWN0aW9uW3Byb3BdID0gb2JqW3Byb3BdKSwgc2VsZWN0aW9uKSwge30pLCBNQVhfVVJMX0xFTkdUSCA9IDE0ODAwLCBwb3NzaWJsZU9wdGlvbnMgPSBbXG4gIFwiaW5jbHVkZVByZXZpb3VzUmV2aXNpb25cIixcbiAgXCJpbmNsdWRlUmVzdWx0XCIsXG4gIFwiaW5jbHVkZU11dGF0aW9uc1wiLFxuICBcInZpc2liaWxpdHlcIixcbiAgXCJlZmZlY3RGb3JtYXRcIixcbiAgXCJ0YWdcIlxuXSwgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGluY2x1ZGVSZXN1bHQ6ICEwXG59O1xuZnVuY3Rpb24gX2xpc3RlbihxdWVyeSwgcGFyYW1zLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyB1cmwsIHRva2VuLCB3aXRoQ3JlZGVudGlhbHMsIHJlcXVlc3RUYWdQcmVmaXggfSA9IHRoaXMuY29uZmlnKCksIHRhZyA9IG9wdHMudGFnICYmIHJlcXVlc3RUYWdQcmVmaXggPyBbcmVxdWVzdFRhZ1ByZWZpeCwgb3B0cy50YWddLmpvaW4oXCIuXCIpIDogb3B0cy50YWcsIG9wdGlvbnMgPSB7IC4uLmRlZmF1bHRzKG9wdHMsIGRlZmF1bHRPcHRpb25zKSwgdGFnIH0sIGxpc3Rlbk9wdHMgPSBwaWNrKG9wdGlvbnMsIHBvc3NpYmxlT3B0aW9ucyksIHFzID0gZW5jb2RlUXVlcnlTdHJpbmcoeyBxdWVyeSwgcGFyYW1zLCBvcHRpb25zOiB7IHRhZywgLi4ubGlzdGVuT3B0cyB9IH0pLCB1cmkgPSBgJHt1cmx9JHtfZ2V0RGF0YVVybCh0aGlzLCBcImxpc3RlblwiLCBxcyl9YDtcbiAgaWYgKHVyaS5sZW5ndGggPiBNQVhfVVJMX0xFTkdUSClcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiBvYnNlcnZlci5lcnJvcihuZXcgRXJyb3IoXCJRdWVyeSB0b28gbGFyZ2UgZm9yIGxpc3RlbmVyXCIpKSk7XG4gIGNvbnN0IGxpc3RlbkZvciA9IG9wdGlvbnMuZXZlbnRzID8gb3B0aW9ucy5ldmVudHMgOiBbXCJtdXRhdGlvblwiXSwgc2hvdWxkRW1pdFJlY29ubmVjdCA9IGxpc3RlbkZvci5pbmRleE9mKFwicmVjb25uZWN0XCIpICE9PSAtMSwgZXNPcHRpb25zID0ge307XG4gIHJldHVybiAodG9rZW4gfHwgd2l0aENyZWRlbnRpYWxzKSAmJiAoZXNPcHRpb25zLndpdGhDcmVkZW50aWFscyA9ICEwKSwgdG9rZW4gJiYgKGVzT3B0aW9ucy5oZWFkZXJzID0ge1xuICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gXG4gIH0pLCBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICBsZXQgZXMsIHJlY29ubmVjdFRpbWVyLCBzdG9wcGVkID0gITEsIHVuc3Vic2NyaWJlZCA9ICExO1xuICAgIG9wZW4oKTtcbiAgICBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgICAgc3RvcHBlZCB8fCAoZW1pdFJlY29ubmVjdCgpLCAhc3RvcHBlZCAmJiBlcy5yZWFkeVN0YXRlID09PSBlcy5DTE9TRUQgJiYgKHVuc3Vic2NyaWJlKCksIGNsZWFyVGltZW91dChyZWNvbm5lY3RUaW1lciksIHJlY29ubmVjdFRpbWVyID0gc2V0VGltZW91dChvcGVuLCAxMDApKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQ2hhbm5lbEVycm9yKGVycikge1xuICAgICAgb2JzZXJ2ZXIuZXJyb3IoY29vZXJjZUVycm9yKGVycikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1lc3NhZ2UoZXZ0KSB7XG4gICAgICBjb25zdCBldmVudCA9IHBhcnNlRXZlbnQkMShldnQpO1xuICAgICAgcmV0dXJuIGV2ZW50IGluc3RhbmNlb2YgRXJyb3IgPyBvYnNlcnZlci5lcnJvcihldmVudCkgOiBvYnNlcnZlci5uZXh0KGV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25EaXNjb25uZWN0KCkge1xuICAgICAgc3RvcHBlZCA9ICEwLCB1bnN1YnNjcmliZSgpLCBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGVzICYmIChlcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvciksIGVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFubmVsRXJyb3JcIiwgb25DaGFubmVsRXJyb3IpLCBlcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzY29ubmVjdFwiLCBvbkRpc2Nvbm5lY3QpLCBsaXN0ZW5Gb3IuZm9yRWFjaCgodHlwZSkgPT4gZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBvbk1lc3NhZ2UpKSwgZXMuY2xvc2UoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtaXRSZWNvbm5lY3QoKSB7XG4gICAgICBzaG91bGRFbWl0UmVjb25uZWN0ICYmIG9ic2VydmVyLm5leHQoeyB0eXBlOiBcInJlY29ubmVjdFwiIH0pO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRFdmVudFNvdXJjZSgpIHtcbiAgICAgIGNvbnN0IHsgZGVmYXVsdDogRXZlbnRTb3VyY2UyIH0gPSBhd2FpdCBpbXBvcnQoXCJAc2FuaXR5L2V2ZW50c291cmNlXCIpO1xuICAgICAgaWYgKHVuc3Vic2NyaWJlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgZXZzID0gbmV3IEV2ZW50U291cmNlMih1cmksIGVzT3B0aW9ucyk7XG4gICAgICByZXR1cm4gZXZzLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKSwgZXZzLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFubmVsRXJyb3JcIiwgb25DaGFubmVsRXJyb3IpLCBldnMuYWRkRXZlbnRMaXN0ZW5lcihcImRpc2Nvbm5lY3RcIiwgb25EaXNjb25uZWN0KSwgbGlzdGVuRm9yLmZvckVhY2goKHR5cGUpID0+IGV2cy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIG9uTWVzc2FnZSkpLCBldnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICBnZXRFdmVudFNvdXJjZSgpLnRoZW4oKGV2ZW50U291cmNlKSA9PiB7XG4gICAgICAgIGV2ZW50U291cmNlICYmIChlcyA9IGV2ZW50U291cmNlLCB1bnN1YnNjcmliZWQgJiYgdW5zdWJzY3JpYmUoKSk7XG4gICAgICB9KS5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgIG9ic2VydmVyLmVycm9yKHJlYXNvbiksIHN0b3AoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgc3RvcHBlZCA9ICEwLCB1bnN1YnNjcmliZSgpLCB1bnN1YnNjcmliZWQgPSAhMDtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3A7XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VFdmVudCQxKGV2ZW50KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGEgJiYgSlNPTi5wYXJzZShldmVudC5kYXRhKSB8fCB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGU6IGV2ZW50LnR5cGUgfSwgZGF0YSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBlcnI7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvb2VyY2VFcnJvcihlcnIpIHtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKVxuICAgIHJldHVybiBlcnI7XG4gIGNvbnN0IGV2dCA9IHBhcnNlRXZlbnQkMShlcnIpO1xuICByZXR1cm4gZXZ0IGluc3RhbmNlb2YgRXJyb3IgPyBldnQgOiBuZXcgRXJyb3IoZXh0cmFjdEVycm9yTWVzc2FnZShldnQpKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RFcnJvck1lc3NhZ2UoZXJyKSB7XG4gIHJldHVybiBlcnIuZXJyb3IgPyBlcnIuZXJyb3IuZGVzY3JpcHRpb24gPyBlcnIuZXJyb3IuZGVzY3JpcHRpb24gOiB0eXBlb2YgZXJyLmVycm9yID09IFwic3RyaW5nXCIgPyBlcnIuZXJyb3IgOiBKU09OLnN0cmluZ2lmeShlcnIuZXJyb3IsIG51bGwsIDIpIDogZXJyLm1lc3NhZ2UgfHwgXCJVbmtub3duIGxpc3RlbmVyIGVycm9yXCI7XG59XG5jb25zdCByZXF1aXJlZEFwaVZlcnNpb24gPSBcIjIwMjEtMDMtMjZcIjtcbmNsYXNzIExpdmVDbGllbnQge1xuICAjY2xpZW50O1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVpcmVzIGBhcGlWZXJzaW9uYCB0byBiZSBgMjAyMS0wMy0yNmAgb3IgbGF0ZXIuXG4gICAqL1xuICBldmVudHMoe1xuICAgIGluY2x1ZGVEcmFmdHMgPSAhMSxcbiAgICB0YWc6IF90YWdcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJvamVjdElkOiBwcm9qZWN0SWQyLFxuICAgICAgYXBpVmVyc2lvbjogX2FwaVZlcnNpb24sXG4gICAgICB0b2tlbixcbiAgICAgIHdpdGhDcmVkZW50aWFscyxcbiAgICAgIHJlcXVlc3RUYWdQcmVmaXhcbiAgICB9ID0gdGhpcy4jY2xpZW50LmNvbmZpZygpLCBhcGlWZXJzaW9uID0gX2FwaVZlcnNpb24ucmVwbGFjZSgvXnYvLCBcIlwiKTtcbiAgICBpZiAoYXBpVmVyc2lvbiAhPT0gXCJYXCIgJiYgYXBpVmVyc2lvbiA8IHJlcXVpcmVkQXBpVmVyc2lvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZSBsaXZlIGV2ZW50cyBBUEkgcmVxdWlyZXMgQVBJIHZlcnNpb24gJHtyZXF1aXJlZEFwaVZlcnNpb259IG9yIGxhdGVyLiBUaGUgY3VycmVudCBBUEkgdmVyc2lvbiBpcyAke2FwaVZlcnNpb259LiBQbGVhc2UgdXBkYXRlIHlvdXIgQVBJIHZlcnNpb24gdG8gdXNlIHRoaXMgZmVhdHVyZS5gXG4gICAgICApO1xuICAgIGlmIChpbmNsdWRlRHJhZnRzICYmICF0b2tlbiAmJiAhd2l0aENyZWRlbnRpYWxzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRoZSBsaXZlIGV2ZW50cyBBUEkgcmVxdWlyZXMgYSB0b2tlbiBvciB3aXRoQ3JlZGVudGlhbHMgd2hlbiAnaW5jbHVkZURyYWZ0czogdHJ1ZScuIFBsZWFzZSB1cGRhdGUgeW91ciBjbGllbnQgY29uZmlndXJhdGlvbi4gVGhlIHRva2VuIHNob3VsZCBoYXZlIHRoZSBsb3dlc3QgcG9zc2libGUgYWNjZXNzIHJvbGUuXCJcbiAgICAgICk7XG4gICAgaWYgKGluY2x1ZGVEcmFmdHMgJiYgYXBpVmVyc2lvbiAhPT0gXCJYXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVGhlIGxpdmUgZXZlbnRzIEFQSSByZXF1aXJlcyBBUEkgdmVyc2lvbiBYIHdoZW4gJ2luY2x1ZGVEcmFmdHM6IHRydWUnLiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2Ugb3IgZXZlbiBiZSByZW1vdmVkLlwiXG4gICAgICApO1xuICAgIGNvbnN0IHBhdGggPSBfZ2V0RGF0YVVybCh0aGlzLiNjbGllbnQsIFwibGl2ZS9ldmVudHNcIiksIHVybCA9IG5ldyBVUkwodGhpcy4jY2xpZW50LmdldFVybChwYXRoLCAhMSkpLCB0YWcgPSBfdGFnICYmIHJlcXVlc3RUYWdQcmVmaXggPyBbcmVxdWVzdFRhZ1ByZWZpeCwgX3RhZ10uam9pbihcIi5cIikgOiBfdGFnO1xuICAgIHRhZyAmJiB1cmwuc2VhcmNoUGFyYW1zLnNldChcInRhZ1wiLCB0YWcpLCBpbmNsdWRlRHJhZnRzICYmIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiaW5jbHVkZURyYWZ0c1wiLCBcInRydWVcIik7XG4gICAgY29uc3QgbGlzdGVuRm9yID0gW1wicmVzdGFydFwiLCBcIm1lc3NhZ2VcIiwgXCJ3ZWxjb21lXCIsIFwicmVjb25uZWN0XCJdLCBlc09wdGlvbnMgPSB7fTtcbiAgICByZXR1cm4gaW5jbHVkZURyYWZ0cyAmJiB0b2tlbiAmJiAoZXNPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgIH0pLCBpbmNsdWRlRHJhZnRzICYmIHdpdGhDcmVkZW50aWFscyAmJiAoZXNPcHRpb25zLndpdGhDcmVkZW50aWFscyA9ICEwKSwgbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gICAgICBsZXQgZXMsIHJlY29ubmVjdFRpbWVyLCBzdG9wcGVkID0gITEsIHVuc3Vic2NyaWJlZCA9ICExO1xuICAgICAgb3BlbigpO1xuICAgICAgZnVuY3Rpb24gb25FcnJvcihldnQpIHtcbiAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIGV2dCkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBwYXJzZUV2ZW50KGV2dCk7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihuZXcgRXJyb3IoZXZlbnQubWVzc2FnZSwgeyBjYXVzZTogZXZlbnQgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcy5yZWFkeVN0YXRlID09PSBlcy5DTE9TRUQgJiYgKHVuc3Vic2NyaWJlKCksIGNsZWFyVGltZW91dChyZWNvbm5lY3RUaW1lciksIHJlY29ubmVjdFRpbWVyID0gc2V0VGltZW91dChvcGVuLCAxMDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25NZXNzYWdlKGV2dCkge1xuICAgICAgICBjb25zdCBldmVudCA9IHBhcnNlRXZlbnQoZXZ0KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50IGluc3RhbmNlb2YgRXJyb3IgPyBvYnNlcnZlci5lcnJvcihldmVudCkgOiBvYnNlcnZlci5uZXh0KGV2ZW50KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoZXMpIHtcbiAgICAgICAgICBlcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGxpc3RlbkZvcilcbiAgICAgICAgICAgIGVzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgb25NZXNzYWdlKTtcbiAgICAgICAgICBlcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhc3luYyBmdW5jdGlvbiBnZXRFdmVudFNvdXJjZSgpIHtcbiAgICAgICAgY29uc3QgRXZlbnRTb3VyY2VJbXBsZW1lbnRhdGlvbiA9IHR5cGVvZiBFdmVudFNvdXJjZSA+IFwidVwiIHx8IGVzT3B0aW9ucy5oZWFkZXJzIHx8IGVzT3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgPyAoYXdhaXQgaW1wb3J0KFwiQHNhbml0eS9ldmVudHNvdXJjZVwiKSkuZGVmYXVsdCA6IEV2ZW50U291cmNlO1xuICAgICAgICBpZiAodW5zdWJzY3JpYmVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiT1BUSU9OU1wiLFxuICAgICAgICAgICAgbW9kZTogXCJjb3JzXCIsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogZXNPcHRpb25zLndpdGhDcmVkZW50aWFscyA/IFwiaW5jbHVkZVwiIDogXCJvbWl0XCIsXG4gICAgICAgICAgICBoZWFkZXJzOiBlc09wdGlvbnMuaGVhZGVyc1xuICAgICAgICAgIH0pLCB1bnN1YnNjcmliZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHRocm93IG5ldyBDb3JzT3JpZ2luRXJyb3IoeyBwcm9qZWN0SWQ6IHByb2plY3RJZDIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZzID0gbmV3IEV2ZW50U291cmNlSW1wbGVtZW50YXRpb24odXJsLnRvU3RyaW5nKCksIGVzT3B0aW9ucyk7XG4gICAgICAgIGV2cy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBsaXN0ZW5Gb3IpXG4gICAgICAgICAgZXZzLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgb25NZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGV2cztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGdldEV2ZW50U291cmNlKCkudGhlbigoZXZlbnRTb3VyY2UpID0+IHtcbiAgICAgICAgICBldmVudFNvdXJjZSAmJiAoZXMgPSBldmVudFNvdXJjZSwgdW5zdWJzY3JpYmVkICYmIHVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB9KS5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IocmVhc29uKSwgc3RvcCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgIHN0b3BwZWQgPSAhMCwgdW5zdWJzY3JpYmUoKSwgdW5zdWJzY3JpYmVkID0gITA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RvcDtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VFdmVudChldmVudCkge1xuICB0cnkge1xuICAgIGNvbnN0IGRhdGEgPSBldmVudC5kYXRhICYmIEpTT04ucGFyc2UoZXZlbnQuZGF0YSkgfHwge307XG4gICAgcmV0dXJuIHsgdHlwZTogZXZlbnQudHlwZSwgaWQ6IGV2ZW50Lmxhc3RFdmVudElkLCAuLi5kYXRhIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBlcnI7XG4gIH1cbn1cbmNsYXNzIE9ic2VydmFibGVEYXRhc2V0c0NsaWVudCB7XG4gICNjbGllbnQ7XG4gICNodHRwUmVxdWVzdDtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGRhdGFzZXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGRhdGFzZXRcbiAgICovXG4gIGNyZWF0ZShuYW1lMiwgb3B0aW9ucykge1xuICAgIHJldHVybiBfbW9kaWZ5KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIFwiUFVUXCIsIG5hbWUyLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRWRpdCBhIGRhdGFzZXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gZWRpdFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5ldyBvcHRpb25zIGZvciB0aGUgZGF0YXNldFxuICAgKi9cbiAgZWRpdChuYW1lMiwgb3B0aW9ucykge1xuICAgIHJldHVybiBfbW9kaWZ5KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIFwiUEFUQ0hcIiwgbmFtZTIsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKG5hbWUyKSB7XG4gICAgcmV0dXJuIF9tb2RpZnkodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgXCJERUxFVEVcIiwgbmFtZTIpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgZGF0YXNldHMgZm9yIHRoZSBjb25maWd1cmVkIHByb2plY3RcbiAgICovXG4gIGxpc3QoKSB7XG4gICAgcmV0dXJuIF9yZXF1ZXN0KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIHtcbiAgICAgIHVyaTogXCIvZGF0YXNldHNcIixcbiAgICAgIHRhZzogbnVsbFxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBEYXRhc2V0c0NsaWVudCB7XG4gICNjbGllbnQ7XG4gICNodHRwUmVxdWVzdDtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGRhdGFzZXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGRhdGFzZXRcbiAgICovXG4gIGNyZWF0ZShuYW1lMiwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX21vZGlmeSh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCBcIlBVVFwiLCBuYW1lMiwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBFZGl0IGEgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgZGF0YXNldCB0byBlZGl0XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmV3IG9wdGlvbnMgZm9yIHRoZSBkYXRhc2V0XG4gICAqL1xuICBlZGl0KG5hbWUyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICBfbW9kaWZ5KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIFwiUEFUQ0hcIiwgbmFtZTIsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgZGF0YXNldCB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShuYW1lMikge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9tb2RpZnkodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgXCJERUxFVEVcIiwgbmFtZTIpKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIGRhdGFzZXRzIGZvciB0aGUgY29uZmlndXJlZCBwcm9qZWN0XG4gICAqL1xuICBsaXN0KCkge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX3JlcXVlc3QodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgeyB1cmk6IFwiL2RhdGFzZXRzXCIsIHRhZzogbnVsbCB9KVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9tb2RpZnkoY2xpZW50LCBodHRwUmVxdWVzdCwgbWV0aG9kLCBuYW1lMiwgb3B0aW9ucykge1xuICByZXR1cm4gZGF0YXNldChuYW1lMiksIF9yZXF1ZXN0KGNsaWVudCwgaHR0cFJlcXVlc3QsIHtcbiAgICBtZXRob2QsXG4gICAgdXJpOiBgL2RhdGFzZXRzLyR7bmFtZTJ9YCxcbiAgICBib2R5OiBvcHRpb25zLFxuICAgIHRhZzogbnVsbFxuICB9KTtcbn1cbmNsYXNzIE9ic2VydmFibGVQcm9qZWN0c0NsaWVudCB7XG4gICNjbGllbnQ7XG4gICNodHRwUmVxdWVzdDtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdDtcbiAgfVxuICBsaXN0KG9wdGlvbnMpIHtcbiAgICBjb25zdCB1cmkgPSBvcHRpb25zPy5pbmNsdWRlTWVtYmVycyA9PT0gITEgPyBcIi9wcm9qZWN0cz9pbmNsdWRlTWVtYmVycz1mYWxzZVwiIDogXCIvcHJvamVjdHNcIjtcbiAgICByZXR1cm4gX3JlcXVlc3QodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgeyB1cmkgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgcHJvamVjdCBieSBwcm9qZWN0IElEXG4gICAqXG4gICAqIEBwYXJhbSBwcm9qZWN0SWQgLSBJRCBvZiB0aGUgcHJvamVjdCB0byBmZXRjaFxuICAgKi9cbiAgZ2V0QnlJZChwcm9qZWN0SWQyKSB7XG4gICAgcmV0dXJuIF9yZXF1ZXN0KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIHsgdXJpOiBgL3Byb2plY3RzLyR7cHJvamVjdElkMn1gIH0pO1xuICB9XG59XG5jbGFzcyBQcm9qZWN0c0NsaWVudCB7XG4gICNjbGllbnQ7XG4gICNodHRwUmVxdWVzdDtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdDtcbiAgfVxuICBsaXN0KG9wdGlvbnMpIHtcbiAgICBjb25zdCB1cmkgPSBvcHRpb25zPy5pbmNsdWRlTWVtYmVycyA9PT0gITEgPyBcIi9wcm9qZWN0cz9pbmNsdWRlTWVtYmVycz1mYWxzZVwiIDogXCIvcHJvamVjdHNcIjtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfcmVxdWVzdCh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCB7IHVyaSB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgcHJvamVjdCBieSBwcm9qZWN0IElEXG4gICAqXG4gICAqIEBwYXJhbSBwcm9qZWN0SWQgLSBJRCBvZiB0aGUgcHJvamVjdCB0byBmZXRjaFxuICAgKi9cbiAgZ2V0QnlJZChwcm9qZWN0SWQyKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICBfcmVxdWVzdCh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCB7IHVyaTogYC9wcm9qZWN0cy8ke3Byb2plY3RJZDJ9YCB9KVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIE9ic2VydmFibGVVc2Vyc0NsaWVudCB7XG4gICNjbGllbnQ7XG4gICNodHRwUmVxdWVzdDtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdDtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSB1c2VyIGJ5IHVzZXIgSURcbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVXNlciBJRCBvZiB0aGUgdXNlciB0byBmZXRjaC4gSWYgYG1lYCBpcyBwcm92aWRlZCwgYSBtaW5pbWFsIHJlc3BvbnNlIGluY2x1ZGluZyB0aGUgdXNlcnMgcm9sZSBpcyByZXR1cm5lZC5cbiAgICovXG4gIGdldEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gX3JlcXVlc3QoXG4gICAgICB0aGlzLiNjbGllbnQsXG4gICAgICB0aGlzLiNodHRwUmVxdWVzdCxcbiAgICAgIHsgdXJpOiBgL3VzZXJzLyR7aWR9YCB9XG4gICAgKTtcbiAgfVxufVxuY2xhc3MgVXNlcnNDbGllbnQge1xuICAjY2xpZW50O1xuICAjaHR0cFJlcXVlc3Q7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgdXNlciBieSB1c2VyIElEXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFVzZXIgSUQgb2YgdGhlIHVzZXIgdG8gZmV0Y2guIElmIGBtZWAgaXMgcHJvdmlkZWQsIGEgbWluaW1hbCByZXNwb25zZSBpbmNsdWRpbmcgdGhlIHVzZXJzIHJvbGUgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICBfcmVxdWVzdCh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCB7XG4gICAgICAgIHVyaTogYC91c2Vycy8ke2lkfWBcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuY2xhc3MgT2JzZXJ2YWJsZVNhbml0eUNsaWVudCB7XG4gIGFzc2V0cztcbiAgZGF0YXNldHM7XG4gIGxpdmU7XG4gIHByb2plY3RzO1xuICB1c2VycztcbiAgLyoqXG4gICAqIFByaXZhdGUgcHJvcGVydGllc1xuICAgKi9cbiAgI2NsaWVudENvbmZpZztcbiAgI2h0dHBSZXF1ZXN0O1xuICAvKipcbiAgICogSW5zdGFuY2UgcHJvcGVydGllc1xuICAgKi9cbiAgbGlzdGVuID0gX2xpc3RlbjtcbiAgY29uc3RydWN0b3IoaHR0cFJlcXVlc3QsIGNvbmZpZyA9IGRlZmF1bHRDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyhjb25maWcpLCB0aGlzLiNodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0LCB0aGlzLmFzc2V0cyA9IG5ldyBPYnNlcnZhYmxlQXNzZXRzQ2xpZW50KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0KSwgdGhpcy5kYXRhc2V0cyA9IG5ldyBPYnNlcnZhYmxlRGF0YXNldHNDbGllbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QpLCB0aGlzLmxpdmUgPSBuZXcgTGl2ZUNsaWVudCh0aGlzKSwgdGhpcy5wcm9qZWN0cyA9IG5ldyBPYnNlcnZhYmxlUHJvamVjdHNDbGllbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QpLCB0aGlzLnVzZXJzID0gbmV3IE9ic2VydmFibGVVc2Vyc0NsaWVudCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lIHRoZSBjbGllbnQgLSByZXR1cm5zIGEgbmV3IGluc3RhbmNlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTYW5pdHlDbGllbnQodGhpcy4jaHR0cFJlcXVlc3QsIHRoaXMuY29uZmlnKCkpO1xuICB9XG4gIGNvbmZpZyhuZXdDb25maWcpIHtcbiAgICBpZiAobmV3Q29uZmlnID09PSB2b2lkIDApXG4gICAgICByZXR1cm4geyAuLi50aGlzLiNjbGllbnRDb25maWcgfTtcbiAgICBpZiAodGhpcy4jY2xpZW50Q29uZmlnICYmIHRoaXMuI2NsaWVudENvbmZpZy5hbGxvd1JlY29uZmlndXJlID09PSAhMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeGlzdGluZyBjbGllbnQgaW5zdGFuY2UgY2Fubm90IGJlIHJlY29uZmlndXJlZCAtIHVzZSBgd2l0aENvbmZpZyhuZXdDb25maWcpYCB0byByZXR1cm4gYSBuZXcgY2xpZW50XCJcbiAgICAgICk7XG4gICAgcmV0dXJuIHRoaXMuI2NsaWVudENvbmZpZyA9IGluaXRDb25maWcobmV3Q29uZmlnLCB0aGlzLiNjbGllbnRDb25maWcgfHwge30pLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZSB0aGUgY2xpZW50IHdpdGggYSBuZXcgKHBhcnRpYWwpIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBuZXdDb25maWcgLSBOZXcgY2xpZW50IGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcywgc2hhbGxvd2x5IG1lcmdlZCB3aXRoIGV4aXN0aW5nIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIHdpdGhDb25maWcobmV3Q29uZmlnKSB7XG4gICAgY29uc3QgdGhpc0NvbmZpZyA9IHRoaXMuY29uZmlnKCk7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlU2FuaXR5Q2xpZW50KHRoaXMuI2h0dHBSZXF1ZXN0LCB7XG4gICAgICAuLi50aGlzQ29uZmlnLFxuICAgICAgLi4ubmV3Q29uZmlnLFxuICAgICAgc3RlZ2E6IHtcbiAgICAgICAgLi4udGhpc0NvbmZpZy5zdGVnYSB8fCB7fSxcbiAgICAgICAgLi4udHlwZW9mIG5ld0NvbmZpZz8uc3RlZ2EgPT0gXCJib29sZWFuXCIgPyB7IGVuYWJsZWQ6IG5ld0NvbmZpZy5zdGVnYSB9IDogbmV3Q29uZmlnPy5zdGVnYSB8fCB7fVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZldGNoKHF1ZXJ5LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2ZldGNoKFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMuI2h0dHBSZXF1ZXN0LFxuICAgICAgdGhpcy4jY2xpZW50Q29uZmlnLnN0ZWdhLFxuICAgICAgcXVlcnksXG4gICAgICBwYXJhbXMsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBzaW5nbGUgZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIERvY3VtZW50IElEIHRvIGZldGNoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqL1xuICBnZXREb2N1bWVudChpZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfZ2V0RG9jdW1lbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIGlkLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggbXVsdGlwbGUgZG9jdW1lbnRzIGluIG9uZSByZXF1ZXN0LlxuICAgKiBTaG91bGQgYmUgdXNlZCBzcGFyaW5nbHkgLSBwZXJmb3JtaW5nIGEgcXVlcnkgaXMgdXN1YWxseSBhIGJldHRlciBvcHRpb24uXG4gICAqIFRoZSBvcmRlci9wb3NpdGlvbiBvZiBkb2N1bWVudHMgaXMgcHJlc2VydmVkIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBhcnJheSBvZiBJRHMuXG4gICAqIElmIGFueSBvZiB0aGUgZG9jdW1lbnRzIGFyZSBtaXNzaW5nLCB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgYnkgYSBgbnVsbGAgZW50cnkgaW4gdGhlIHJldHVybmVkIGFycmF5XG4gICAqXG4gICAqIEBwYXJhbSBpZHMgLSBEb2N1bWVudCBJRHMgdG8gZmV0Y2hcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnNcbiAgICovXG4gIGdldERvY3VtZW50cyhpZHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2dldERvY3VtZW50cyh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgaWRzLCBvcHRpb25zKTtcbiAgfVxuICBjcmVhdGUoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2NyZWF0ZSh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgZG9jdW1lbnQsIFwiY3JlYXRlXCIsIG9wdGlvbnMpO1xuICB9XG4gIGNyZWF0ZUlmTm90RXhpc3RzKGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVJZk5vdEV4aXN0cyh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgZG9jdW1lbnQsIG9wdGlvbnMpO1xuICB9XG4gIGNyZWF0ZU9yUmVwbGFjZShkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfY3JlYXRlT3JSZXBsYWNlKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBkb2N1bWVudCwgb3B0aW9ucyk7XG4gIH1cbiAgZGVsZXRlKHNlbGVjdGlvbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBfZGVsZXRlKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBzZWxlY3Rpb24sIG9wdGlvbnMpO1xuICB9XG4gIG11dGF0ZShvcGVyYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9tdXRhdGUodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIG9wZXJhdGlvbnMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYnVpbGRhYmxlIHBhdGNoIG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybVxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gRG9jdW1lbnQgSUQsIGFuIGFycmF5IG9mIGRvY3VtZW50IElEcywgb3IgYW4gb2JqZWN0IHdpdGggYHF1ZXJ5YCBhbmQgb3B0aW9uYWwgYHBhcmFtc2AsIGRlZmluaW5nIHdoaWNoIGRvY3VtZW50KHMpIHRvIHBhdGNoXG4gICAqIEBwYXJhbSBvcGVyYXRpb25zIC0gT3B0aW9uYWwgb2JqZWN0IG9mIHBhdGNoIG9wZXJhdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgcGF0Y2ggaW5zdGFuY2Ugd2l0aFxuICAgKiBAcmV0dXJucyBQYXRjaCBpbnN0YW5jZSAtIGNhbGwgYC5jb21taXQoKWAgdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9ucyBkZWZpbmVkXG4gICAqL1xuICBwYXRjaChzZWxlY3Rpb24sIG9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVQYXRjaChzZWxlY3Rpb24sIG9wZXJhdGlvbnMsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNhY3Rpb24gb2YgbXV0YXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb25zIC0gT3B0aW9uYWwgYXJyYXkgb2YgbXV0YXRpb24gb3BlcmF0aW9ucyB0byBpbml0aWFsaXplIHRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSB3aXRoXG4gICAqL1xuICB0cmFuc2FjdGlvbihvcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlVHJhbnNhY3Rpb24ob3BlcmF0aW9ucywgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm0gYWN0aW9uIG9wZXJhdGlvbnMgYWdhaW5zdCB0aGUgY29uZmlndXJlZCBkYXRhc2V0XG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb25zIC0gQWN0aW9uIG9wZXJhdGlvbihzKSB0byBleGVjdXRlXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQWN0aW9uIG9wdGlvbnNcbiAgICovXG4gIGFjdGlvbihvcGVyYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9hY3Rpb24odGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIG9wZXJhdGlvbnMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIEhUVFAgcmVxdWVzdCBhZ2FpbnN0IHRoZSBTYW5pdHkgQVBJXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqL1xuICByZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX3JlcXVlc3QodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBTYW5pdHkgQVBJIFVSTCBmb3IgdGhlIFVSSSBwcm92aWRlZFxuICAgKlxuICAgKiBAcGFyYW0gdXJpIC0gVVJJL3BhdGggdG8gYnVpbGQgVVJMIGZvclxuICAgKiBAcGFyYW0gY2FuVXNlQ2RuIC0gV2hldGhlciBvciBub3QgdG8gYWxsb3cgdXNpbmcgdGhlIEFQSSBDRE4gZm9yIHRoaXMgcm91dGVcbiAgICovXG4gIGdldFVybCh1cmksIGNhblVzZUNkbikge1xuICAgIHJldHVybiBfZ2V0VXJsKHRoaXMsIHVyaSwgY2FuVXNlQ2RuKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgU2FuaXR5IEFQSSBVUkwgZm9yIHRoZSBkYXRhIG9wZXJhdGlvbiBhbmQgcGF0aCBwcm92aWRlZFxuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9uIC0gRGF0YSBvcGVyYXRpb24gKGVnIGBxdWVyeWAsIGBtdXRhdGVgLCBgbGlzdGVuYCBvciBzaW1pbGFyKVxuICAgKiBAcGFyYW0gcGF0aCAtIFBhdGggdG8gYXBwZW5kIGFmdGVyIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGdldERhdGFVcmwob3BlcmF0aW9uLCBwYXRoKSB7XG4gICAgcmV0dXJuIF9nZXREYXRhVXJsKHRoaXMsIG9wZXJhdGlvbiwgcGF0aCk7XG4gIH1cbn1cbmNsYXNzIFNhbml0eUNsaWVudCB7XG4gIGFzc2V0cztcbiAgZGF0YXNldHM7XG4gIGxpdmU7XG4gIHByb2plY3RzO1xuICB1c2VycztcbiAgLyoqXG4gICAqIE9ic2VydmFibGUgdmVyc2lvbiBvZiB0aGUgU2FuaXR5IGNsaWVudCwgd2l0aCB0aGUgc2FtZSBjb25maWd1cmF0aW9uIGFzIHRoZSBwcm9taXNlLWJhc2VkIG9uZVxuICAgKi9cbiAgb2JzZXJ2YWJsZTtcbiAgLyoqXG4gICAqIFByaXZhdGUgcHJvcGVydGllc1xuICAgKi9cbiAgI2NsaWVudENvbmZpZztcbiAgI2h0dHBSZXF1ZXN0O1xuICAvKipcbiAgICogSW5zdGFuY2UgcHJvcGVydGllc1xuICAgKi9cbiAgbGlzdGVuID0gX2xpc3RlbjtcbiAgY29uc3RydWN0b3IoaHR0cFJlcXVlc3QsIGNvbmZpZyA9IGRlZmF1bHRDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyhjb25maWcpLCB0aGlzLiNodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0LCB0aGlzLmFzc2V0cyA9IG5ldyBBc3NldHNDbGllbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QpLCB0aGlzLmRhdGFzZXRzID0gbmV3IERhdGFzZXRzQ2xpZW50KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0KSwgdGhpcy5saXZlID0gbmV3IExpdmVDbGllbnQodGhpcyksIHRoaXMucHJvamVjdHMgPSBuZXcgUHJvamVjdHNDbGllbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QpLCB0aGlzLnVzZXJzID0gbmV3IFVzZXJzQ2xpZW50KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0KSwgdGhpcy5vYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVTYW5pdHlDbGllbnQoaHR0cFJlcXVlc3QsIGNvbmZpZyk7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lIHRoZSBjbGllbnQgLSByZXR1cm5zIGEgbmV3IGluc3RhbmNlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFNhbml0eUNsaWVudCh0aGlzLiNodHRwUmVxdWVzdCwgdGhpcy5jb25maWcoKSk7XG4gIH1cbiAgY29uZmlnKG5ld0NvbmZpZykge1xuICAgIGlmIChuZXdDb25maWcgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiB7IC4uLnRoaXMuI2NsaWVudENvbmZpZyB9O1xuICAgIGlmICh0aGlzLiNjbGllbnRDb25maWcgJiYgdGhpcy4jY2xpZW50Q29uZmlnLmFsbG93UmVjb25maWd1cmUgPT09ICExKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkV4aXN0aW5nIGNsaWVudCBpbnN0YW5jZSBjYW5ub3QgYmUgcmVjb25maWd1cmVkIC0gdXNlIGB3aXRoQ29uZmlnKG5ld0NvbmZpZylgIHRvIHJldHVybiBhIG5ldyBjbGllbnRcIlxuICAgICAgKTtcbiAgICByZXR1cm4gdGhpcy5vYnNlcnZhYmxlICYmIHRoaXMub2JzZXJ2YWJsZS5jb25maWcobmV3Q29uZmlnKSwgdGhpcy4jY2xpZW50Q29uZmlnID0gaW5pdENvbmZpZyhuZXdDb25maWcsIHRoaXMuI2NsaWVudENvbmZpZyB8fCB7fSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lIHRoZSBjbGllbnQgd2l0aCBhIG5ldyAocGFydGlhbCkgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG5ld0NvbmZpZyAtIE5ldyBjbGllbnQgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLCBzaGFsbG93bHkgbWVyZ2VkIHdpdGggZXhpc3RpbmcgY29uZmlndXJhdGlvblxuICAgKi9cbiAgd2l0aENvbmZpZyhuZXdDb25maWcpIHtcbiAgICBjb25zdCB0aGlzQ29uZmlnID0gdGhpcy5jb25maWcoKTtcbiAgICByZXR1cm4gbmV3IFNhbml0eUNsaWVudCh0aGlzLiNodHRwUmVxdWVzdCwge1xuICAgICAgLi4udGhpc0NvbmZpZyxcbiAgICAgIC4uLm5ld0NvbmZpZyxcbiAgICAgIHN0ZWdhOiB7XG4gICAgICAgIC4uLnRoaXNDb25maWcuc3RlZ2EgfHwge30sXG4gICAgICAgIC4uLnR5cGVvZiBuZXdDb25maWc/LnN0ZWdhID09IFwiYm9vbGVhblwiID8geyBlbmFibGVkOiBuZXdDb25maWcuc3RlZ2EgfSA6IG5ld0NvbmZpZz8uc3RlZ2EgfHwge31cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmZXRjaChxdWVyeSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICBfZmV0Y2goXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMuI2h0dHBSZXF1ZXN0LFxuICAgICAgICB0aGlzLiNjbGllbnRDb25maWcuc3RlZ2EsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHNpbmdsZSBkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBJRC5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gRG9jdW1lbnQgSUQgdG8gZmV0Y2hcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnNcbiAgICovXG4gIGdldERvY3VtZW50KGlkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX2dldERvY3VtZW50KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBpZCwgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBtdWx0aXBsZSBkb2N1bWVudHMgaW4gb25lIHJlcXVlc3QuXG4gICAqIFNob3VsZCBiZSB1c2VkIHNwYXJpbmdseSAtIHBlcmZvcm1pbmcgYSBxdWVyeSBpcyB1c3VhbGx5IGEgYmV0dGVyIG9wdGlvbi5cbiAgICogVGhlIG9yZGVyL3Bvc2l0aW9uIG9mIGRvY3VtZW50cyBpcyBwcmVzZXJ2ZWQgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGFycmF5IG9mIElEcy5cbiAgICogSWYgYW55IG9mIHRoZSBkb2N1bWVudHMgYXJlIG1pc3NpbmcsIHRoZXkgd2lsbCBiZSByZXBsYWNlZCBieSBhIGBudWxsYCBlbnRyeSBpbiB0aGUgcmV0dXJuZWQgYXJyYXlcbiAgICpcbiAgICogQHBhcmFtIGlkcyAtIERvY3VtZW50IElEcyB0byBmZXRjaFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9uc1xuICAgKi9cbiAgZ2V0RG9jdW1lbnRzKGlkcywgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9nZXREb2N1bWVudHModGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIGlkcywgb3B0aW9ucykpO1xuICB9XG4gIGNyZWF0ZShkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX2NyZWF0ZSh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgZG9jdW1lbnQsIFwiY3JlYXRlXCIsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICBjcmVhdGVJZk5vdEV4aXN0cyhkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX2NyZWF0ZUlmTm90RXhpc3RzKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBkb2N1bWVudCwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIGNyZWF0ZU9yUmVwbGFjZShkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX2NyZWF0ZU9yUmVwbGFjZSh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgZG9jdW1lbnQsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICBkZWxldGUoc2VsZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX2RlbGV0ZSh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgc2VsZWN0aW9uLCBvcHRpb25zKSk7XG4gIH1cbiAgbXV0YXRlKG9wZXJhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfbXV0YXRlKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBvcGVyYXRpb25zLCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBidWlsZGFibGUgcGF0Y2ggb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3Rpb24gLSBEb2N1bWVudCBJRCwgYW4gYXJyYXkgb2YgZG9jdW1lbnQgSURzLCBvciBhbiBvYmplY3Qgd2l0aCBgcXVlcnlgIGFuZCBvcHRpb25hbCBgcGFyYW1zYCwgZGVmaW5pbmcgd2hpY2ggZG9jdW1lbnQocykgdG8gcGF0Y2hcbiAgICogQHBhcmFtIG9wZXJhdGlvbnMgLSBPcHRpb25hbCBvYmplY3Qgb2YgcGF0Y2ggb3BlcmF0aW9ucyB0byBpbml0aWFsaXplIHRoZSBwYXRjaCBpbnN0YW5jZSB3aXRoXG4gICAqIEByZXR1cm5zIFBhdGNoIGluc3RhbmNlIC0gY2FsbCBgLmNvbW1pdCgpYCB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb25zIGRlZmluZWRcbiAgICovXG4gIHBhdGNoKGRvY3VtZW50SWQsIG9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhdGNoKGRvY3VtZW50SWQsIG9wZXJhdGlvbnMsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNhY3Rpb24gb2YgbXV0YXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb25zIC0gT3B0aW9uYWwgYXJyYXkgb2YgbXV0YXRpb24gb3BlcmF0aW9ucyB0byBpbml0aWFsaXplIHRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSB3aXRoXG4gICAqL1xuICB0cmFuc2FjdGlvbihvcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbihvcGVyYXRpb25zLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBhY3Rpb24gb3BlcmF0aW9ucyBhZ2FpbnN0IHRoZSBjb25maWd1cmVkIGRhdGFzZXRcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gcmVzdWx0XG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb25zIC0gQWN0aW9uIG9wZXJhdGlvbihzKSB0byBleGVjdXRlXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQWN0aW9uIG9wdGlvbnNcbiAgICovXG4gIGFjdGlvbihvcGVyYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX2FjdGlvbih0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgb3BlcmF0aW9ucywgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgcmVxdWVzdCBhZ2FpbnN0IHRoZSBTYW5pdHkgQVBJXG4gICAqIE5PVEU6IE9ubHkgdXNlIHRoaXMgZm9yIFNhbml0eSBBUEkgZW5kcG9pbnRzLCBub3QgZm9yIHlvdXIgb3duIEFQSXMhXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByZXNwb25zZSBib2R5XG4gICAqL1xuICByZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfcmVxdWVzdCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIEhUVFAgcmVxdWVzdCBhIGAvZGF0YWAgc3ViLWVuZHBvaW50XG4gICAqIE5PVEU6IENvbnNpZGVyZWQgaW50ZXJuYWwsIHRodXMgbWFya2VkIGFzIGRlcHJlY2F0ZWQuIFVzZSBgcmVxdWVzdGAgaW5zdGVhZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgLSBVc2UgYHJlcXVlc3QoKWAgb3IgeW91ciBvd24gSFRUUCBsaWJyYXJ5IGluc3RlYWRcbiAgICogQHBhcmFtIGVuZHBvaW50IC0gRW5kcG9pbnQgdG8gaGl0IChtdXRhdGUsIHF1ZXJ5IGV0YylcbiAgICogQHBhcmFtIGJvZHkgLSBSZXF1ZXN0IGJvZHlcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnNcbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYXRhUmVxdWVzdChlbmRwb2ludCwgYm9keSwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9kYXRhUmVxdWVzdCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgZW5kcG9pbnQsIGJvZHksIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgU2FuaXR5IEFQSSBVUkwgZm9yIHRoZSBVUkkgcHJvdmlkZWRcbiAgICpcbiAgICogQHBhcmFtIHVyaSAtIFVSSS9wYXRoIHRvIGJ1aWxkIFVSTCBmb3JcbiAgICogQHBhcmFtIGNhblVzZUNkbiAtIFdoZXRoZXIgb3Igbm90IHRvIGFsbG93IHVzaW5nIHRoZSBBUEkgQ0ROIGZvciB0aGlzIHJvdXRlXG4gICAqL1xuICBnZXRVcmwodXJpLCBjYW5Vc2VDZG4pIHtcbiAgICByZXR1cm4gX2dldFVybCh0aGlzLCB1cmksIGNhblVzZUNkbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIFNhbml0eSBBUEkgVVJMIGZvciB0aGUgZGF0YSBvcGVyYXRpb24gYW5kIHBhdGggcHJvdmlkZWRcbiAgICpcbiAgICogQHBhcmFtIG9wZXJhdGlvbiAtIERhdGEgb3BlcmF0aW9uIChlZyBgcXVlcnlgLCBgbXV0YXRlYCwgYGxpc3RlbmAgb3Igc2ltaWxhcilcbiAgICogQHBhcmFtIHBhdGggLSBQYXRoIHRvIGFwcGVuZCBhZnRlciB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBnZXREYXRhVXJsKG9wZXJhdGlvbiwgcGF0aCkge1xuICAgIHJldHVybiBfZ2V0RGF0YVVybCh0aGlzLCBvcGVyYXRpb24sIHBhdGgpO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVDcmVhdGVDbGllbnRFeHBvcnRzKGVudk1pZGRsZXdhcmUsIENsYXNzQ29uc3RydWN0b3IpIHtcbiAgY29uc3QgZGVmYXVsdFJlcXVlc3RlciA9IGRlZmluZUh0dHBSZXF1ZXN0KGVudk1pZGRsZXdhcmUpO1xuICByZXR1cm4geyByZXF1ZXN0ZXI6IGRlZmF1bHRSZXF1ZXN0ZXIsIGNyZWF0ZUNsaWVudDogKGNvbmZpZykgPT4gbmV3IENsYXNzQ29uc3RydWN0b3IoXG4gICAgKG9wdGlvbnMsIHJlcXVlc3RlcjIpID0+IChyZXF1ZXN0ZXIyIHx8IGRlZmF1bHRSZXF1ZXN0ZXIpKHtcbiAgICAgIG1heFJlZGlyZWN0czogMCxcbiAgICAgIG1heFJldHJpZXM6IGNvbmZpZy5tYXhSZXRyaWVzLFxuICAgICAgcmV0cnlEZWxheTogY29uZmlnLnJldHJ5RGVsYXksXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSksXG4gICAgY29uZmlnXG4gICkgfTtcbn1cbmZ1bmN0aW9uIGRlZmluZURlcHJlY2F0ZWRDcmVhdGVDbGllbnQoY3JlYXRlQ2xpZW50Mikge1xuICByZXR1cm4gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgcmV0dXJuIHByaW50Tm9EZWZhdWx0RXhwb3J0KCksIGNyZWF0ZUNsaWVudDIoY29uZmlnKTtcbiAgfTtcbn1cbnZhciBuYW1lID0gXCJAc2FuaXR5L2NsaWVudFwiLCB2ZXJzaW9uID0gXCI2LjI0LjFcIjtcbmNvbnN0IG1pZGRsZXdhcmUgPSBbXG4gIGRlYnVnKHsgdmVyYm9zZTogITAsIG5hbWVzcGFjZTogXCJzYW5pdHk6Y2xpZW50XCIgfSksXG4gIGhlYWRlcnMoeyBcIlVzZXItQWdlbnRcIjogYCR7bmFtZX0gJHt2ZXJzaW9ufWAgfSksXG4gIC8vIEVuYWJsZSBrZWVwLWFsaXZlLCBhbmQgaW4gYWRkaXRpb24gbGltaXQgdGhlIG51bWJlciBvZiBzb2NrZXRzIHRoYXQgY2FuIGJlIG9wZW5lZC5cbiAgLy8gVGhpcyBhdm9pZHMgb3BlbmluZyB0b28gbWFueSBjb25uZWN0aW9ucyB0byB0aGUgc2VydmVyIGlmIHNvbWVvbmUgdHJpZXMgdG8gZXhlY3V0ZVxuICAvLyBhIGJ1bmNoIG9mIHJlcXVlc3RzIGluIHBhcmFsbGVsLiBJdCdzIHJlY29tbWVuZGVkIHRvIGhhdmUgYSBjb25jdXJyZW5jeSBsaW1pdFxuICAvLyBhdCBhIFwiaGlnaGVyIGxpbWl0XCIgKGkuZS4geW91IHNob3VsZG4ndCBhY3R1YWxseSBleGVjdXRlIGh1bmRyZWRzIG9mIHJlcXVlc3RzIGluIHBhcmFsbGVsKSxcbiAgLy8gYW5kIHRoaXMgaXMgbWFpbmx5IHRvIG1pbmltaXplIHRoZSBpbXBhY3QgZm9yIHRoZSBuZXR3b3JrIGFuZCBzZXJ2ZXIuXG4gIC8vXG4gIC8vIFdlJ3JlIGN1cnJlbnRseSBtYXRjaGluZyB0aGUgc2FtZSBkZWZhdWx0cyBhcyBicm93c2VyczpcbiAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjYwMDM3NTYvaXMtdGhlcmUtYS1saW1pdC1wcmFjdGljYWwtb3Itb3RoZXJ3aXNlLXRvLXRoZS1udW1iZXItb2Ytd2ViLXNvY2tldHMtYS1wYWdlLW9wXG4gIGFnZW50KHtcbiAgICBrZWVwQWxpdmU6ICEwLFxuICAgIG1heFNvY2tldHM6IDMwLFxuICAgIG1heFRvdGFsU29ja2V0czogMjU2XG4gIH0pXG5dLCBleHAgPSBkZWZpbmVDcmVhdGVDbGllbnRFeHBvcnRzKG1pZGRsZXdhcmUsIFNhbml0eUNsaWVudCksIHJlcXVlc3RlciA9IGV4cC5yZXF1ZXN0ZXIsIGNyZWF0ZUNsaWVudCA9IGV4cC5jcmVhdGVDbGllbnQsIGRlcHJlY2F0ZWRDcmVhdGVDbGllbnQgPSBkZWZpbmVEZXByZWNhdGVkQ3JlYXRlQ2xpZW50KGNyZWF0ZUNsaWVudCk7XG5leHBvcnQge1xuICBCYXNlUGF0Y2gsXG4gIEJhc2VUcmFuc2FjdGlvbixcbiAgQ2xpZW50RXJyb3IsXG4gIENvcnNPcmlnaW5FcnJvcixcbiAgT2JzZXJ2YWJsZVBhdGNoLFxuICBPYnNlcnZhYmxlU2FuaXR5Q2xpZW50LFxuICBPYnNlcnZhYmxlVHJhbnNhY3Rpb24sXG4gIFBhdGNoLFxuICBTYW5pdHlDbGllbnQsXG4gIFNlcnZlckVycm9yLFxuICBUcmFuc2FjdGlvbixcbiAgY3JlYXRlQ2xpZW50LFxuICBkZXByZWNhdGVkQ3JlYXRlQ2xpZW50IGFzIGRlZmF1bHQsXG4gIHJlcXVlc3RlcixcbiAgYWRhcHRlciBhcyB1bnN0YWJsZV9fYWRhcHRlcixcbiAgZW52aXJvbm1lbnQgYXMgdW5zdGFibGVfX2Vudmlyb25tZW50LFxuICB2YWxpZGF0ZUFwaVBlcnNwZWN0aXZlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/client/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/comlink/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@sanity/comlink/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOMAIN: () => (/* binding */ DOMAIN),\n/* harmony export */   FETCH_TIMEOUT_DEFAULT: () => (/* binding */ FETCH_TIMEOUT_DEFAULT),\n/* harmony export */   HANDSHAKE_INTERVAL: () => (/* binding */ HANDSHAKE_INTERVAL),\n/* harmony export */   HANDSHAKE_MSG_TYPES: () => (/* binding */ HANDSHAKE_MSG_TYPES),\n/* harmony export */   HEARTBEAT_INTERVAL: () => (/* binding */ HEARTBEAT_INTERVAL),\n/* harmony export */   INTERNAL_MSG_TYPES: () => (/* binding */ INTERNAL_MSG_TYPES),\n/* harmony export */   MSG_DISCONNECT: () => (/* binding */ MSG_DISCONNECT),\n/* harmony export */   MSG_HANDSHAKE_ACK: () => (/* binding */ MSG_HANDSHAKE_ACK),\n/* harmony export */   MSG_HANDSHAKE_SYN: () => (/* binding */ MSG_HANDSHAKE_SYN),\n/* harmony export */   MSG_HANDSHAKE_SYN_ACK: () => (/* binding */ MSG_HANDSHAKE_SYN_ACK),\n/* harmony export */   MSG_HEARTBEAT: () => (/* binding */ MSG_HEARTBEAT),\n/* harmony export */   MSG_RESPONSE: () => (/* binding */ MSG_RESPONSE),\n/* harmony export */   RESPONSE_TIMEOUT_DEFAULT: () => (/* binding */ RESPONSE_TIMEOUT_DEFAULT),\n/* harmony export */   createConnection: () => (/* binding */ createConnection),\n/* harmony export */   createConnectionMachine: () => (/* binding */ createConnectionMachine),\n/* harmony export */   createController: () => (/* binding */ createController),\n/* harmony export */   createListenLogic: () => (/* binding */ createListenLogic),\n/* harmony export */   createNode: () => (/* binding */ createNode),\n/* harmony export */   createNodeMachine: () => (/* binding */ createNodeMachine),\n/* harmony export */   createRequestMachine: () => (/* binding */ createRequestMachine)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/@sanity/comlink/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/log-0acd9069.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/defer.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/map.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/util/pipe.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/filter.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/concatMap.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/take.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/empty.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js\");\n\n\n\nconst listenInputFromContext = (config) => ({\n  context\n}) => {\n  const { count, include, exclude, responseType = \"message.received\" } = config;\n  return {\n    count,\n    domain: context.domain,\n    from: context.connectTo,\n    include: include ? Array.isArray(include) ? include : [include] : [],\n    exclude: exclude ? Array.isArray(exclude) ? exclude : [exclude] : [],\n    responseType,\n    target: context.target,\n    to: context.name\n  };\n}, listenFilter = (input) => (event) => {\n  const { data } = event;\n  return (input.include.length ? input.include.includes(data.type) : !0) && (input.exclude.length ? !input.exclude.includes(data.type) : !0) && data.domain === input.domain && data.from === input.from && data.to === input.to && (!input.target || event.source === input.target);\n}, eventToMessage = (type) => (event) => ({\n  type,\n  message: event\n}), messageEvents$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.defer)(\n  () => (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(window, \"message\")\n), createListenLogic = (compatMap) => (0,xstate__WEBPACK_IMPORTED_MODULE_2__.fromEventObservable)(({ input }) => messageEvents$.pipe(\n  compatMap ? (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.map)(compatMap) : (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.pipe)(),\n  (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.filter)(listenFilter(input)),\n  (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.map)(eventToMessage(input.responseType)),\n  input.count ? (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.pipe)(\n    (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.bufferCount)(input.count),\n    (0,rxjs__WEBPACK_IMPORTED_MODULE_7__.concatMap)((arr) => arr),\n    (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.take)(input.count)\n  ) : (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.pipe)()\n)), DOMAIN = \"sanity/comlink\", RESPONSE_TIMEOUT_DEFAULT = 3e3, FETCH_TIMEOUT_DEFAULT = 1e4, HEARTBEAT_INTERVAL = 1e3, HANDSHAKE_INTERVAL = 500, MSG_RESPONSE = \"comlink/response\", MSG_HEARTBEAT = \"comlink/heartbeat\", MSG_DISCONNECT = \"comlink/disconnect\", MSG_HANDSHAKE_SYN = \"comlink/handshake/syn\", MSG_HANDSHAKE_SYN_ACK = \"comlink/handshake/syn-ack\", MSG_HANDSHAKE_ACK = \"comlink/handshake/ack\", HANDSHAKE_MSG_TYPES = [\n  MSG_HANDSHAKE_SYN,\n  MSG_HANDSHAKE_SYN_ACK,\n  MSG_HANDSHAKE_ACK\n], INTERNAL_MSG_TYPES = [\n  MSG_RESPONSE,\n  MSG_DISCONNECT,\n  MSG_HEARTBEAT,\n  ...HANDSHAKE_MSG_TYPES\n], throwOnEvent = (message) => (source) => source.pipe(\n  (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.take)(1),\n  (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.map)(() => {\n    throw new Error(message);\n  })\n), createRequestMachine = () => (0,xstate__WEBPACK_IMPORTED_MODULE_9__.setup)({\n  types: {},\n  actors: {\n    listen: (0,xstate__WEBPACK_IMPORTED_MODULE_2__.fromEventObservable)(\n      ({\n        input\n      }) => {\n        const abortSignal$ = input.signal ? (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(input.signal, \"abort\").pipe(\n          throwOnEvent(`Request ${input.requestId} aborted`)\n        ) : rxjs__WEBPACK_IMPORTED_MODULE_10__.EMPTY, messageFilter = (event) => event.data?.type === MSG_RESPONSE && event.data?.responseTo === input.requestId && !!event.source && input.sources.has(event.source);\n        return (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(window, \"message\").pipe(\n          (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.filter)(messageFilter),\n          (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.take)(input.sources.size),\n          (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.takeUntil)(abortSignal$)\n        );\n      }\n    )\n  },\n  actions: {\n    \"send message\": ({ context }, params) => {\n      const { sources, targetOrigin } = context, { message } = params;\n      sources.forEach((source) => {\n        source.postMessage(message, { targetOrigin });\n      });\n    },\n    \"on success\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.c)(\n      ({ context }) => context.parentRef,\n      ({ context, self }) => (context.response && context.resolvable?.resolve(context.response), {\n        type: \"request.success\",\n        requestId: self.id,\n        response: context.response,\n        responseTo: context.responseTo\n      })\n    ),\n    \"on fail\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.c)(\n      ({ context }) => context.parentRef,\n      ({ context, self }) => (context.suppressWarnings || console.warn(\n        `[@sanity/comlink] Received no response to message '${context.type}' on client '${context.from}' (ID: '${context.id}').`\n      ), context.resolvable?.reject(new Error(\"No response received\")), { type: \"request.failed\", requestId: self.id })\n    ),\n    \"on abort\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.c)(\n      ({ context }) => context.parentRef,\n      ({ context, self }) => (context.resolvable?.reject(new Error(\"Request aborted\")), { type: \"request.aborted\", requestId: self.id })\n    )\n  },\n  guards: {\n    expectsResponse: ({ context }) => context.expectResponse\n  },\n  delays: {\n    initialTimeout: 0,\n    responseTimeout: ({ context }) => context.responseTimeout ?? RESPONSE_TIMEOUT_DEFAULT\n  }\n}).createMachine({\n  /** @xstate-layout N4IgpgJg5mDOIC5QAoC2BDAxgCwJYDswBKAOlwgBswBiAD1gBd0GwT0AzFgJ2QNwdzoKAFVyowAewCuDItTRY8hUuSoBtAAwBdRKAAOE2P1wT8ukLUQBGAEwBWEgBYAnK+eOAzB7sB2DzY8rABoQAE9rDQc3V0cNTw8fAA4NHwBfVJCFHAJiElgwfAgCKGpNHSQQAyMBU3NLBDsrDxI7DTaAjQA2OOcNDxDwhHsNJx9Ou0TOq2cJxP9HdMyMbOU8gqL8ErUrcv1DY1qK+sbm1vaPLp6+gcRnGydo9wDGycWQLKVc9AB3dGNN6jiWCwdAwMrmKoHMxHRCJRKOEiJHwuZKBZwXKzBMKIGyYkhtAkXOweTqOHw2RJvD45Ug-P4CAH0JgsNicMA8LhwAz4fKicTSWTyZafWm-f5QcEVSE1aGgepwhFIlF9aYYrGDC4+JzEppjGzOUkeGbpDIgfASCBwczU5QQ-YyuqIAC0nRuCBd+IJXu9KSpwppZEoYDt1RMsosiEcNjdVjiJEeGisiSTHkcVgWpptuXyhWKIahjqGzi1BqRJINnVcdkcbuTLS9VYC8ISfsUAbp4vzDphCHJIyjBvJNlxNmRNexQ3sJGH43GPj8jWJrZWuXYfyoEC7YcLsbrgRsjkcvkmdgNbopVhIPhVfnsh8ClMz-tWsCkmEwcHgUvt257u8v+6Hse4xnhOdZnImVidPqCRNB4JqpEAA */\n  context: ({ input }) => ({\n    channelId: input.channelId,\n    data: input.data,\n    domain: input.domain,\n    expectResponse: input.expectResponse ?? !1,\n    from: input.from,\n    id: `msg-${(0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()}`,\n    parentRef: input.parentRef,\n    resolvable: input.resolvable,\n    response: null,\n    responseTimeout: input.responseTimeout,\n    responseTo: input.responseTo,\n    signal: input.signal,\n    sources: input.sources instanceof Set ? input.sources : /* @__PURE__ */ new Set([input.sources]),\n    suppressWarnings: input.suppressWarnings,\n    targetOrigin: input.targetOrigin,\n    to: input.to,\n    type: input.type\n  }),\n  initial: \"idle\",\n  on: {\n    abort: \".aborted\"\n  },\n  states: {\n    idle: {\n      after: {\n        initialTimeout: [\n          {\n            target: \"sending\"\n          }\n        ]\n      }\n    },\n    sending: {\n      entry: {\n        type: \"send message\",\n        params: ({ context }) => {\n          const { channelId, data, domain, from, id, responseTo, to, type } = context;\n          return { message: {\n            channelId,\n            data,\n            domain,\n            from,\n            id,\n            to,\n            type,\n            responseTo\n          } };\n        }\n      },\n      always: [\n        {\n          guard: \"expectsResponse\",\n          target: \"awaiting\"\n        },\n        \"success\"\n      ]\n    },\n    awaiting: {\n      invoke: {\n        id: \"listen for response\",\n        src: \"listen\",\n        input: ({ context }) => ({\n          requestId: context.id,\n          sources: context.sources,\n          signal: context.signal\n        }),\n        onError: \"aborted\"\n      },\n      after: {\n        responseTimeout: \"failed\"\n      },\n      on: {\n        message: {\n          actions: (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n            response: ({ event }) => event.data.data,\n            responseTo: ({ event }) => event.data.responseTo\n          }),\n          target: \"success\"\n        }\n      }\n    },\n    failed: {\n      type: \"final\",\n      entry: \"on fail\"\n    },\n    success: {\n      type: \"final\",\n      entry: \"on success\"\n    },\n    aborted: {\n      type: \"final\",\n      entry: \"on abort\"\n    }\n  },\n  output: ({ context, self }) => ({\n    requestId: self.id,\n    response: context.response,\n    responseTo: context.responseTo\n  })\n}), sendBackAtInterval = (0,xstate__WEBPACK_IMPORTED_MODULE_2__.fromCallback)(({ sendBack, input }) => {\n  const send = () => {\n    sendBack(input.event);\n  };\n  input.immediate && send();\n  const interval = setInterval(send, input.interval);\n  return () => {\n    clearInterval(interval);\n  };\n}), createConnectionMachine = () => (0,xstate__WEBPACK_IMPORTED_MODULE_9__.setup)({\n  types: {},\n  actors: {\n    requestMachine: createRequestMachine(),\n    listen: createListenLogic(),\n    sendBackAtInterval\n  },\n  actions: {\n    \"buffer message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ enqueue }) => {\n      enqueue.assign({\n        buffer: ({ event, context }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), [...context.buffer, event.data])\n      }), enqueue.emit(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), {\n        type: \"_buffer.added\",\n        message: event.data\n      }));\n    }),\n    \"create request\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n      requests: ({ context, event, self, spawn }) => {\n        (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"request\");\n        const requests = (Array.isArray(event.data) ? event.data : [event.data]).map((request) => {\n          const id = `req-${(0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()}`;\n          return spawn(\"requestMachine\", {\n            id,\n            input: {\n              channelId: context.channelId,\n              data: request.data,\n              domain: context.domain,\n              expectResponse: request.expectResponse,\n              from: context.name,\n              parentRef: self,\n              responseTo: request.responseTo,\n              sources: context.target,\n              targetOrigin: context.targetOrigin,\n              to: context.connectTo,\n              type: request.type\n            }\n          });\n        });\n        return [...context.requests, ...requests];\n      }\n    }),\n    \"emit received message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ enqueue }) => {\n      enqueue.emit(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), {\n        type: \"_message\",\n        message: event.message.data\n      })), enqueue.emit(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), {\n        type: event.message.data.type,\n        message: event.message.data\n      }));\n    }),\n    \"emit status\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.e)((_, params) => ({\n      type: \"_status\",\n      status: params.status\n    })),\n    \"flush buffer\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ enqueue }) => {\n      enqueue.raise(({ context }) => ({\n        type: \"request\",\n        data: context.buffer.map(({ data, type }) => ({ data, type }))\n      })), enqueue.emit(({ context }) => ({\n        type: \"_buffer.flushed\",\n        messages: context.buffer\n      })), enqueue.assign({\n        buffer: []\n      });\n    }),\n    post: (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), {\n      type: \"request\",\n      data: {\n        data: event.data.data,\n        expectResponse: !0,\n        type: event.data.type\n      }\n    })),\n    \"remove request\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ context, enqueue, event }) => {\n      (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, [\"request.success\", \"request.failed\", \"request.aborted\"]), (0,xstate__WEBPACK_IMPORTED_MODULE_14__.R)(event.requestId), enqueue.assign({ requests: context.requests.filter(({ id }) => id !== event.requestId) });\n    }),\n    respond: (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"response\"), {\n      type: \"request\",\n      data: {\n        data: event.data,\n        type: MSG_RESPONSE,\n        responseTo: event.respondTo\n      }\n    })),\n    \"send handshake ack\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)({\n      type: \"request\",\n      data: { type: MSG_HANDSHAKE_ACK }\n    }),\n    \"send disconnect\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)(() => ({\n      type: \"request\",\n      data: { type: MSG_DISCONNECT }\n    })),\n    \"send handshake syn\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)({\n      type: \"request\",\n      data: { type: MSG_HANDSHAKE_SYN }\n    }),\n    \"set target\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n      target: ({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"target.set\"), event.target)\n    })\n  },\n  guards: {\n    \"has target\": ({ context }) => !!context.target,\n    \"should send heartbeats\": ({ context }) => context.heartbeat\n  }\n}).createMachine({\n  /** @xstate-layout N4IgpgJg5mDOIC5QGMAWBDAdpsAbAxAC7oBOMhAdLGIQNoAMAuoqAA4D2sAloV+5ixAAPRAHZRAJgoAWABz0ArHICMy2QGZZCgJwAaEAE9EE+tIrb6ANgkLl46fTuj1AXxf60WHARJgAjgCucJSwAcjIcLAMzEggHNy8-IIiCKLS2hQS6qb2yurisrL6RgjK9LIyCuqq0g7WstZuHhjYePi+gcEUAGboXLiQ0YLxPHwCsSmiCgoykpayDtqS6trqxYjKEk0gnq24FFwQA-jI-DjIdEzDnKNJExuOZpZ12eq29OrSCuupypYUojUaTKCnm5Wk2123gORzA+HilxibBuiXGoBSGnUAIU4gU9FWamUtR+lmUM1EllBEkslMUEnpkJa0JaEFgGAA1lxMFB8LADJghrERqjkhtshk3mTtNo5OpqpYfqCKhTptoqpY1WUtu4dky8BQWWz0Jzue1-EFYIjrgkxqLSupqRRPpoPqJtLI0hIioZENJJE7NnJ8ZYHVk1YyvPrDRyuTyEYLkTa7uixVlMh81KGFhS1j6EPkZlpVjTphr8mkI3sDVhWTHTQBbSLoGAUXwRLgAN0GVyFKNt91KimUFEKXvKC2s9R+6X+jipnzJeSqEJ1UKjNaNJp5EC4sFOrQuCbifeTwg2cgoym0RPxDtqkj0eaB9Ao8zSolMEivZVcq71+33c5CEgeFOCtXskzRM8EDxKRpmkSw3QJbQsmpH5tHmV8JHSbJpDsakV2aSMALOMALhAjoLXAxNbiglI-SxWw1Vw0QNDw0Qfg9KQ7EJSxHHxApK2hQCyOAiAzVgDhMGoI9hX7FMEHSF8cWkelpHURCbBsb481xAEgT9BQJCmWQsiE-URPI8TG1gWBmzAVsyLATtuyRY9ILtWoKmlL82Kqd0tAVJ91LMHFZDKIkVlkNVZHMkiDzE-Adz3UjDx7GiRQHCKnheD53k+HSSkDDIwpBVTqQwuKKEssSDTAUhCAAI3qyg0DIrd8Fkk86MQUMnVM+RynoegTDJH48hGp0vR-FDRqqKqasgOqGua9AQjATAd1NSiul6fpXOtWi7Wy19cslD4vnG7IX3oVjVDUVYEJQqrksW8SdstLqPKy0wKgG1RhtMWogqKhoMjkWp6XxUyFBe3c3tAz70vco6fq+V8PTkGUFzdQqNnELEM2yClrwwzQ4ZShKQJqr7UYU98AS0W9pT4z5pHG0yXwMkNNTyGk3B1TB2AgOBBDXXBDsyhSFG9EovQqN5i1JeRcKqw4Bkl+ToMx8x0j+EaqQ9XMSkBURMgMkEwQWKro2NWNNdPFJAzN0lJGM4slDxhBEJfXyplBd03wW1KxIdnrBxBh4JAyW75C8rJpmDqmIGWkgmpasPjqUcaHooMLHA0uU1UkJOgKW1B6rT1bWor5At0zgcTAkK7hrz1irB0D8cW0UvRPLyv07WqgNq2qAG+l9SnXUz0UOXD5xuMs3Y4+DVJBX7UiKrV6Q8gcfoJO54rFefLLqfJYX1WKYNLxL4NO1NwgA */\n  id: \"connection\",\n  context: ({ input }) => ({\n    id: input.id || `${input.name}-${(0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()}`,\n    buffer: [],\n    channelId: `chn-${(0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()}`,\n    connectTo: input.connectTo,\n    domain: input.domain ?? DOMAIN,\n    heartbeat: input.heartbeat ?? !1,\n    name: input.name,\n    requests: [],\n    target: input.target,\n    targetOrigin: input.targetOrigin\n  }),\n  on: {\n    \"target.set\": {\n      actions: \"set target\"\n    },\n    \"request.success\": {\n      actions: \"remove request\"\n    },\n    \"request.failed\": {\n      actions: \"remove request\"\n    }\n  },\n  initial: \"idle\",\n  states: {\n    idle: {\n      entry: [{ type: \"emit status\", params: { status: \"idle\" } }],\n      on: {\n        connect: {\n          target: \"handshaking\",\n          guard: \"has target\"\n        },\n        post: {\n          actions: \"buffer message\"\n        }\n      }\n    },\n    handshaking: {\n      id: \"handshaking\",\n      entry: [{ type: \"emit status\", params: { status: \"handshaking\" } }],\n      invoke: [\n        {\n          id: \"send syn\",\n          src: \"sendBackAtInterval\",\n          input: () => ({\n            event: { type: \"syn\" },\n            interval: HANDSHAKE_INTERVAL,\n            immediate: !0\n          })\n        },\n        {\n          id: \"listen for handshake\",\n          src: \"listen\",\n          input: (input) => listenInputFromContext({\n            include: MSG_HANDSHAKE_SYN_ACK,\n            count: 1\n          })(input)\n          /* Below would maybe be more readable than transitioning to\n          'connected' on 'message', and 'ack' on exit but having onDone when\n          using passing invocations currently breaks XState Editor */\n          // onDone: {\n          //   target: 'connected',\n          //   actions: 'ack',\n          // },\n        }\n      ],\n      on: {\n        syn: {\n          actions: \"send handshake syn\"\n        },\n        request: {\n          actions: \"create request\"\n        },\n        post: {\n          actions: \"buffer message\"\n        },\n        \"message.received\": {\n          target: \"connected\"\n        },\n        disconnect: {\n          target: \"disconnected\"\n        }\n      },\n      exit: \"send handshake ack\"\n    },\n    connected: {\n      entry: [\"flush buffer\", { type: \"emit status\", params: { status: \"connected\" } }],\n      invoke: {\n        id: \"listen for messages\",\n        src: \"listen\",\n        input: listenInputFromContext({\n          exclude: [MSG_RESPONSE, MSG_HEARTBEAT]\n        })\n      },\n      on: {\n        post: {\n          actions: \"post\"\n        },\n        request: {\n          actions: \"create request\"\n        },\n        response: {\n          actions: \"respond\"\n        },\n        \"message.received\": {\n          actions: \"emit received message\"\n        },\n        disconnect: {\n          target: \"disconnected\"\n        }\n      },\n      initial: \"heartbeat\",\n      states: {\n        heartbeat: {\n          initial: \"checking\",\n          states: {\n            checking: {\n              always: {\n                guard: \"should send heartbeats\",\n                target: \"sending\"\n              }\n            },\n            sending: {\n              on: {\n                \"request.failed\": {\n                  target: \"#handshaking\"\n                }\n              },\n              invoke: {\n                id: \"send heartbeat\",\n                src: \"sendBackAtInterval\",\n                input: () => ({\n                  event: { type: \"post\", data: { type: MSG_HEARTBEAT, data: void 0 } },\n                  interval: 2e3,\n                  immediate: !1\n                })\n              }\n            }\n          }\n        }\n      }\n    },\n    disconnected: {\n      id: \"disconnected\",\n      entry: [\"send disconnect\", { type: \"emit status\", params: { status: \"disconnected\" } }],\n      on: {\n        request: {\n          actions: \"create request\"\n        },\n        post: {\n          actions: \"buffer message\"\n        },\n        connect: {\n          target: \"handshaking\",\n          guard: \"has target\"\n        }\n      }\n    }\n  }\n}), createConnection = (input, machine = createConnectionMachine()) => {\n  const id = input.id || `${input.name}-${(0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()}`, actor = (0,xstate__WEBPACK_IMPORTED_MODULE_14__.A)(machine, {\n    input: { ...input, id }\n  }), on = (type, handler) => {\n    const { unsubscribe } = actor.on(\n      // @ts-expect-error @todo `type` typing\n      type,\n      async (event) => {\n        const response = await handler(event.message.data);\n        response && actor.send({ type: \"response\", respondTo: event.message.id, data: response });\n      }\n    );\n    return unsubscribe;\n  }, connect = () => {\n    actor.send({ type: \"connect\" });\n  }, disconnect = () => {\n    actor.send({ type: \"disconnect\" });\n  }, onStatus = (handler, filter2) => {\n    const { unsubscribe } = actor.on(\n      // @ts-expect-error @todo ReceivedEmitEvent causes this\n      \"_status\",\n      (event) => {\n        filter2 && event.status !== filter2 || handler(event.status);\n      }\n    );\n    return unsubscribe;\n  }, setTarget = (target) => {\n    actor.send({ type: \"target.set\", target });\n  }, post = (type, data) => {\n    const _data = { type, data };\n    actor.send({ type: \"post\", data: _data });\n  }, stop = () => {\n    actor.stop();\n  }, start = () => (actor.start(), stop);\n  return {\n    actor,\n    connect,\n    disconnect,\n    id,\n    name: input.name,\n    machine,\n    on,\n    onStatus,\n    post,\n    setTarget,\n    start,\n    stop,\n    get target() {\n      return actor.getSnapshot().context.target;\n    }\n  };\n}, cleanupConnection = (connection) => {\n  connection.disconnect(), setTimeout(() => {\n    connection.stop();\n  }, 0);\n}, noop = () => {\n}, createController = (input) => {\n  const { targetOrigin } = input, targets = /* @__PURE__ */ new Set(), channels = /* @__PURE__ */ new Set();\n  return {\n    addTarget: (target) => {\n      if (targets.has(target))\n        return noop;\n      if (!targets.size || !channels.size)\n        return targets.add(target), channels.forEach((channel) => {\n          channel.connections.forEach((connection) => {\n            connection.setTarget(target), connection.connect();\n          });\n        }), () => {\n          targets.delete(target), channels.forEach((channel) => {\n            channel.connections.forEach((connection) => {\n              connection.target === target && connection.disconnect();\n            });\n          });\n        };\n      targets.add(target);\n      const targetConnections = /* @__PURE__ */ new Set();\n      return channels.forEach((channel) => {\n        const connection = createConnection(\n          {\n            ...channel.input,\n            target,\n            targetOrigin\n          },\n          channel.machine\n        );\n        targetConnections.add(connection), channel.connections.add(connection), channel.subscribers.forEach(({ type, handler, unsubscribers }) => {\n          unsubscribers.push(connection.on(type, handler));\n        }), channel.internalEventSubscribers.forEach(({ type, handler, unsubscribers }) => {\n          unsubscribers.push(connection.actor.on(type, handler).unsubscribe);\n        }), channel.statusSubscribers.forEach(({ handler, unsubscribers }) => {\n          unsubscribers.push(\n            connection.onStatus((status) => handler({ connection: connection.id, status }))\n          );\n        }), connection.start(), connection.connect();\n      }), () => {\n        targets.delete(target), targetConnections.forEach((connection) => {\n          cleanupConnection(connection), channels.forEach((channel) => {\n            channel.connections.delete(connection);\n          });\n        });\n      };\n    },\n    createChannel: (input2, machine = createConnectionMachine()) => {\n      const channel = {\n        connections: /* @__PURE__ */ new Set(),\n        input: input2,\n        internalEventSubscribers: /* @__PURE__ */ new Set(),\n        machine,\n        statusSubscribers: /* @__PURE__ */ new Set(),\n        subscribers: /* @__PURE__ */ new Set()\n      };\n      channels.add(channel);\n      const { connections, internalEventSubscribers, statusSubscribers, subscribers } = channel;\n      if (targets.size)\n        targets.forEach((target) => {\n          const connection = createConnection(\n            {\n              ...input2,\n              target,\n              targetOrigin\n            },\n            machine\n          );\n          connections.add(connection);\n        });\n      else {\n        const connection = createConnection({ ...input2, targetOrigin }, machine);\n        connections.add(connection);\n      }\n      const post = (...params) => {\n        const [type, data] = params;\n        connections.forEach((connection) => {\n          connection.post(type, data);\n        });\n      }, on = (type, handler) => {\n        const unsubscribers = [];\n        connections.forEach((connection) => {\n          unsubscribers.push(connection.on(type, handler));\n        });\n        const subscriber = { type, handler, unsubscribers };\n        return subscribers.add(subscriber), () => {\n          unsubscribers.forEach((unsub) => unsub()), subscribers.delete(subscriber);\n        };\n      }, onInternalEvent = (type, handler) => {\n        const unsubscribers = [];\n        connections.forEach((connection) => {\n          unsubscribers.push(connection.actor.on(type, handler).unsubscribe);\n        });\n        const subscriber = { type, handler, unsubscribers };\n        return internalEventSubscribers.add(subscriber), () => {\n          unsubscribers.forEach((unsub) => unsub()), internalEventSubscribers.delete(subscriber);\n        };\n      }, onStatus = (handler) => {\n        const unsubscribers = [];\n        connections.forEach((connection) => {\n          unsubscribers.push(\n            connection.onStatus((status) => handler({ connection: connection.id, status }))\n          );\n        });\n        const subscriber = { handler, unsubscribers };\n        return statusSubscribers.add(subscriber), () => {\n          unsubscribers.forEach((unsub) => unsub()), statusSubscribers.delete(subscriber);\n        };\n      }, stop = () => {\n        const connections2 = channel.connections;\n        connections2.forEach(cleanupConnection), connections2.clear(), channels.delete(channel);\n      };\n      return {\n        on,\n        onInternalEvent,\n        onStatus,\n        post,\n        start: () => (connections.forEach((connection) => {\n          connection.start(), connection.connect();\n        }), stop),\n        stop\n      };\n    },\n    destroy: () => {\n      channels.forEach(({ connections }) => {\n        connections.forEach(cleanupConnection), connections.clear();\n      }), channels.clear(), targets.clear();\n    }\n  };\n}, createNodeMachine = () => (0,xstate__WEBPACK_IMPORTED_MODULE_9__.setup)({\n  types: {},\n  actors: {\n    requestMachine: createRequestMachine(),\n    listen: createListenLogic()\n  },\n  actions: {\n    \"buffer incoming message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n      handshakeBuffer: ({ event, context }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), [...context.handshakeBuffer, event])\n    }),\n    \"buffer message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ enqueue }) => {\n      enqueue.assign({\n        buffer: ({ event, context }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), [\n          ...context.buffer,\n          {\n            data: event.data,\n            resolvable: event.resolvable,\n            options: event.options\n          }\n        ])\n      }), enqueue.emit(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), {\n        type: \"_buffer.added\",\n        message: event.data\n      }));\n    }),\n    \"create request\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n      requests: ({ context, event, self, spawn }) => {\n        (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"request\");\n        const requests = (Array.isArray(event.data) ? event.data : [event.data]).map((request) => {\n          const id = `req-${(0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()}`;\n          return spawn(\"requestMachine\", {\n            id,\n            input: {\n              channelId: context.channelId,\n              data: request.data,\n              domain: context.domain,\n              expectResponse: request.expectResponse,\n              from: context.name,\n              parentRef: self,\n              resolvable: request.resolvable,\n              responseTimeout: request.options?.responseTimeout,\n              responseTo: request.responseTo,\n              signal: request.options?.signal,\n              sources: context.target,\n              suppressWarnings: request.options?.suppressWarnings,\n              targetOrigin: context.targetOrigin,\n              to: context.connectTo,\n              type: request.type\n            }\n          });\n        });\n        return [...context.requests, ...requests];\n      }\n    }),\n    \"emit heartbeat\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.e)(() => ({\n      type: \"_heartbeat\"\n    })),\n    \"emit received message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ enqueue }) => {\n      enqueue.emit(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), {\n        type: \"_message\",\n        message: event.message.data\n      })), enqueue.emit(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), {\n        type: event.message.data.type,\n        message: event.message.data\n      }));\n    }),\n    \"emit status\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.e)((_, params) => ({\n      type: \"_status\",\n      status: params.status\n    })),\n    \"flush buffer\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ enqueue }) => {\n      enqueue.raise(({ context }) => ({\n        type: \"request\",\n        data: context.buffer.map(({ data, resolvable, options }) => ({\n          data: data.data,\n          type: data.type,\n          expectResponse: !!resolvable,\n          resolvable,\n          options\n        }))\n      })), enqueue.emit(({ context }) => ({\n        type: \"_buffer.flushed\",\n        messages: context.buffer.map(({ data }) => data)\n      })), enqueue.assign({\n        buffer: []\n      });\n    }),\n    \"flush handshake buffer\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ context, enqueue }) => {\n      context.handshakeBuffer.forEach((event) => enqueue.raise(event)), enqueue.assign({\n        handshakeBuffer: []\n      });\n    }),\n    post: (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), {\n      type: \"request\",\n      data: {\n        data: event.data.data,\n        expectResponse: !!event.resolvable,\n        type: event.data.type,\n        resolvable: event.resolvable,\n        options: event.options\n      }\n    })),\n    \"remove request\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ context, enqueue, event }) => {\n      (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, [\"request.success\", \"request.failed\", \"request.aborted\"]), (0,xstate__WEBPACK_IMPORTED_MODULE_14__.R)(event.requestId), enqueue.assign({ requests: context.requests.filter(({ id }) => id !== event.requestId) });\n    }),\n    \"send response\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, [\"message.received\", \"heartbeat.received\"]), {\n      type: \"request\",\n      data: {\n        type: MSG_RESPONSE,\n        responseTo: event.message.data.id,\n        data: void 0\n      }\n    })),\n    \"send handshake syn ack\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)({\n      type: \"request\",\n      data: { type: MSG_HANDSHAKE_SYN_ACK }\n    }),\n    \"set connection config\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n      channelId: ({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"handshake.syn\"), event.message.data.channelId),\n      target: ({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"handshake.syn\"), event.message.source || void 0),\n      targetOrigin: ({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"handshake.syn\"), event.message.origin)\n    })\n  },\n  guards: {\n    hasSource: ({ context }) => context.target !== null\n  }\n}).createMachine({\n  /** @xstate-layout N4IgpgJg5mDOIC5QDsD2EwGIBOYCOArnAC4B0sBAxpXLANoAMAuoqAA6qwCWxXqyrEAA9EAVgYAWUgEYJDUQA4JAZmUSJC0coDsAGhABPRNIYLSErdOkBOAGzbx227YUBfV-rQYc+IrDIAZgCGXAA2kIwsSCAc3Lz8giIIoiakqgBMDKbp2tYS0srp+kYI0ununuhgpFwQ4ZgQ-NVcyABuqADW1V7NdWAILe2UQfHIkZGCsTx8AtFJ6aKipAzWOtrpC7Z5BUWGiNoK6aS26RLW2tLaqkqqFSA9NX2YALa0QTCkuDRcrRHMk5xpgk5ogJLZSNZIVDoVCFLZiohbIVSLkXLZRHZDgxbHcHrV6rFiBNolNRolEVJbCsdGUzsoyhiEcllOC1DowelVmVrOUPPcqqQABZBZAQWDCjotKANJo1NqdboC4Wi8VBSXIKADeXDUbjf4kwFkkEILbg8RZMHKOzWKzKJkHJa086Xa4qZS4pUisUSqU+QgkYnsQ0zcnJaRLDbpZwKNQSBYspm2MEyC5KTnaDSSd18h7K71q32EwMxYPA0BJFLKY5yZxIrKSURM0RnFHSBTrQqQ9babQejBCr2q9XSiBcWCUfjIMCUIn6oNxEPGtTWFFR0RUy7iGzt+3Ip0XURXVZKPvVCfIKczyB+vyzqLzoGzcuIG0MGTyCztjRtjaJjbHVMNAUTdu1PUhz0vYhryLOcSwXMthBfK0ZGsLQGBZekCi0Jso1IdI23WG04zOE4wIg6coIgBox3Imdi1JRdnxNOxSHNSQkWtW0mTjMxMQ7fDzgcbNKn7WjKJeN4Pi+MAfj+e84MfUMFHbZZwxOHZNDyO09gQOQjmAhZJCM9IMjIycKOvQUwCCbBiAAI2sshpNkiB6NLJ9EIQBQbWOdJlMhYCUjbJkchXGsFmsJQMVsWl3BzKp4GiHoAXgjykgAWmkZZ6xy3LZF2EobCy6xsQWJQ42kE4FjA-EwBSxTjSRUhDgqkzgO2BxdykU4AvXFQ-KjMC8yHKV6qNJi6WOdcypcZsXGxe0JG0XySKjM5lKsMyLwsiAxsYzylDfONznUEqrmi+1ThkHqXDONbULi1wgA */\n  id: \"node\",\n  context: ({ input }) => ({\n    buffer: [],\n    channelId: null,\n    connectTo: input.connectTo,\n    domain: input.domain ?? DOMAIN,\n    handshakeBuffer: [],\n    name: input.name,\n    requests: [],\n    target: void 0,\n    targetOrigin: null\n  }),\n  // Always listen for handshake syn messages. The channel could have\n  // disconnected without being able to notify the node, and so need to\n  // re-establish the connection.\n  invoke: {\n    id: \"listen for handshake syn\",\n    src: \"listen\",\n    input: listenInputFromContext({\n      include: MSG_HANDSHAKE_SYN,\n      responseType: \"handshake.syn\"\n    })\n  },\n  on: {\n    \"request.success\": {\n      actions: \"remove request\"\n    },\n    \"request.failed\": {\n      actions: \"remove request\"\n    },\n    \"request.aborted\": {\n      actions: \"remove request\"\n    },\n    \"handshake.syn\": {\n      actions: \"set connection config\",\n      target: \".handshaking\"\n    }\n  },\n  initial: \"idle\",\n  states: {\n    idle: {\n      entry: [{ type: \"emit status\", params: { status: \"idle\" } }],\n      on: {\n        post: {\n          actions: \"buffer message\"\n        }\n      }\n    },\n    handshaking: {\n      guard: \"hasSource\",\n      entry: [\"send handshake syn ack\", { type: \"emit status\", params: { status: \"handshaking\" } }],\n      invoke: [\n        {\n          id: \"listen for handshake ack\",\n          src: \"listen\",\n          input: listenInputFromContext({\n            include: MSG_HANDSHAKE_ACK,\n            count: 1,\n            // Override the default `message.received` responseType to prevent\n            // buffering the ack message. We transition to the connected state\n            // using onDone instead of listening to this event using `on`\n            responseType: \"handshake.complete\"\n          }),\n          onDone: \"connected\"\n        },\n        {\n          id: \"listen for disconnect\",\n          src: \"listen\",\n          input: listenInputFromContext({\n            include: MSG_DISCONNECT,\n            count: 1,\n            responseType: \"disconnect\"\n          })\n        },\n        {\n          id: \"listen for messages\",\n          src: \"listen\",\n          input: listenInputFromContext({\n            exclude: [\n              MSG_DISCONNECT,\n              MSG_HANDSHAKE_SYN,\n              MSG_HANDSHAKE_ACK,\n              MSG_HEARTBEAT,\n              MSG_RESPONSE\n            ]\n          })\n        }\n      ],\n      on: {\n        request: {\n          actions: \"create request\"\n        },\n        post: {\n          actions: \"buffer message\"\n        },\n        \"message.received\": {\n          actions: \"buffer incoming message\"\n        },\n        disconnect: {\n          target: \"idle\"\n        }\n      }\n    },\n    connected: {\n      entry: [\n        \"flush handshake buffer\",\n        \"flush buffer\",\n        { type: \"emit status\", params: { status: \"connected\" } }\n      ],\n      invoke: [\n        {\n          id: \"listen for messages\",\n          src: \"listen\",\n          input: listenInputFromContext({\n            exclude: [\n              MSG_DISCONNECT,\n              MSG_HANDSHAKE_SYN,\n              MSG_HANDSHAKE_ACK,\n              MSG_HEARTBEAT,\n              MSG_RESPONSE\n            ]\n          })\n        },\n        {\n          id: \"listen for heartbeat\",\n          src: \"listen\",\n          input: listenInputFromContext({\n            include: MSG_HEARTBEAT,\n            responseType: \"heartbeat.received\"\n          })\n        },\n        {\n          id: \"listen for disconnect\",\n          src: \"listen\",\n          input: listenInputFromContext({\n            include: MSG_DISCONNECT,\n            count: 1,\n            responseType: \"disconnect\"\n          })\n        }\n      ],\n      on: {\n        request: {\n          actions: \"create request\"\n        },\n        post: {\n          actions: \"post\"\n        },\n        disconnect: {\n          target: \"idle\"\n        },\n        \"message.received\": {\n          actions: [\"send response\", \"emit received message\"]\n        },\n        \"heartbeat.received\": {\n          actions: [\"send response\", \"emit heartbeat\"]\n        }\n      }\n    }\n  }\n}), createNode = (input, machine = createNodeMachine()) => {\n  const actor = (0,xstate__WEBPACK_IMPORTED_MODULE_14__.A)(machine, {\n    input\n  }), on = (type, handler) => {\n    const { unsubscribe } = actor.on(\n      // @ts-expect-error @todo ReceivedEmitEvent causes this\n      type,\n      (event) => {\n        handler(event.message.data);\n      }\n    );\n    return unsubscribe;\n  }, onStatus = (handler, filter2) => {\n    const { unsubscribe } = actor.on(\n      // @ts-expect-error @todo ReceivedEmitEvent causes this\n      \"_status\",\n      (event) => {\n        filter2 && event.status !== filter2 || handler(event.status);\n      }\n    );\n    return unsubscribe;\n  }, post = (type, data) => {\n    const _data = { type, data };\n    actor.send({ type: \"post\", data: _data });\n  }, fetch = (type, data, options) => {\n    const { responseTimeout = FETCH_TIMEOUT_DEFAULT, signal, suppressWarnings } = options || {}, resolvable = Promise.withResolvers(), _data = { type, data };\n    return actor.send({\n      type: \"post\",\n      data: _data,\n      resolvable,\n      options: { responseTimeout, signal, suppressWarnings }\n    }), resolvable.promise;\n  }, stop = () => {\n    actor.stop();\n  };\n  return {\n    actor,\n    fetch,\n    machine,\n    on,\n    onStatus,\n    post,\n    start: () => (actor.start(), stop),\n    stop\n  };\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jb21saW5rL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDMEg7QUFDekM7QUFDM0c7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLDZEQUE2RDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLE9BQU87QUFDakI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUMsb0JBQW9CLDJDQUFLO0FBQzFCLFFBQVEsK0NBQVM7QUFDakIsc0NBQXNDLDJEQUFtQixJQUFJLE9BQU87QUFDcEUsY0FBYyx5Q0FBRyxjQUFjLDBDQUFJO0FBQ25DLEVBQUUsNENBQU07QUFDUixFQUFFLHlDQUFHO0FBQ0wsZ0JBQWdCLDBDQUFJO0FBQ3BCLElBQUksaURBQVc7QUFDZixJQUFJLCtDQUFTO0FBQ2IsSUFBSSwwQ0FBSTtBQUNSLE1BQU0sMENBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMENBQUk7QUFDTixFQUFFLHlDQUFHO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsZ0NBQWdDLDZDQUFLO0FBQ3JDLFdBQVc7QUFDWDtBQUNBLFlBQVksMkRBQW1CO0FBQy9CO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNENBQTRDLCtDQUFTO0FBQ3JELGtDQUFrQyxpQkFBaUI7QUFDbkQsWUFBWSx3Q0FBSztBQUNqQixlQUFlLCtDQUFTO0FBQ3hCLFVBQVUsNENBQU07QUFDaEIsVUFBVSwwQ0FBSTtBQUNkLFVBQVUsZ0RBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsY0FBYyx3QkFBd0IsYUFBYSxVQUFVO0FBQzdEO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQsT0FBTztBQUNQLEtBQUs7QUFDTCxrQkFBa0IsMENBQU07QUFDeEIsU0FBUyxTQUFTO0FBQ2xCLFNBQVMsZUFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGVBQWUsMENBQU07QUFDckIsU0FBUyxTQUFTO0FBQ2xCLFNBQVMsZUFBZTtBQUN4Qiw4REFBOEQsYUFBYSxlQUFlLGFBQWEsVUFBVSxXQUFXO0FBQzVILDBFQUEwRSw0Q0FBNEM7QUFDdEg7QUFDQSxnQkFBZ0IsMENBQU07QUFDdEIsU0FBUyxTQUFTO0FBQ2xCLFNBQVMsZUFBZSxrRUFBa0UsNkNBQTZDO0FBQ3ZJO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakMsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBLENBQUM7QUFDRDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBRSxHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixrQkFBa0IsMERBQTBEO0FBQzVFLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBTTtBQUN6Qix5QkFBeUIsT0FBTztBQUNoQywyQkFBMkIsT0FBTztBQUNsQyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLHdCQUF3QixvREFBWSxJQUFJLGlCQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQ0FBbUMsNkNBQUs7QUFDekMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0JBQXNCLDBDQUFjLElBQUksU0FBUztBQUNqRDtBQUNBLG1CQUFtQixnQkFBZ0IsTUFBTSxtREFBVztBQUNwRCxPQUFPLG1CQUFtQixPQUFPLE1BQU0sbURBQVc7QUFDbEQ7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsc0JBQXNCLDBDQUFNO0FBQzVCLG1CQUFtQiw2QkFBNkI7QUFDaEQsUUFBUSxtREFBVztBQUNuQjtBQUNBLDRCQUE0QixpREFBRSxHQUFHO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkIsMENBQWMsSUFBSSxTQUFTO0FBQ3hELHNCQUFzQixPQUFPLE1BQU0sbURBQVc7QUFDOUM7QUFDQTtBQUNBLE9BQU8sb0JBQW9CLE9BQU8sTUFBTSxtREFBVztBQUNuRDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxtQkFBbUIsMENBQUk7QUFDdkI7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMENBQWMsSUFBSSxTQUFTO0FBQy9DLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0Esb0NBQW9DLFlBQVksUUFBUSxZQUFZO0FBQ3BFLE9BQU8sb0JBQW9CLFNBQVM7QUFDcEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsVUFBVSwwQ0FBSyxJQUFJLE9BQU8sTUFBTSxtREFBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLDBDQUFjLElBQUkseUJBQXlCO0FBQ2pFLE1BQU0sbURBQVcsbUVBQW1FLDBDQUFTLG9DQUFvQyxxQ0FBcUMsSUFBSSw4QkFBOEI7QUFDeE0sS0FBSztBQUNMLGFBQWEsMENBQUssSUFBSSxPQUFPLE1BQU0sbURBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQiwwQ0FBSztBQUMvQjtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0wsdUJBQXVCLDBDQUFLO0FBQzVCO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCwwQkFBMEIsMENBQUs7QUFDL0I7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGtCQUFrQiwwQ0FBTTtBQUN4QixpQkFBaUIsT0FBTyxNQUFNLG1EQUFXO0FBQ3pDLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsU0FBUztBQUM5QixpQ0FBaUMsU0FBUztBQUMxQztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLHVCQUF1QixXQUFXLEdBQUcsaURBQUUsR0FBRztBQUMxQztBQUNBLHNCQUFzQixpREFBRSxHQUFHO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCLGtCQUFrQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQix5QkFBeUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0MsK0JBQStCLHVCQUF1QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCLHFDQUFxQztBQUN0RjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQywrQkFBK0IsMEJBQTBCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDRCQUE0QixXQUFXLEdBQUcsaURBQUUsR0FBRyxXQUFXLDBDQUFXO0FBQ3JFLGFBQWE7QUFDYixHQUFHO0FBQ0gsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtEQUErRDtBQUNoRztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLGlCQUFpQjtBQUNsQyxHQUFHO0FBQ0gsaUJBQWlCLG9CQUFvQjtBQUNyQyxHQUFHO0FBQ0gsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlCQUFpQiw0QkFBNEI7QUFDN0MsR0FBRztBQUNILG9CQUFvQjtBQUNwQixpQkFBaUIsMkJBQTJCO0FBQzVDLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELENBQUM7QUFDRCxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLCtHQUErRyw4QkFBOEI7QUFDN0k7QUFDQSxTQUFTLCtDQUErQyw4QkFBOEI7QUFDdEY7QUFDQSxTQUFTLHdDQUF3Qyx3QkFBd0I7QUFDekU7QUFDQSxzREFBc0QsbUNBQW1DO0FBQ3pGO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3RUFBd0U7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQ0FBbUM7QUFDekY7QUFDQSxTQUFTO0FBQ1QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUMsNEJBQTRCLDZDQUFLO0FBQ2xDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwrQkFBK0IsMENBQU07QUFDckMsMEJBQTBCLGdCQUFnQixNQUFNLG1EQUFXO0FBQzNELEtBQUs7QUFDTCxzQkFBc0IsMENBQWMsSUFBSSxTQUFTO0FBQ2pEO0FBQ0EsbUJBQW1CLGdCQUFnQixNQUFNLG1EQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxtQkFBbUIsT0FBTyxNQUFNLG1EQUFXO0FBQ2xEO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLHNCQUFzQiwwQ0FBTTtBQUM1QixtQkFBbUIsNkJBQTZCO0FBQ2hELFFBQVEsbURBQVc7QUFDbkI7QUFDQSw0QkFBNEIsaURBQUUsR0FBRztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0IsMENBQUk7QUFDMUI7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCLDBDQUFjLElBQUksU0FBUztBQUN4RCxzQkFBc0IsT0FBTyxNQUFNLG1EQUFXO0FBQzlDO0FBQ0E7QUFDQSxPQUFPLG9CQUFvQixPQUFPLE1BQU0sbURBQVc7QUFDbkQ7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsbUJBQW1CLDBDQUFJO0FBQ3ZCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDBDQUFjLElBQUksU0FBUztBQUMvQyx1QkFBdUIsU0FBUztBQUNoQztBQUNBLG9DQUFvQywyQkFBMkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPLG9CQUFvQixTQUFTO0FBQ3BDO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUMsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCw4QkFBOEIsMENBQWMsSUFBSSxrQkFBa0I7QUFDbEU7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsVUFBVSwwQ0FBSyxJQUFJLE9BQU8sTUFBTSxtREFBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNCQUFzQiwwQ0FBYyxJQUFJLHlCQUF5QjtBQUNqRSxNQUFNLG1EQUFXLG1FQUFtRSwwQ0FBUyxvQ0FBb0MscUNBQXFDLElBQUksOEJBQThCO0FBQ3hNLEtBQUs7QUFDTCxxQkFBcUIsMENBQUssSUFBSSxPQUFPLE1BQU0sbURBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhCQUE4QiwwQ0FBSztBQUNuQztBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0wsNkJBQTZCLDBDQUFNO0FBQ25DLG9CQUFvQixPQUFPLE1BQU0sbURBQVc7QUFDNUMsaUJBQWlCLE9BQU8sTUFBTSxtREFBVztBQUN6Qyx1QkFBdUIsT0FBTyxNQUFNLG1EQUFXO0FBQy9DLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQixrQkFBa0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMENBQTBDLCtCQUErQix5QkFBeUI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0JBQStCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdCQUFnQiwwQ0FBVztBQUMzQjtBQUNBLEdBQUc7QUFDSCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9CQUFvQjtBQUNwQixpQkFBaUIsMkJBQTJCO0FBQzVDLEdBQUc7QUFDSCxZQUFZLG9FQUFvRSxlQUFlLGtEQUFrRDtBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBc0JFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95Y19kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jb21saW5rL2Rpc3QvaW5kZXguanM/NWJiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2NCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBmcm9tRXZlbnRPYnNlcnZhYmxlLCBzZXR1cCwgc2VuZFRvLCBhc3NpZ24sIGZyb21DYWxsYmFjaywgZW5xdWV1ZUFjdGlvbnMsIGFzc2VydEV2ZW50LCBlbWl0LCByYWlzZSwgc3RvcENoaWxkLCBjcmVhdGVBY3RvciB9IGZyb20gXCJ4c3RhdGVcIjtcbmltcG9ydCB7IGRlZmVyLCBmcm9tRXZlbnQsIG1hcCwgcGlwZSwgZmlsdGVyLCBidWZmZXJDb3VudCwgY29uY2F0TWFwLCB0YWtlLCBFTVBUWSwgdGFrZVVudGlsIH0gZnJvbSBcInJ4anNcIjtcbmNvbnN0IGxpc3RlbklucHV0RnJvbUNvbnRleHQgPSAoY29uZmlnKSA9PiAoe1xuICBjb250ZXh0XG59KSA9PiB7XG4gIGNvbnN0IHsgY291bnQsIGluY2x1ZGUsIGV4Y2x1ZGUsIHJlc3BvbnNlVHlwZSA9IFwibWVzc2FnZS5yZWNlaXZlZFwiIH0gPSBjb25maWc7XG4gIHJldHVybiB7XG4gICAgY291bnQsXG4gICAgZG9tYWluOiBjb250ZXh0LmRvbWFpbixcbiAgICBmcm9tOiBjb250ZXh0LmNvbm5lY3RUbyxcbiAgICBpbmNsdWRlOiBpbmNsdWRlID8gQXJyYXkuaXNBcnJheShpbmNsdWRlKSA/IGluY2x1ZGUgOiBbaW5jbHVkZV0gOiBbXSxcbiAgICBleGNsdWRlOiBleGNsdWRlID8gQXJyYXkuaXNBcnJheShleGNsdWRlKSA/IGV4Y2x1ZGUgOiBbZXhjbHVkZV0gOiBbXSxcbiAgICByZXNwb25zZVR5cGUsXG4gICAgdGFyZ2V0OiBjb250ZXh0LnRhcmdldCxcbiAgICB0bzogY29udGV4dC5uYW1lXG4gIH07XG59LCBsaXN0ZW5GaWx0ZXIgPSAoaW5wdXQpID0+IChldmVudCkgPT4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGV2ZW50O1xuICByZXR1cm4gKGlucHV0LmluY2x1ZGUubGVuZ3RoID8gaW5wdXQuaW5jbHVkZS5pbmNsdWRlcyhkYXRhLnR5cGUpIDogITApICYmIChpbnB1dC5leGNsdWRlLmxlbmd0aCA/ICFpbnB1dC5leGNsdWRlLmluY2x1ZGVzKGRhdGEudHlwZSkgOiAhMCkgJiYgZGF0YS5kb21haW4gPT09IGlucHV0LmRvbWFpbiAmJiBkYXRhLmZyb20gPT09IGlucHV0LmZyb20gJiYgZGF0YS50byA9PT0gaW5wdXQudG8gJiYgKCFpbnB1dC50YXJnZXQgfHwgZXZlbnQuc291cmNlID09PSBpbnB1dC50YXJnZXQpO1xufSwgZXZlbnRUb01lc3NhZ2UgPSAodHlwZSkgPT4gKGV2ZW50KSA9PiAoe1xuICB0eXBlLFxuICBtZXNzYWdlOiBldmVudFxufSksIG1lc3NhZ2VFdmVudHMkID0gZGVmZXIoXG4gICgpID0+IGZyb21FdmVudCh3aW5kb3csIFwibWVzc2FnZVwiKVxuKSwgY3JlYXRlTGlzdGVuTG9naWMgPSAoY29tcGF0TWFwKSA9PiBmcm9tRXZlbnRPYnNlcnZhYmxlKCh7IGlucHV0IH0pID0+IG1lc3NhZ2VFdmVudHMkLnBpcGUoXG4gIGNvbXBhdE1hcCA/IG1hcChjb21wYXRNYXApIDogcGlwZSgpLFxuICBmaWx0ZXIobGlzdGVuRmlsdGVyKGlucHV0KSksXG4gIG1hcChldmVudFRvTWVzc2FnZShpbnB1dC5yZXNwb25zZVR5cGUpKSxcbiAgaW5wdXQuY291bnQgPyBwaXBlKFxuICAgIGJ1ZmZlckNvdW50KGlucHV0LmNvdW50KSxcbiAgICBjb25jYXRNYXAoKGFycikgPT4gYXJyKSxcbiAgICB0YWtlKGlucHV0LmNvdW50KVxuICApIDogcGlwZSgpXG4pKSwgRE9NQUlOID0gXCJzYW5pdHkvY29tbGlua1wiLCBSRVNQT05TRV9USU1FT1VUX0RFRkFVTFQgPSAzZTMsIEZFVENIX1RJTUVPVVRfREVGQVVMVCA9IDFlNCwgSEVBUlRCRUFUX0lOVEVSVkFMID0gMWUzLCBIQU5EU0hBS0VfSU5URVJWQUwgPSA1MDAsIE1TR19SRVNQT05TRSA9IFwiY29tbGluay9yZXNwb25zZVwiLCBNU0dfSEVBUlRCRUFUID0gXCJjb21saW5rL2hlYXJ0YmVhdFwiLCBNU0dfRElTQ09OTkVDVCA9IFwiY29tbGluay9kaXNjb25uZWN0XCIsIE1TR19IQU5EU0hBS0VfU1lOID0gXCJjb21saW5rL2hhbmRzaGFrZS9zeW5cIiwgTVNHX0hBTkRTSEFLRV9TWU5fQUNLID0gXCJjb21saW5rL2hhbmRzaGFrZS9zeW4tYWNrXCIsIE1TR19IQU5EU0hBS0VfQUNLID0gXCJjb21saW5rL2hhbmRzaGFrZS9hY2tcIiwgSEFORFNIQUtFX01TR19UWVBFUyA9IFtcbiAgTVNHX0hBTkRTSEFLRV9TWU4sXG4gIE1TR19IQU5EU0hBS0VfU1lOX0FDSyxcbiAgTVNHX0hBTkRTSEFLRV9BQ0tcbl0sIElOVEVSTkFMX01TR19UWVBFUyA9IFtcbiAgTVNHX1JFU1BPTlNFLFxuICBNU0dfRElTQ09OTkVDVCxcbiAgTVNHX0hFQVJUQkVBVCxcbiAgLi4uSEFORFNIQUtFX01TR19UWVBFU1xuXSwgdGhyb3dPbkV2ZW50ID0gKG1lc3NhZ2UpID0+IChzb3VyY2UpID0+IHNvdXJjZS5waXBlKFxuICB0YWtlKDEpLFxuICBtYXAoKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfSlcbiksIGNyZWF0ZVJlcXVlc3RNYWNoaW5lID0gKCkgPT4gc2V0dXAoe1xuICB0eXBlczoge30sXG4gIGFjdG9yczoge1xuICAgIGxpc3RlbjogZnJvbUV2ZW50T2JzZXJ2YWJsZShcbiAgICAgICh7XG4gICAgICAgIGlucHV0XG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGFib3J0U2lnbmFsJCA9IGlucHV0LnNpZ25hbCA/IGZyb21FdmVudChpbnB1dC5zaWduYWwsIFwiYWJvcnRcIikucGlwZShcbiAgICAgICAgICB0aHJvd09uRXZlbnQoYFJlcXVlc3QgJHtpbnB1dC5yZXF1ZXN0SWR9IGFib3J0ZWRgKVxuICAgICAgICApIDogRU1QVFksIG1lc3NhZ2VGaWx0ZXIgPSAoZXZlbnQpID0+IGV2ZW50LmRhdGE/LnR5cGUgPT09IE1TR19SRVNQT05TRSAmJiBldmVudC5kYXRhPy5yZXNwb25zZVRvID09PSBpbnB1dC5yZXF1ZXN0SWQgJiYgISFldmVudC5zb3VyY2UgJiYgaW5wdXQuc291cmNlcy5oYXMoZXZlbnQuc291cmNlKTtcbiAgICAgICAgcmV0dXJuIGZyb21FdmVudCh3aW5kb3csIFwibWVzc2FnZVwiKS5waXBlKFxuICAgICAgICAgIGZpbHRlcihtZXNzYWdlRmlsdGVyKSxcbiAgICAgICAgICB0YWtlKGlucHV0LnNvdXJjZXMuc2l6ZSksXG4gICAgICAgICAgdGFrZVVudGlsKGFib3J0U2lnbmFsJClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApXG4gIH0sXG4gIGFjdGlvbnM6IHtcbiAgICBcInNlbmQgbWVzc2FnZVwiOiAoeyBjb250ZXh0IH0sIHBhcmFtcykgPT4ge1xuICAgICAgY29uc3QgeyBzb3VyY2VzLCB0YXJnZXRPcmlnaW4gfSA9IGNvbnRleHQsIHsgbWVzc2FnZSB9ID0gcGFyYW1zO1xuICAgICAgc291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICAgICAgc291cmNlLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHsgdGFyZ2V0T3JpZ2luIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBcIm9uIHN1Y2Nlc3NcIjogc2VuZFRvKFxuICAgICAgKHsgY29udGV4dCB9KSA9PiBjb250ZXh0LnBhcmVudFJlZixcbiAgICAgICh7IGNvbnRleHQsIHNlbGYgfSkgPT4gKGNvbnRleHQucmVzcG9uc2UgJiYgY29udGV4dC5yZXNvbHZhYmxlPy5yZXNvbHZlKGNvbnRleHQucmVzcG9uc2UpLCB7XG4gICAgICAgIHR5cGU6IFwicmVxdWVzdC5zdWNjZXNzXCIsXG4gICAgICAgIHJlcXVlc3RJZDogc2VsZi5pZCxcbiAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQucmVzcG9uc2UsXG4gICAgICAgIHJlc3BvbnNlVG86IGNvbnRleHQucmVzcG9uc2VUb1xuICAgICAgfSlcbiAgICApLFxuICAgIFwib24gZmFpbFwiOiBzZW5kVG8oXG4gICAgICAoeyBjb250ZXh0IH0pID0+IGNvbnRleHQucGFyZW50UmVmLFxuICAgICAgKHsgY29udGV4dCwgc2VsZiB9KSA9PiAoY29udGV4dC5zdXBwcmVzc1dhcm5pbmdzIHx8IGNvbnNvbGUud2FybihcbiAgICAgICAgYFtAc2FuaXR5L2NvbWxpbmtdIFJlY2VpdmVkIG5vIHJlc3BvbnNlIHRvIG1lc3NhZ2UgJyR7Y29udGV4dC50eXBlfScgb24gY2xpZW50ICcke2NvbnRleHQuZnJvbX0nIChJRDogJyR7Y29udGV4dC5pZH0nKS5gXG4gICAgICApLCBjb250ZXh0LnJlc29sdmFibGU/LnJlamVjdChuZXcgRXJyb3IoXCJObyByZXNwb25zZSByZWNlaXZlZFwiKSksIHsgdHlwZTogXCJyZXF1ZXN0LmZhaWxlZFwiLCByZXF1ZXN0SWQ6IHNlbGYuaWQgfSlcbiAgICApLFxuICAgIFwib24gYWJvcnRcIjogc2VuZFRvKFxuICAgICAgKHsgY29udGV4dCB9KSA9PiBjb250ZXh0LnBhcmVudFJlZixcbiAgICAgICh7IGNvbnRleHQsIHNlbGYgfSkgPT4gKGNvbnRleHQucmVzb2x2YWJsZT8ucmVqZWN0KG5ldyBFcnJvcihcIlJlcXVlc3QgYWJvcnRlZFwiKSksIHsgdHlwZTogXCJyZXF1ZXN0LmFib3J0ZWRcIiwgcmVxdWVzdElkOiBzZWxmLmlkIH0pXG4gICAgKVxuICB9LFxuICBndWFyZHM6IHtcbiAgICBleHBlY3RzUmVzcG9uc2U6ICh7IGNvbnRleHQgfSkgPT4gY29udGV4dC5leHBlY3RSZXNwb25zZVxuICB9LFxuICBkZWxheXM6IHtcbiAgICBpbml0aWFsVGltZW91dDogMCxcbiAgICByZXNwb25zZVRpbWVvdXQ6ICh7IGNvbnRleHQgfSkgPT4gY29udGV4dC5yZXNwb25zZVRpbWVvdXQgPz8gUkVTUE9OU0VfVElNRU9VVF9ERUZBVUxUXG4gIH1cbn0pLmNyZWF0ZU1hY2hpbmUoe1xuICAvKiogQHhzdGF0ZS1sYXlvdXQgTjRJZ3BnSmc1bURPSUM1UUFvQzJCREF4Z0N3SllEc3dCS0FPbHdnQnN3QmlBRDFnQmQwR3dUMEF6RmdKMlFOd2R6b0tBRlZ5b3dBZXdDdURJdFRSWThoVXVTb0J0QUF3QmRSS0FBT0UyUDF3VDh1a0xVUUJHQUV3QldFZ0JZQW5LK2VPQXpCN3NCMkR6WThyQUJvUUFFOXJEUWMzVjBjTlR3OGZBQTROSHdCZlZKQ0ZIQUppRWxnd2ZBZ0NLR3BOSFNRUUF5TUJVM05MQkRzckR4STdEVGFBalFBMk9PY05EeER3aEhzTkp4OU91MFRPcTJjSnhQOUhkTXlNYk9VOGdxTDhFclVyY3YxRFkxcUsrc2JtMXZhUExwNitnY1JuR3lkbzl3REd5Y1dRTEtWYzlBQjNkR05ONmppV0N3ZEF3TXJtS29ITXhIUkNKUktPRWlKSHd1WktCWndYS3pCTUtJR3lZa2h0QWtYT3dlVHFPSHcyUkp2RDQ1VWctUDRDQUgwSmdzTmljTUE4TGh3QXo0ZktpY1RTV1R5WmFmV20tZjVRY0VWU0UxYUdnZXB3aEZJbEY5YVlZckdEQzQrSnpFcHBqR3pPVWtlR2JwRElnZkFTQ0J3Y3pVNVFRLVl5dXFJQUMwblJ1Q0JkK0lKWHU5S1Nwd3BwWkVvWUR0MVJNc29zaUVjTmpkVmppSkVlR2lzaVNUSGtjVmdXcHB0dVh5aFdLSWFoanFHemkxQnFSSklOblZjZGtjYnVUTFM5VllDOElTZnNVQWJwNHZ6RHBoQ0hKSXlqQnZKTmx4Tm1STmV4UTNzSkdINDNHUGo4aldKclpXdVhZZnlvRUM3WWNMc2JyZ1JzamtjdmttZGdOYm9wVmhJUGhWZm5zaDhDbE16LXRXc0NrbUV3Y0hnVXZ0MjU3dTh2KzZIc2U0eG5oT2RabkltVmlkUHFDUk5CNEpxcEVBQSAqL1xuICBjb250ZXh0OiAoeyBpbnB1dCB9KSA9PiAoe1xuICAgIGNoYW5uZWxJZDogaW5wdXQuY2hhbm5lbElkLFxuICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgZG9tYWluOiBpbnB1dC5kb21haW4sXG4gICAgZXhwZWN0UmVzcG9uc2U6IGlucHV0LmV4cGVjdFJlc3BvbnNlID8/ICExLFxuICAgIGZyb206IGlucHV0LmZyb20sXG4gICAgaWQ6IGBtc2ctJHt2NCgpfWAsXG4gICAgcGFyZW50UmVmOiBpbnB1dC5wYXJlbnRSZWYsXG4gICAgcmVzb2x2YWJsZTogaW5wdXQucmVzb2x2YWJsZSxcbiAgICByZXNwb25zZTogbnVsbCxcbiAgICByZXNwb25zZVRpbWVvdXQ6IGlucHV0LnJlc3BvbnNlVGltZW91dCxcbiAgICByZXNwb25zZVRvOiBpbnB1dC5yZXNwb25zZVRvLFxuICAgIHNpZ25hbDogaW5wdXQuc2lnbmFsLFxuICAgIHNvdXJjZXM6IGlucHV0LnNvdXJjZXMgaW5zdGFuY2VvZiBTZXQgPyBpbnB1dC5zb3VyY2VzIDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2lucHV0LnNvdXJjZXNdKSxcbiAgICBzdXBwcmVzc1dhcm5pbmdzOiBpbnB1dC5zdXBwcmVzc1dhcm5pbmdzLFxuICAgIHRhcmdldE9yaWdpbjogaW5wdXQudGFyZ2V0T3JpZ2luLFxuICAgIHRvOiBpbnB1dC50byxcbiAgICB0eXBlOiBpbnB1dC50eXBlXG4gIH0pLFxuICBpbml0aWFsOiBcImlkbGVcIixcbiAgb246IHtcbiAgICBhYm9ydDogXCIuYWJvcnRlZFwiXG4gIH0sXG4gIHN0YXRlczoge1xuICAgIGlkbGU6IHtcbiAgICAgIGFmdGVyOiB7XG4gICAgICAgIGluaXRpYWxUaW1lb3V0OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInNlbmRpbmdcIlxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0sXG4gICAgc2VuZGluZzoge1xuICAgICAgZW50cnk6IHtcbiAgICAgICAgdHlwZTogXCJzZW5kIG1lc3NhZ2VcIixcbiAgICAgICAgcGFyYW1zOiAoeyBjb250ZXh0IH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGNoYW5uZWxJZCwgZGF0YSwgZG9tYWluLCBmcm9tLCBpZCwgcmVzcG9uc2VUbywgdG8sIHR5cGUgfSA9IGNvbnRleHQ7XG4gICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZToge1xuICAgICAgICAgICAgY2hhbm5lbElkLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGRvbWFpbixcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHJlc3BvbnNlVG9cbiAgICAgICAgICB9IH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhbHdheXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGd1YXJkOiBcImV4cGVjdHNSZXNwb25zZVwiLFxuICAgICAgICAgIHRhcmdldDogXCJhd2FpdGluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3VjY2Vzc1wiXG4gICAgICBdXG4gICAgfSxcbiAgICBhd2FpdGluZzoge1xuICAgICAgaW52b2tlOiB7XG4gICAgICAgIGlkOiBcImxpc3RlbiBmb3IgcmVzcG9uc2VcIixcbiAgICAgICAgc3JjOiBcImxpc3RlblwiLFxuICAgICAgICBpbnB1dDogKHsgY29udGV4dCB9KSA9PiAoe1xuICAgICAgICAgIHJlcXVlc3RJZDogY29udGV4dC5pZCxcbiAgICAgICAgICBzb3VyY2VzOiBjb250ZXh0LnNvdXJjZXMsXG4gICAgICAgICAgc2lnbmFsOiBjb250ZXh0LnNpZ25hbFxuICAgICAgICB9KSxcbiAgICAgICAgb25FcnJvcjogXCJhYm9ydGVkXCJcbiAgICAgIH0sXG4gICAgICBhZnRlcjoge1xuICAgICAgICByZXNwb25zZVRpbWVvdXQ6IFwiZmFpbGVkXCJcbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgYWN0aW9uczogYXNzaWduKHtcbiAgICAgICAgICAgIHJlc3BvbnNlOiAoeyBldmVudCB9KSA9PiBldmVudC5kYXRhLmRhdGEsXG4gICAgICAgICAgICByZXNwb25zZVRvOiAoeyBldmVudCB9KSA9PiBldmVudC5kYXRhLnJlc3BvbnNlVG9cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0YXJnZXQ6IFwic3VjY2Vzc1wiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZhaWxlZDoge1xuICAgICAgdHlwZTogXCJmaW5hbFwiLFxuICAgICAgZW50cnk6IFwib24gZmFpbFwiXG4gICAgfSxcbiAgICBzdWNjZXNzOiB7XG4gICAgICB0eXBlOiBcImZpbmFsXCIsXG4gICAgICBlbnRyeTogXCJvbiBzdWNjZXNzXCJcbiAgICB9LFxuICAgIGFib3J0ZWQ6IHtcbiAgICAgIHR5cGU6IFwiZmluYWxcIixcbiAgICAgIGVudHJ5OiBcIm9uIGFib3J0XCJcbiAgICB9XG4gIH0sXG4gIG91dHB1dDogKHsgY29udGV4dCwgc2VsZiB9KSA9PiAoe1xuICAgIHJlcXVlc3RJZDogc2VsZi5pZCxcbiAgICByZXNwb25zZTogY29udGV4dC5yZXNwb25zZSxcbiAgICByZXNwb25zZVRvOiBjb250ZXh0LnJlc3BvbnNlVG9cbiAgfSlcbn0pLCBzZW5kQmFja0F0SW50ZXJ2YWwgPSBmcm9tQ2FsbGJhY2soKHsgc2VuZEJhY2ssIGlucHV0IH0pID0+IHtcbiAgY29uc3Qgc2VuZCA9ICgpID0+IHtcbiAgICBzZW5kQmFjayhpbnB1dC5ldmVudCk7XG4gIH07XG4gIGlucHV0LmltbWVkaWF0ZSAmJiBzZW5kKCk7XG4gIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoc2VuZCwgaW5wdXQuaW50ZXJ2YWwpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9O1xufSksIGNyZWF0ZUNvbm5lY3Rpb25NYWNoaW5lID0gKCkgPT4gc2V0dXAoe1xuICB0eXBlczoge30sXG4gIGFjdG9yczoge1xuICAgIHJlcXVlc3RNYWNoaW5lOiBjcmVhdGVSZXF1ZXN0TWFjaGluZSgpLFxuICAgIGxpc3RlbjogY3JlYXRlTGlzdGVuTG9naWMoKSxcbiAgICBzZW5kQmFja0F0SW50ZXJ2YWxcbiAgfSxcbiAgYWN0aW9uczoge1xuICAgIFwiYnVmZmVyIG1lc3NhZ2VcIjogZW5xdWV1ZUFjdGlvbnMoKHsgZW5xdWV1ZSB9KSA9PiB7XG4gICAgICBlbnF1ZXVlLmFzc2lnbih7XG4gICAgICAgIGJ1ZmZlcjogKHsgZXZlbnQsIGNvbnRleHQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInBvc3RcIiksIFsuLi5jb250ZXh0LmJ1ZmZlciwgZXZlbnQuZGF0YV0pXG4gICAgICB9KSwgZW5xdWV1ZS5lbWl0KCh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJwb3N0XCIpLCB7XG4gICAgICAgIHR5cGU6IFwiX2J1ZmZlci5hZGRlZFwiLFxuICAgICAgICBtZXNzYWdlOiBldmVudC5kYXRhXG4gICAgICB9KSk7XG4gICAgfSksXG4gICAgXCJjcmVhdGUgcmVxdWVzdFwiOiBhc3NpZ24oe1xuICAgICAgcmVxdWVzdHM6ICh7IGNvbnRleHQsIGV2ZW50LCBzZWxmLCBzcGF3biB9KSA9PiB7XG4gICAgICAgIGFzc2VydEV2ZW50KGV2ZW50LCBcInJlcXVlc3RcIik7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RzID0gKEFycmF5LmlzQXJyYXkoZXZlbnQuZGF0YSkgPyBldmVudC5kYXRhIDogW2V2ZW50LmRhdGFdKS5tYXAoKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGByZXEtJHt2NCgpfWA7XG4gICAgICAgICAgcmV0dXJuIHNwYXduKFwicmVxdWVzdE1hY2hpbmVcIiwge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICBjaGFubmVsSWQ6IGNvbnRleHQuY2hhbm5lbElkLFxuICAgICAgICAgICAgICBkYXRhOiByZXF1ZXN0LmRhdGEsXG4gICAgICAgICAgICAgIGRvbWFpbjogY29udGV4dC5kb21haW4sXG4gICAgICAgICAgICAgIGV4cGVjdFJlc3BvbnNlOiByZXF1ZXN0LmV4cGVjdFJlc3BvbnNlLFxuICAgICAgICAgICAgICBmcm9tOiBjb250ZXh0Lm5hbWUsXG4gICAgICAgICAgICAgIHBhcmVudFJlZjogc2VsZixcbiAgICAgICAgICAgICAgcmVzcG9uc2VUbzogcmVxdWVzdC5yZXNwb25zZVRvLFxuICAgICAgICAgICAgICBzb3VyY2VzOiBjb250ZXh0LnRhcmdldCxcbiAgICAgICAgICAgICAgdGFyZ2V0T3JpZ2luOiBjb250ZXh0LnRhcmdldE9yaWdpbixcbiAgICAgICAgICAgICAgdG86IGNvbnRleHQuY29ubmVjdFRvLFxuICAgICAgICAgICAgICB0eXBlOiByZXF1ZXN0LnR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbLi4uY29udGV4dC5yZXF1ZXN0cywgLi4ucmVxdWVzdHNdO1xuICAgICAgfVxuICAgIH0pLFxuICAgIFwiZW1pdCByZWNlaXZlZCBtZXNzYWdlXCI6IGVucXVldWVBY3Rpb25zKCh7IGVucXVldWUgfSkgPT4ge1xuICAgICAgZW5xdWV1ZS5lbWl0KCh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJtZXNzYWdlLnJlY2VpdmVkXCIpLCB7XG4gICAgICAgIHR5cGU6IFwiX21lc3NhZ2VcIixcbiAgICAgICAgbWVzc2FnZTogZXZlbnQubWVzc2FnZS5kYXRhXG4gICAgICB9KSksIGVucXVldWUuZW1pdCgoeyBldmVudCB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwibWVzc2FnZS5yZWNlaXZlZFwiKSwge1xuICAgICAgICB0eXBlOiBldmVudC5tZXNzYWdlLmRhdGEudHlwZSxcbiAgICAgICAgbWVzc2FnZTogZXZlbnQubWVzc2FnZS5kYXRhXG4gICAgICB9KSk7XG4gICAgfSksXG4gICAgXCJlbWl0IHN0YXR1c1wiOiBlbWl0KChfLCBwYXJhbXMpID0+ICh7XG4gICAgICB0eXBlOiBcIl9zdGF0dXNcIixcbiAgICAgIHN0YXR1czogcGFyYW1zLnN0YXR1c1xuICAgIH0pKSxcbiAgICBcImZsdXNoIGJ1ZmZlclwiOiBlbnF1ZXVlQWN0aW9ucygoeyBlbnF1ZXVlIH0pID0+IHtcbiAgICAgIGVucXVldWUucmFpc2UoKHsgY29udGV4dCB9KSA9PiAoe1xuICAgICAgICB0eXBlOiBcInJlcXVlc3RcIixcbiAgICAgICAgZGF0YTogY29udGV4dC5idWZmZXIubWFwKCh7IGRhdGEsIHR5cGUgfSkgPT4gKHsgZGF0YSwgdHlwZSB9KSlcbiAgICAgIH0pKSwgZW5xdWV1ZS5lbWl0KCh7IGNvbnRleHQgfSkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJfYnVmZmVyLmZsdXNoZWRcIixcbiAgICAgICAgbWVzc2FnZXM6IGNvbnRleHQuYnVmZmVyXG4gICAgICB9KSksIGVucXVldWUuYXNzaWduKHtcbiAgICAgICAgYnVmZmVyOiBbXVxuICAgICAgfSk7XG4gICAgfSksXG4gICAgcG9zdDogcmFpc2UoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInBvc3RcIiksIHtcbiAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgZGF0YToge1xuICAgICAgICBkYXRhOiBldmVudC5kYXRhLmRhdGEsXG4gICAgICAgIGV4cGVjdFJlc3BvbnNlOiAhMCxcbiAgICAgICAgdHlwZTogZXZlbnQuZGF0YS50eXBlXG4gICAgICB9XG4gICAgfSkpLFxuICAgIFwicmVtb3ZlIHJlcXVlc3RcIjogZW5xdWV1ZUFjdGlvbnMoKHsgY29udGV4dCwgZW5xdWV1ZSwgZXZlbnQgfSkgPT4ge1xuICAgICAgYXNzZXJ0RXZlbnQoZXZlbnQsIFtcInJlcXVlc3Quc3VjY2Vzc1wiLCBcInJlcXVlc3QuZmFpbGVkXCIsIFwicmVxdWVzdC5hYm9ydGVkXCJdKSwgc3RvcENoaWxkKGV2ZW50LnJlcXVlc3RJZCksIGVucXVldWUuYXNzaWduKHsgcmVxdWVzdHM6IGNvbnRleHQucmVxdWVzdHMuZmlsdGVyKCh7IGlkIH0pID0+IGlkICE9PSBldmVudC5yZXF1ZXN0SWQpIH0pO1xuICAgIH0pLFxuICAgIHJlc3BvbmQ6IHJhaXNlKCh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJyZXNwb25zZVwiKSwge1xuICAgICAgdHlwZTogXCJyZXF1ZXN0XCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICAgIHR5cGU6IE1TR19SRVNQT05TRSxcbiAgICAgICAgcmVzcG9uc2VUbzogZXZlbnQucmVzcG9uZFRvXG4gICAgICB9XG4gICAgfSkpLFxuICAgIFwic2VuZCBoYW5kc2hha2UgYWNrXCI6IHJhaXNlKHtcbiAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgZGF0YTogeyB0eXBlOiBNU0dfSEFORFNIQUtFX0FDSyB9XG4gICAgfSksXG4gICAgXCJzZW5kIGRpc2Nvbm5lY3RcIjogcmFpc2UoKCkgPT4gKHtcbiAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgZGF0YTogeyB0eXBlOiBNU0dfRElTQ09OTkVDVCB9XG4gICAgfSkpLFxuICAgIFwic2VuZCBoYW5kc2hha2Ugc3luXCI6IHJhaXNlKHtcbiAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgZGF0YTogeyB0eXBlOiBNU0dfSEFORFNIQUtFX1NZTiB9XG4gICAgfSksXG4gICAgXCJzZXQgdGFyZ2V0XCI6IGFzc2lnbih7XG4gICAgICB0YXJnZXQ6ICh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJ0YXJnZXQuc2V0XCIpLCBldmVudC50YXJnZXQpXG4gICAgfSlcbiAgfSxcbiAgZ3VhcmRzOiB7XG4gICAgXCJoYXMgdGFyZ2V0XCI6ICh7IGNvbnRleHQgfSkgPT4gISFjb250ZXh0LnRhcmdldCxcbiAgICBcInNob3VsZCBzZW5kIGhlYXJ0YmVhdHNcIjogKHsgY29udGV4dCB9KSA9PiBjb250ZXh0LmhlYXJ0YmVhdFxuICB9XG59KS5jcmVhdGVNYWNoaW5lKHtcbiAgLyoqIEB4c3RhdGUtbGF5b3V0IE40SWdwZ0pnNW1ET0lDNVFHTUFXQkRBZHBzQWJBeEFDN29CT01oQWRMR0lRTm9BTUF1b3FBQTREMnNBbG9WKzVpeEFBUFJBSFpSQUpnb0FXQUJ6MEFySElDTXkyUUdaWkNnSndBYUVBRTlFRSt0SXJiNkFOZ2tMbDQ2ZlR1ajFBWHhmNjBXSEFSSmdBamdDdWNKU3dBY2pJY0xBTXpFZ2dITnk4LUlJaUNLTFMyaFFTNnFiMnl1cmlzckw2UmdqSzlMSXlDdXFxMGc3V3N0WnVIaGpZZVBpK2djRVVBR2JvWExpUTBZTHhQSHdDc1NtaUNnb3lrcGF5RHRxUzZ0cnF4WWpLRWswZ25xMjRGRndRQS1qSS1EaklkRXpEbktOSkV4dU9acFoxMmVxMjlPclNDdXVweXBZVW9qVWFUS0NubTVXazIxMjNnT1J6QStIaWx4aWJCdWlYR29CU0duVUFJVTRnVTlGV2FtVXRSK2xtVU0xRWxsQkVrc2xNVUVucGtKYTBKYUVGZ0dBQTFseE1GQjhMQURKZ2hyRVJxamtodHNoazNtVHRObzVPcHFwWWZxQ0toVHB0b3FwWTFXVXR1NGRreThCUVdXejBKenVlMS1FRllJanJna3hxTFN1cHFSUlBwb1BxSnRMSTBoSWlvWkVOSkpFN05uSjhaWUhWazFZeXZQckRSeXVUeUVZTGtUYTd1aXhWbE1oODFLR0ZoUzFqNkVQa1pscFZqVHBocjhta0kzc0RWaFdUSFRRQmJTTG9HQVVYd1JMZ0FOMEdWeUZLTnQ5MUtpbVVGRUtYdktDMnM5Uis2WCtqaXBuekplU3FFSjFVS2pOYU5KcDVFQzRzRk9yUXVDYmlmZVR3ZzJjZ295bTBSUHhEdHFrajBlYUI5QW84elNvbE1FaXZaVmNxNzErMzNjNUNFZ2VGT0N0WHNrelJNOEVEeEtScG1rU3czUUpiUXNtcEg1dEhtVjhKSFNiSnBEc2FrVjJhU01BTE9NQUxoQWpvTFhBeE5iaWdsSS1TeFd3MVZ3MFFORHcwUWZnOUtRN0VKU3hISHhBcEsyaFFDeU9BaUF6VmdEaE1Hb0k5aFg3Rk1FSFNGOGNXa2VscEhVUkNiQnNiNDgxeEFFZ1Q5QlFKQ21XUXNpRS1VUlBJOFRHMWdXQm16QVZzeUxBVHR1eVJZOUlMdFdvS21sTDgyS3FkMHRBVko5MUxNSEZaREtJa1Zsa05WWkhNa2lEekUtQWR6M1VqRHg3R2lSUUhDS25oZUQ1M2srSFNTa0RESXdwQlZUcVF3dUtLRXNzU0RUQVVoQ0FBSTNxeWcwRElyZDhGa2s4Nk1RVU1uVk0rUnlub2VnVERKSDQ4aEdwMHZSLUZEUnFxS3Fhc2dPcUd1YTlBUWpBVEFkMU5TaXVsNmZwWE90V2k3V3kxOWNzbEQ0dm5HN0lYM29WalZEVVZZRUpRcXJrc1c4U2RzdExxUEt5MHdLZ0cxUmh0TVdvZ3FLaG9NamtXcDZYeFV5RkJlM2MzdEF6NzB2Y282ZnErVjhQVGtHVUZ6ZFFxTm5FTEVNMnlDbHJ3d3pRNFpTaEtRSnFyN1VZVTk4QVMwVzlwVDR6NXBIRzB5WHdNa05OVHlHazNCMVRCMkFnT0JCRFhYQkRzeWhTRkc5RW92UXFONWkxSmVSY0txdzRCa2wrVG9NeDh4MGorRWFxUTlYTVNrQlVSTWdNa0V3UVdLcm8yTldOTmRQRkpBek4wbEpHTTRzbER4aEJFSmZYeXBsQmQwM3dXMUt4SWRuckJ4Qmg0SkF5Vzc1QzhySnBtRHFtSUdXa2dtcGFzUGpxVWNhSG9vTUxIQTB1VTFVa0pPZ0tXMUI2clQxYldvcjVBdDB6Z2NUQWtLN2hyejFpckIwRDhjVzBVdlJQTHl2MDdXcWdOcTJxQUcrbDlTblhVejBVT1hENXh1TXMzWTQrRFZKQlg3VWlLclY2UThnY2ZvSk81NHJGZWZMTHFmSllYMVdLWU5MeEw0Tk8xTndnQSAqL1xuICBpZDogXCJjb25uZWN0aW9uXCIsXG4gIGNvbnRleHQ6ICh7IGlucHV0IH0pID0+ICh7XG4gICAgaWQ6IGlucHV0LmlkIHx8IGAke2lucHV0Lm5hbWV9LSR7djQoKX1gLFxuICAgIGJ1ZmZlcjogW10sXG4gICAgY2hhbm5lbElkOiBgY2huLSR7djQoKX1gLFxuICAgIGNvbm5lY3RUbzogaW5wdXQuY29ubmVjdFRvLFxuICAgIGRvbWFpbjogaW5wdXQuZG9tYWluID8/IERPTUFJTixcbiAgICBoZWFydGJlYXQ6IGlucHV0LmhlYXJ0YmVhdCA/PyAhMSxcbiAgICBuYW1lOiBpbnB1dC5uYW1lLFxuICAgIHJlcXVlc3RzOiBbXSxcbiAgICB0YXJnZXQ6IGlucHV0LnRhcmdldCxcbiAgICB0YXJnZXRPcmlnaW46IGlucHV0LnRhcmdldE9yaWdpblxuICB9KSxcbiAgb246IHtcbiAgICBcInRhcmdldC5zZXRcIjoge1xuICAgICAgYWN0aW9uczogXCJzZXQgdGFyZ2V0XCJcbiAgICB9LFxuICAgIFwicmVxdWVzdC5zdWNjZXNzXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwicmVtb3ZlIHJlcXVlc3RcIlxuICAgIH0sXG4gICAgXCJyZXF1ZXN0LmZhaWxlZFwiOiB7XG4gICAgICBhY3Rpb25zOiBcInJlbW92ZSByZXF1ZXN0XCJcbiAgICB9XG4gIH0sXG4gIGluaXRpYWw6IFwiaWRsZVwiLFxuICBzdGF0ZXM6IHtcbiAgICBpZGxlOiB7XG4gICAgICBlbnRyeTogW3sgdHlwZTogXCJlbWl0IHN0YXR1c1wiLCBwYXJhbXM6IHsgc3RhdHVzOiBcImlkbGVcIiB9IH1dLFxuICAgICAgb246IHtcbiAgICAgICAgY29ubmVjdDoge1xuICAgICAgICAgIHRhcmdldDogXCJoYW5kc2hha2luZ1wiLFxuICAgICAgICAgIGd1YXJkOiBcImhhcyB0YXJnZXRcIlxuICAgICAgICB9LFxuICAgICAgICBwb3N0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJidWZmZXIgbWVzc2FnZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRzaGFraW5nOiB7XG4gICAgICBpZDogXCJoYW5kc2hha2luZ1wiLFxuICAgICAgZW50cnk6IFt7IHR5cGU6IFwiZW1pdCBzdGF0dXNcIiwgcGFyYW1zOiB7IHN0YXR1czogXCJoYW5kc2hha2luZ1wiIH0gfV0sXG4gICAgICBpbnZva2U6IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcInNlbmQgc3luXCIsXG4gICAgICAgICAgc3JjOiBcInNlbmRCYWNrQXRJbnRlcnZhbFwiLFxuICAgICAgICAgIGlucHV0OiAoKSA9PiAoe1xuICAgICAgICAgICAgZXZlbnQ6IHsgdHlwZTogXCJzeW5cIiB9LFxuICAgICAgICAgICAgaW50ZXJ2YWw6IEhBTkRTSEFLRV9JTlRFUlZBTCxcbiAgICAgICAgICAgIGltbWVkaWF0ZTogITBcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwibGlzdGVuIGZvciBoYW5kc2hha2VcIixcbiAgICAgICAgICBzcmM6IFwibGlzdGVuXCIsXG4gICAgICAgICAgaW5wdXQ6IChpbnB1dCkgPT4gbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICAgICAgICBpbmNsdWRlOiBNU0dfSEFORFNIQUtFX1NZTl9BQ0ssXG4gICAgICAgICAgICBjb3VudDogMVxuICAgICAgICAgIH0pKGlucHV0KVxuICAgICAgICAgIC8qIEJlbG93IHdvdWxkIG1heWJlIGJlIG1vcmUgcmVhZGFibGUgdGhhbiB0cmFuc2l0aW9uaW5nIHRvXG4gICAgICAgICAgJ2Nvbm5lY3RlZCcgb24gJ21lc3NhZ2UnLCBhbmQgJ2Fjaycgb24gZXhpdCBidXQgaGF2aW5nIG9uRG9uZSB3aGVuXG4gICAgICAgICAgdXNpbmcgcGFzc2luZyBpbnZvY2F0aW9ucyBjdXJyZW50bHkgYnJlYWtzIFhTdGF0ZSBFZGl0b3IgKi9cbiAgICAgICAgICAvLyBvbkRvbmU6IHtcbiAgICAgICAgICAvLyAgIHRhcmdldDogJ2Nvbm5lY3RlZCcsXG4gICAgICAgICAgLy8gICBhY3Rpb25zOiAnYWNrJyxcbiAgICAgICAgICAvLyB9LFxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgb246IHtcbiAgICAgICAgc3luOiB7XG4gICAgICAgICAgYWN0aW9uczogXCJzZW5kIGhhbmRzaGFrZSBzeW5cIlxuICAgICAgICB9LFxuICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJjcmVhdGUgcmVxdWVzdFwiXG4gICAgICAgIH0sXG4gICAgICAgIHBvc3Q6IHtcbiAgICAgICAgICBhY3Rpb25zOiBcImJ1ZmZlciBtZXNzYWdlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtZXNzYWdlLnJlY2VpdmVkXCI6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiY29ubmVjdGVkXCJcbiAgICAgICAgfSxcbiAgICAgICAgZGlzY29ubmVjdDoge1xuICAgICAgICAgIHRhcmdldDogXCJkaXNjb25uZWN0ZWRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXhpdDogXCJzZW5kIGhhbmRzaGFrZSBhY2tcIlxuICAgIH0sXG4gICAgY29ubmVjdGVkOiB7XG4gICAgICBlbnRyeTogW1wiZmx1c2ggYnVmZmVyXCIsIHsgdHlwZTogXCJlbWl0IHN0YXR1c1wiLCBwYXJhbXM6IHsgc3RhdHVzOiBcImNvbm5lY3RlZFwiIH0gfV0sXG4gICAgICBpbnZva2U6IHtcbiAgICAgICAgaWQ6IFwibGlzdGVuIGZvciBtZXNzYWdlc1wiLFxuICAgICAgICBzcmM6IFwibGlzdGVuXCIsXG4gICAgICAgIGlucHV0OiBsaXN0ZW5JbnB1dEZyb21Db250ZXh0KHtcbiAgICAgICAgICBleGNsdWRlOiBbTVNHX1JFU1BPTlNFLCBNU0dfSEVBUlRCRUFUXVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIHBvc3Q6IHtcbiAgICAgICAgICBhY3Rpb25zOiBcInBvc3RcIlxuICAgICAgICB9LFxuICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJjcmVhdGUgcmVxdWVzdFwiXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgYWN0aW9uczogXCJyZXNwb25kXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtZXNzYWdlLnJlY2VpdmVkXCI6IHtcbiAgICAgICAgICBhY3Rpb25zOiBcImVtaXQgcmVjZWl2ZWQgbWVzc2FnZVwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc2Nvbm5lY3Q6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiZGlzY29ubmVjdGVkXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluaXRpYWw6IFwiaGVhcnRiZWF0XCIsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgaGVhcnRiZWF0OiB7XG4gICAgICAgICAgaW5pdGlhbDogXCJjaGVja2luZ1wiLFxuICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgY2hlY2tpbmc6IHtcbiAgICAgICAgICAgICAgYWx3YXlzOiB7XG4gICAgICAgICAgICAgICAgZ3VhcmQ6IFwic2hvdWxkIHNlbmQgaGVhcnRiZWF0c1wiLFxuICAgICAgICAgICAgICAgIHRhcmdldDogXCJzZW5kaW5nXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbmRpbmc6IHtcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBcInJlcXVlc3QuZmFpbGVkXCI6IHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjaGFuZHNoYWtpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaW52b2tlOiB7XG4gICAgICAgICAgICAgICAgaWQ6IFwic2VuZCBoZWFydGJlYXRcIixcbiAgICAgICAgICAgICAgICBzcmM6IFwic2VuZEJhY2tBdEludGVydmFsXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICBldmVudDogeyB0eXBlOiBcInBvc3RcIiwgZGF0YTogeyB0eXBlOiBNU0dfSEVBUlRCRUFULCBkYXRhOiB2b2lkIDAgfSB9LFxuICAgICAgICAgICAgICAgICAgaW50ZXJ2YWw6IDJlMyxcbiAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZTogITFcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXNjb25uZWN0ZWQ6IHtcbiAgICAgIGlkOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgICAgZW50cnk6IFtcInNlbmQgZGlzY29ubmVjdFwiLCB7IHR5cGU6IFwiZW1pdCBzdGF0dXNcIiwgcGFyYW1zOiB7IHN0YXR1czogXCJkaXNjb25uZWN0ZWRcIiB9IH1dLFxuICAgICAgb246IHtcbiAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgIGFjdGlvbnM6IFwiY3JlYXRlIHJlcXVlc3RcIlxuICAgICAgICB9LFxuICAgICAgICBwb3N0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJidWZmZXIgbWVzc2FnZVwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3Q6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiaGFuZHNoYWtpbmdcIixcbiAgICAgICAgICBndWFyZDogXCJoYXMgdGFyZ2V0XCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSksIGNyZWF0ZUNvbm5lY3Rpb24gPSAoaW5wdXQsIG1hY2hpbmUgPSBjcmVhdGVDb25uZWN0aW9uTWFjaGluZSgpKSA9PiB7XG4gIGNvbnN0IGlkID0gaW5wdXQuaWQgfHwgYCR7aW5wdXQubmFtZX0tJHt2NCgpfWAsIGFjdG9yID0gY3JlYXRlQWN0b3IobWFjaGluZSwge1xuICAgIGlucHV0OiB7IC4uLmlucHV0LCBpZCB9XG4gIH0pLCBvbiA9ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgY29uc3QgeyB1bnN1YnNjcmliZSB9ID0gYWN0b3Iub24oXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEB0b2RvIGB0eXBlYCB0eXBpbmdcbiAgICAgIHR5cGUsXG4gICAgICBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyKGV2ZW50Lm1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIHJlc3BvbnNlICYmIGFjdG9yLnNlbmQoeyB0eXBlOiBcInJlc3BvbnNlXCIsIHJlc3BvbmRUbzogZXZlbnQubWVzc2FnZS5pZCwgZGF0YTogcmVzcG9uc2UgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIGNvbm5lY3QgPSAoKSA9PiB7XG4gICAgYWN0b3Iuc2VuZCh7IHR5cGU6IFwiY29ubmVjdFwiIH0pO1xuICB9LCBkaXNjb25uZWN0ID0gKCkgPT4ge1xuICAgIGFjdG9yLnNlbmQoeyB0eXBlOiBcImRpc2Nvbm5lY3RcIiB9KTtcbiAgfSwgb25TdGF0dXMgPSAoaGFuZGxlciwgZmlsdGVyMikgPT4ge1xuICAgIGNvbnN0IHsgdW5zdWJzY3JpYmUgfSA9IGFjdG9yLm9uKFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBAdG9kbyBSZWNlaXZlZEVtaXRFdmVudCBjYXVzZXMgdGhpc1xuICAgICAgXCJfc3RhdHVzXCIsXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgZmlsdGVyMiAmJiBldmVudC5zdGF0dXMgIT09IGZpbHRlcjIgfHwgaGFuZGxlcihldmVudC5zdGF0dXMpO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBzZXRUYXJnZXQgPSAodGFyZ2V0KSA9PiB7XG4gICAgYWN0b3Iuc2VuZCh7IHR5cGU6IFwidGFyZ2V0LnNldFwiLCB0YXJnZXQgfSk7XG4gIH0sIHBvc3QgPSAodHlwZSwgZGF0YSkgPT4ge1xuICAgIGNvbnN0IF9kYXRhID0geyB0eXBlLCBkYXRhIH07XG4gICAgYWN0b3Iuc2VuZCh7IHR5cGU6IFwicG9zdFwiLCBkYXRhOiBfZGF0YSB9KTtcbiAgfSwgc3RvcCA9ICgpID0+IHtcbiAgICBhY3Rvci5zdG9wKCk7XG4gIH0sIHN0YXJ0ID0gKCkgPT4gKGFjdG9yLnN0YXJ0KCksIHN0b3ApO1xuICByZXR1cm4ge1xuICAgIGFjdG9yLFxuICAgIGNvbm5lY3QsXG4gICAgZGlzY29ubmVjdCxcbiAgICBpZCxcbiAgICBuYW1lOiBpbnB1dC5uYW1lLFxuICAgIG1hY2hpbmUsXG4gICAgb24sXG4gICAgb25TdGF0dXMsXG4gICAgcG9zdCxcbiAgICBzZXRUYXJnZXQsXG4gICAgc3RhcnQsXG4gICAgc3RvcCxcbiAgICBnZXQgdGFyZ2V0KCkge1xuICAgICAgcmV0dXJuIGFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC50YXJnZXQ7XG4gICAgfVxuICB9O1xufSwgY2xlYW51cENvbm5lY3Rpb24gPSAoY29ubmVjdGlvbikgPT4ge1xuICBjb25uZWN0aW9uLmRpc2Nvbm5lY3QoKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY29ubmVjdGlvbi5zdG9wKCk7XG4gIH0sIDApO1xufSwgbm9vcCA9ICgpID0+IHtcbn0sIGNyZWF0ZUNvbnRyb2xsZXIgPSAoaW5wdXQpID0+IHtcbiAgY29uc3QgeyB0YXJnZXRPcmlnaW4gfSA9IGlucHV0LCB0YXJnZXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgY2hhbm5lbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICByZXR1cm4ge1xuICAgIGFkZFRhcmdldDogKHRhcmdldCkgPT4ge1xuICAgICAgaWYgKHRhcmdldHMuaGFzKHRhcmdldCkpXG4gICAgICAgIHJldHVybiBub29wO1xuICAgICAgaWYgKCF0YXJnZXRzLnNpemUgfHwgIWNoYW5uZWxzLnNpemUpXG4gICAgICAgIHJldHVybiB0YXJnZXRzLmFkZCh0YXJnZXQpLCBjaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgY2hhbm5lbC5jb25uZWN0aW9ucy5mb3JFYWNoKChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnNldFRhcmdldCh0YXJnZXQpLCBjb25uZWN0aW9uLmNvbm5lY3QoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksICgpID0+IHtcbiAgICAgICAgICB0YXJnZXRzLmRlbGV0ZSh0YXJnZXQpLCBjaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgICBjaGFubmVsLmNvbm5lY3Rpb25zLmZvckVhY2goKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbi50YXJnZXQgPT09IHRhcmdldCAmJiBjb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgdGFyZ2V0cy5hZGQodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHRhcmdldENvbm5lY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHJldHVybiBjaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBjcmVhdGVDb25uZWN0aW9uKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLmNoYW5uZWwuaW5wdXQsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICB0YXJnZXRPcmlnaW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoYW5uZWwubWFjaGluZVxuICAgICAgICApO1xuICAgICAgICB0YXJnZXRDb25uZWN0aW9ucy5hZGQoY29ubmVjdGlvbiksIGNoYW5uZWwuY29ubmVjdGlvbnMuYWRkKGNvbm5lY3Rpb24pLCBjaGFubmVsLnN1YnNjcmliZXJzLmZvckVhY2goKHsgdHlwZSwgaGFuZGxlciwgdW5zdWJzY3JpYmVycyB9KSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVycy5wdXNoKGNvbm5lY3Rpb24ub24odHlwZSwgaGFuZGxlcikpO1xuICAgICAgICB9KSwgY2hhbm5lbC5pbnRlcm5hbEV2ZW50U3Vic2NyaWJlcnMuZm9yRWFjaCgoeyB0eXBlLCBoYW5kbGVyLCB1bnN1YnNjcmliZXJzIH0pID0+IHtcbiAgICAgICAgICB1bnN1YnNjcmliZXJzLnB1c2goY29ubmVjdGlvbi5hY3Rvci5vbih0eXBlLCBoYW5kbGVyKS51bnN1YnNjcmliZSk7XG4gICAgICAgIH0pLCBjaGFubmVsLnN0YXR1c1N1YnNjcmliZXJzLmZvckVhY2goKHsgaGFuZGxlciwgdW5zdWJzY3JpYmVycyB9KSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVycy5wdXNoKFxuICAgICAgICAgICAgY29ubmVjdGlvbi5vblN0YXR1cygoc3RhdHVzKSA9PiBoYW5kbGVyKHsgY29ubmVjdGlvbjogY29ubmVjdGlvbi5pZCwgc3RhdHVzIH0pKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pLCBjb25uZWN0aW9uLnN0YXJ0KCksIGNvbm5lY3Rpb24uY29ubmVjdCgpO1xuICAgICAgfSksICgpID0+IHtcbiAgICAgICAgdGFyZ2V0cy5kZWxldGUodGFyZ2V0KSwgdGFyZ2V0Q29ubmVjdGlvbnMuZm9yRWFjaCgoY29ubmVjdGlvbikgPT4ge1xuICAgICAgICAgIGNsZWFudXBDb25uZWN0aW9uKGNvbm5lY3Rpb24pLCBjaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgICBjaGFubmVsLmNvbm5lY3Rpb25zLmRlbGV0ZShjb25uZWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlQ2hhbm5lbDogKGlucHV0MiwgbWFjaGluZSA9IGNyZWF0ZUNvbm5lY3Rpb25NYWNoaW5lKCkpID0+IHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB7XG4gICAgICAgIGNvbm5lY3Rpb25zOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgICBpbnB1dDogaW5wdXQyLFxuICAgICAgICBpbnRlcm5hbEV2ZW50U3Vic2NyaWJlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICAgIG1hY2hpbmUsXG4gICAgICAgIHN0YXR1c1N1YnNjcmliZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgICBzdWJzY3JpYmVyczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgICAgfTtcbiAgICAgIGNoYW5uZWxzLmFkZChjaGFubmVsKTtcbiAgICAgIGNvbnN0IHsgY29ubmVjdGlvbnMsIGludGVybmFsRXZlbnRTdWJzY3JpYmVycywgc3RhdHVzU3Vic2NyaWJlcnMsIHN1YnNjcmliZXJzIH0gPSBjaGFubmVsO1xuICAgICAgaWYgKHRhcmdldHMuc2l6ZSlcbiAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKCh0YXJnZXQpID0+IHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gY3JlYXRlQ29ubmVjdGlvbihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uaW5wdXQyLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHRhcmdldE9yaWdpblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hY2hpbmVcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbm5lY3Rpb25zLmFkZChjb25uZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGNyZWF0ZUNvbm5lY3Rpb24oeyAuLi5pbnB1dDIsIHRhcmdldE9yaWdpbiB9LCBtYWNoaW5lKTtcbiAgICAgICAgY29ubmVjdGlvbnMuYWRkKGNvbm5lY3Rpb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9zdCA9ICguLi5wYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgW3R5cGUsIGRhdGFdID0gcGFyYW1zO1xuICAgICAgICBjb25uZWN0aW9ucy5mb3JFYWNoKChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgY29ubmVjdGlvbi5wb3N0KHR5cGUsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIG9uID0gKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVycyA9IFtdO1xuICAgICAgICBjb25uZWN0aW9ucy5mb3JFYWNoKChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVycy5wdXNoKGNvbm5lY3Rpb24ub24odHlwZSwgaGFuZGxlcikpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHsgdHlwZSwgaGFuZGxlciwgdW5zdWJzY3JpYmVycyB9O1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcnMuYWRkKHN1YnNjcmliZXIpLCAoKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVycy5mb3JFYWNoKCh1bnN1YikgPT4gdW5zdWIoKSksIHN1YnNjcmliZXJzLmRlbGV0ZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfTtcbiAgICAgIH0sIG9uSW50ZXJuYWxFdmVudCA9ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlcnMgPSBbXTtcbiAgICAgICAgY29ubmVjdGlvbnMuZm9yRWFjaCgoY29ubmVjdGlvbikgPT4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlcnMucHVzaChjb25uZWN0aW9uLmFjdG9yLm9uKHR5cGUsIGhhbmRsZXIpLnVuc3Vic2NyaWJlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSB7IHR5cGUsIGhhbmRsZXIsIHVuc3Vic2NyaWJlcnMgfTtcbiAgICAgICAgcmV0dXJuIGludGVybmFsRXZlbnRTdWJzY3JpYmVycy5hZGQoc3Vic2NyaWJlciksICgpID0+IHtcbiAgICAgICAgICB1bnN1YnNjcmliZXJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKSwgaW50ZXJuYWxFdmVudFN1YnNjcmliZXJzLmRlbGV0ZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfTtcbiAgICAgIH0sIG9uU3RhdHVzID0gKGhhbmRsZXIpID0+IHtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVycyA9IFtdO1xuICAgICAgICBjb25uZWN0aW9ucy5mb3JFYWNoKChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVycy5wdXNoKFxuICAgICAgICAgICAgY29ubmVjdGlvbi5vblN0YXR1cygoc3RhdHVzKSA9PiBoYW5kbGVyKHsgY29ubmVjdGlvbjogY29ubmVjdGlvbi5pZCwgc3RhdHVzIH0pKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0geyBoYW5kbGVyLCB1bnN1YnNjcmliZXJzIH07XG4gICAgICAgIHJldHVybiBzdGF0dXNTdWJzY3JpYmVycy5hZGQoc3Vic2NyaWJlciksICgpID0+IHtcbiAgICAgICAgICB1bnN1YnNjcmliZXJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKSwgc3RhdHVzU3Vic2NyaWJlcnMuZGVsZXRlKHN1YnNjcmliZXIpO1xuICAgICAgICB9O1xuICAgICAgfSwgc3RvcCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbnMyID0gY2hhbm5lbC5jb25uZWN0aW9ucztcbiAgICAgICAgY29ubmVjdGlvbnMyLmZvckVhY2goY2xlYW51cENvbm5lY3Rpb24pLCBjb25uZWN0aW9uczIuY2xlYXIoKSwgY2hhbm5lbHMuZGVsZXRlKGNoYW5uZWwpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9uLFxuICAgICAgICBvbkludGVybmFsRXZlbnQsXG4gICAgICAgIG9uU3RhdHVzLFxuICAgICAgICBwb3N0LFxuICAgICAgICBzdGFydDogKCkgPT4gKGNvbm5lY3Rpb25zLmZvckVhY2goKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uLnN0YXJ0KCksIGNvbm5lY3Rpb24uY29ubmVjdCgpO1xuICAgICAgICB9KSwgc3RvcCksXG4gICAgICAgIHN0b3BcbiAgICAgIH07XG4gICAgfSxcbiAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICBjaGFubmVscy5mb3JFYWNoKCh7IGNvbm5lY3Rpb25zIH0pID0+IHtcbiAgICAgICAgY29ubmVjdGlvbnMuZm9yRWFjaChjbGVhbnVwQ29ubmVjdGlvbiksIGNvbm5lY3Rpb25zLmNsZWFyKCk7XG4gICAgICB9KSwgY2hhbm5lbHMuY2xlYXIoKSwgdGFyZ2V0cy5jbGVhcigpO1xuICAgIH1cbiAgfTtcbn0sIGNyZWF0ZU5vZGVNYWNoaW5lID0gKCkgPT4gc2V0dXAoe1xuICB0eXBlczoge30sXG4gIGFjdG9yczoge1xuICAgIHJlcXVlc3RNYWNoaW5lOiBjcmVhdGVSZXF1ZXN0TWFjaGluZSgpLFxuICAgIGxpc3RlbjogY3JlYXRlTGlzdGVuTG9naWMoKVxuICB9LFxuICBhY3Rpb25zOiB7XG4gICAgXCJidWZmZXIgaW5jb21pbmcgbWVzc2FnZVwiOiBhc3NpZ24oe1xuICAgICAgaGFuZHNoYWtlQnVmZmVyOiAoeyBldmVudCwgY29udGV4dCB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwibWVzc2FnZS5yZWNlaXZlZFwiKSwgWy4uLmNvbnRleHQuaGFuZHNoYWtlQnVmZmVyLCBldmVudF0pXG4gICAgfSksXG4gICAgXCJidWZmZXIgbWVzc2FnZVwiOiBlbnF1ZXVlQWN0aW9ucygoeyBlbnF1ZXVlIH0pID0+IHtcbiAgICAgIGVucXVldWUuYXNzaWduKHtcbiAgICAgICAgYnVmZmVyOiAoeyBldmVudCwgY29udGV4dCB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwicG9zdFwiKSwgW1xuICAgICAgICAgIC4uLmNvbnRleHQuYnVmZmVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgICByZXNvbHZhYmxlOiBldmVudC5yZXNvbHZhYmxlLFxuICAgICAgICAgICAgb3B0aW9uczogZXZlbnQub3B0aW9uc1xuICAgICAgICAgIH1cbiAgICAgICAgXSlcbiAgICAgIH0pLCBlbnF1ZXVlLmVtaXQoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInBvc3RcIiksIHtcbiAgICAgICAgdHlwZTogXCJfYnVmZmVyLmFkZGVkXCIsXG4gICAgICAgIG1lc3NhZ2U6IGV2ZW50LmRhdGFcbiAgICAgIH0pKTtcbiAgICB9KSxcbiAgICBcImNyZWF0ZSByZXF1ZXN0XCI6IGFzc2lnbih7XG4gICAgICByZXF1ZXN0czogKHsgY29udGV4dCwgZXZlbnQsIHNlbGYsIHNwYXduIH0pID0+IHtcbiAgICAgICAgYXNzZXJ0RXZlbnQoZXZlbnQsIFwicmVxdWVzdFwiKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdHMgPSAoQXJyYXkuaXNBcnJheShldmVudC5kYXRhKSA/IGV2ZW50LmRhdGEgOiBbZXZlbnQuZGF0YV0pLm1hcCgocmVxdWVzdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkID0gYHJlcS0ke3Y0KCl9YDtcbiAgICAgICAgICByZXR1cm4gc3Bhd24oXCJyZXF1ZXN0TWFjaGluZVwiLCB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgIGNoYW5uZWxJZDogY29udGV4dC5jaGFubmVsSWQsXG4gICAgICAgICAgICAgIGRhdGE6IHJlcXVlc3QuZGF0YSxcbiAgICAgICAgICAgICAgZG9tYWluOiBjb250ZXh0LmRvbWFpbixcbiAgICAgICAgICAgICAgZXhwZWN0UmVzcG9uc2U6IHJlcXVlc3QuZXhwZWN0UmVzcG9uc2UsXG4gICAgICAgICAgICAgIGZyb206IGNvbnRleHQubmFtZSxcbiAgICAgICAgICAgICAgcGFyZW50UmVmOiBzZWxmLFxuICAgICAgICAgICAgICByZXNvbHZhYmxlOiByZXF1ZXN0LnJlc29sdmFibGUsXG4gICAgICAgICAgICAgIHJlc3BvbnNlVGltZW91dDogcmVxdWVzdC5vcHRpb25zPy5yZXNwb25zZVRpbWVvdXQsXG4gICAgICAgICAgICAgIHJlc3BvbnNlVG86IHJlcXVlc3QucmVzcG9uc2VUbyxcbiAgICAgICAgICAgICAgc2lnbmFsOiByZXF1ZXN0Lm9wdGlvbnM/LnNpZ25hbCxcbiAgICAgICAgICAgICAgc291cmNlczogY29udGV4dC50YXJnZXQsXG4gICAgICAgICAgICAgIHN1cHByZXNzV2FybmluZ3M6IHJlcXVlc3Qub3B0aW9ucz8uc3VwcHJlc3NXYXJuaW5ncyxcbiAgICAgICAgICAgICAgdGFyZ2V0T3JpZ2luOiBjb250ZXh0LnRhcmdldE9yaWdpbixcbiAgICAgICAgICAgICAgdG86IGNvbnRleHQuY29ubmVjdFRvLFxuICAgICAgICAgICAgICB0eXBlOiByZXF1ZXN0LnR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbLi4uY29udGV4dC5yZXF1ZXN0cywgLi4ucmVxdWVzdHNdO1xuICAgICAgfVxuICAgIH0pLFxuICAgIFwiZW1pdCBoZWFydGJlYXRcIjogZW1pdCgoKSA9PiAoe1xuICAgICAgdHlwZTogXCJfaGVhcnRiZWF0XCJcbiAgICB9KSksXG4gICAgXCJlbWl0IHJlY2VpdmVkIG1lc3NhZ2VcIjogZW5xdWV1ZUFjdGlvbnMoKHsgZW5xdWV1ZSB9KSA9PiB7XG4gICAgICBlbnF1ZXVlLmVtaXQoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcIm1lc3NhZ2UucmVjZWl2ZWRcIiksIHtcbiAgICAgICAgdHlwZTogXCJfbWVzc2FnZVwiLFxuICAgICAgICBtZXNzYWdlOiBldmVudC5tZXNzYWdlLmRhdGFcbiAgICAgIH0pKSwgZW5xdWV1ZS5lbWl0KCh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJtZXNzYWdlLnJlY2VpdmVkXCIpLCB7XG4gICAgICAgIHR5cGU6IGV2ZW50Lm1lc3NhZ2UuZGF0YS50eXBlLFxuICAgICAgICBtZXNzYWdlOiBldmVudC5tZXNzYWdlLmRhdGFcbiAgICAgIH0pKTtcbiAgICB9KSxcbiAgICBcImVtaXQgc3RhdHVzXCI6IGVtaXQoKF8sIHBhcmFtcykgPT4gKHtcbiAgICAgIHR5cGU6IFwiX3N0YXR1c1wiLFxuICAgICAgc3RhdHVzOiBwYXJhbXMuc3RhdHVzXG4gICAgfSkpLFxuICAgIFwiZmx1c2ggYnVmZmVyXCI6IGVucXVldWVBY3Rpb25zKCh7IGVucXVldWUgfSkgPT4ge1xuICAgICAgZW5xdWV1ZS5yYWlzZSgoeyBjb250ZXh0IH0pID0+ICh7XG4gICAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5tYXAoKHsgZGF0YSwgcmVzb2x2YWJsZSwgb3B0aW9ucyB9KSA9PiAoe1xuICAgICAgICAgIGRhdGE6IGRhdGEuZGF0YSxcbiAgICAgICAgICB0eXBlOiBkYXRhLnR5cGUsXG4gICAgICAgICAgZXhwZWN0UmVzcG9uc2U6ICEhcmVzb2x2YWJsZSxcbiAgICAgICAgICByZXNvbHZhYmxlLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSkpXG4gICAgICB9KSksIGVucXVldWUuZW1pdCgoeyBjb250ZXh0IH0pID0+ICh7XG4gICAgICAgIHR5cGU6IFwiX2J1ZmZlci5mbHVzaGVkXCIsXG4gICAgICAgIG1lc3NhZ2VzOiBjb250ZXh0LmJ1ZmZlci5tYXAoKHsgZGF0YSB9KSA9PiBkYXRhKVxuICAgICAgfSkpLCBlbnF1ZXVlLmFzc2lnbih7XG4gICAgICAgIGJ1ZmZlcjogW11cbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIFwiZmx1c2ggaGFuZHNoYWtlIGJ1ZmZlclwiOiBlbnF1ZXVlQWN0aW9ucygoeyBjb250ZXh0LCBlbnF1ZXVlIH0pID0+IHtcbiAgICAgIGNvbnRleHQuaGFuZHNoYWtlQnVmZmVyLmZvckVhY2goKGV2ZW50KSA9PiBlbnF1ZXVlLnJhaXNlKGV2ZW50KSksIGVucXVldWUuYXNzaWduKHtcbiAgICAgICAgaGFuZHNoYWtlQnVmZmVyOiBbXVxuICAgICAgfSk7XG4gICAgfSksXG4gICAgcG9zdDogcmFpc2UoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInBvc3RcIiksIHtcbiAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgZGF0YToge1xuICAgICAgICBkYXRhOiBldmVudC5kYXRhLmRhdGEsXG4gICAgICAgIGV4cGVjdFJlc3BvbnNlOiAhIWV2ZW50LnJlc29sdmFibGUsXG4gICAgICAgIHR5cGU6IGV2ZW50LmRhdGEudHlwZSxcbiAgICAgICAgcmVzb2x2YWJsZTogZXZlbnQucmVzb2x2YWJsZSxcbiAgICAgICAgb3B0aW9uczogZXZlbnQub3B0aW9uc1xuICAgICAgfVxuICAgIH0pKSxcbiAgICBcInJlbW92ZSByZXF1ZXN0XCI6IGVucXVldWVBY3Rpb25zKCh7IGNvbnRleHQsIGVucXVldWUsIGV2ZW50IH0pID0+IHtcbiAgICAgIGFzc2VydEV2ZW50KGV2ZW50LCBbXCJyZXF1ZXN0LnN1Y2Nlc3NcIiwgXCJyZXF1ZXN0LmZhaWxlZFwiLCBcInJlcXVlc3QuYWJvcnRlZFwiXSksIHN0b3BDaGlsZChldmVudC5yZXF1ZXN0SWQpLCBlbnF1ZXVlLmFzc2lnbih7IHJlcXVlc3RzOiBjb250ZXh0LnJlcXVlc3RzLmZpbHRlcigoeyBpZCB9KSA9PiBpZCAhPT0gZXZlbnQucmVxdWVzdElkKSB9KTtcbiAgICB9KSxcbiAgICBcInNlbmQgcmVzcG9uc2VcIjogcmFpc2UoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBbXCJtZXNzYWdlLnJlY2VpdmVkXCIsIFwiaGVhcnRiZWF0LnJlY2VpdmVkXCJdKSwge1xuICAgICAgdHlwZTogXCJyZXF1ZXN0XCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHR5cGU6IE1TR19SRVNQT05TRSxcbiAgICAgICAgcmVzcG9uc2VUbzogZXZlbnQubWVzc2FnZS5kYXRhLmlkLFxuICAgICAgICBkYXRhOiB2b2lkIDBcbiAgICAgIH1cbiAgICB9KSksXG4gICAgXCJzZW5kIGhhbmRzaGFrZSBzeW4gYWNrXCI6IHJhaXNlKHtcbiAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgZGF0YTogeyB0eXBlOiBNU0dfSEFORFNIQUtFX1NZTl9BQ0sgfVxuICAgIH0pLFxuICAgIFwic2V0IGNvbm5lY3Rpb24gY29uZmlnXCI6IGFzc2lnbih7XG4gICAgICBjaGFubmVsSWQ6ICh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJoYW5kc2hha2Uuc3luXCIpLCBldmVudC5tZXNzYWdlLmRhdGEuY2hhbm5lbElkKSxcbiAgICAgIHRhcmdldDogKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcImhhbmRzaGFrZS5zeW5cIiksIGV2ZW50Lm1lc3NhZ2Uuc291cmNlIHx8IHZvaWQgMCksXG4gICAgICB0YXJnZXRPcmlnaW46ICh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJoYW5kc2hha2Uuc3luXCIpLCBldmVudC5tZXNzYWdlLm9yaWdpbilcbiAgICB9KVxuICB9LFxuICBndWFyZHM6IHtcbiAgICBoYXNTb3VyY2U6ICh7IGNvbnRleHQgfSkgPT4gY29udGV4dC50YXJnZXQgIT09IG51bGxcbiAgfVxufSkuY3JlYXRlTWFjaGluZSh7XG4gIC8qKiBAeHN0YXRlLWxheW91dCBONElncGdKZzVtRE9JQzVRRHNEMkV3R0lCT1lDT0FybkFDNEIwc0JBeHBYTEFOb0FNQXVvcUFBNnF3Q1d4WHF5ckVBQTlFQVZnWUFXVWdFWUpEVVFBNEpBWm1VU0pDMGNvRHNBR2hBQlBSTklZTFNFcmRPa0JPQUd6YngyMjdZVUJmVi1yUVljK0lyRElBWmdDR1hBQTJrSXdzU0NBYzNMejhnaUlJb2lha3FnQk1ES2JwMnRZUzBzcnAra1lJMHVudW51aGdwRndRNFpnUS1OVmN5QUJ1cUFEVzFWN05kV0FJTGUyVVFmSElrWkdDc1R4OEF0Rko2YUtpcEF6V090cnBDN1o1QlVXR2lOb0s2YVMyNlJMVzJ0TGFxa3FxRlNBOU5YMllBTGEwUVRDa3VEUmNyUkhNazV4cGdrNW9nSkxaU05aSVZEb1ZDRkxaaW9oYklWU0xrWExaUkhaRGd4YkhjSHJWNnJGaUJOb2xOUm9sRVZKYkNzZEdVenNveWhpRWNsbE9DMURvd2VsVm1Wck9VUFBjcXFRQUJaQlpBUVdEQ2pvdEtBTkpvMU5xZGJvQzRXaThWQlNYSUtBRGVYRFViamY0a3dGa2tFSUxiZzhSWk1IS096V0t6S0prSEphMDg2WGE0cVpTNHBVaXNVU3FVK1Fna1luc1EwemNuSmFSTERicFp3S05RU0JZc3BtMk1FeUM1S1RuYURTU2QxOGg3SzcxcTMyRXdNeFlQQTBCSkZMS1k1eVp4SXJLU1VSTTBSbkZIU0JUclFxUTliYWJRZWpCQ3IycTlYU2lCY1dDVWZqSU1DVUluNm9OeEVQR3RUV0ZGUjBSVXk3aUd6dCszSXAwWFVSWFZaS1B2VkNmSUtjenlCK3Z5enFMem9HemN1SUcwTUdUeUN6dGpSdGphSmpiSFZNTkFVVGR1MVBVaHowdllocnlMT2NTd1hNdGhCZkswWkdzTFFHQlpla0NpMEpzbzFJZEkyM1dHMDR6T0U0d0lnNmNvSWdCb3gzSW1kaTFKUmRueE5PeFNITlNRa1d0VzBtVGpNeE1RN2ZEemdjYk5LbjdXaktKZU40UGkrTUFmaitlODRNZlVNRkhiWlp3eE9IWk5EeU8wOWdRT1FqbUFoWkpDTTlJTWpJeWNLT3ZRVXdDQ2JCaUFBSTJzc2hwTmtpQjZOTEo5RUlRQlFiV09kSmxNaFlDVWpiSmtjaFhHc0Ztc0pRTVZzV2wzQnpLcDRHaUhvQVhnanlrZ0FXbWtaWjZ4eTNMWkYyRW9iQ3k2eHNRV0pRNDJrRTRGakEtRXdCU3hUalNSVWhEZ3FremdPMkJ4ZHlrVTRBdlhGUS1Lak1DOHlIS1Y2cU5KaTZXT2RjeXBjWnNYR3hlMEpHMFh5U0tqTTVsS3NNeUx3c2lBeHNZenlsRGZPTnpuVUVxcm1pKzFUaGtIcVhET05iVUxpMXdnQSAqL1xuICBpZDogXCJub2RlXCIsXG4gIGNvbnRleHQ6ICh7IGlucHV0IH0pID0+ICh7XG4gICAgYnVmZmVyOiBbXSxcbiAgICBjaGFubmVsSWQ6IG51bGwsXG4gICAgY29ubmVjdFRvOiBpbnB1dC5jb25uZWN0VG8sXG4gICAgZG9tYWluOiBpbnB1dC5kb21haW4gPz8gRE9NQUlOLFxuICAgIGhhbmRzaGFrZUJ1ZmZlcjogW10sXG4gICAgbmFtZTogaW5wdXQubmFtZSxcbiAgICByZXF1ZXN0czogW10sXG4gICAgdGFyZ2V0OiB2b2lkIDAsXG4gICAgdGFyZ2V0T3JpZ2luOiBudWxsXG4gIH0pLFxuICAvLyBBbHdheXMgbGlzdGVuIGZvciBoYW5kc2hha2Ugc3luIG1lc3NhZ2VzLiBUaGUgY2hhbm5lbCBjb3VsZCBoYXZlXG4gIC8vIGRpc2Nvbm5lY3RlZCB3aXRob3V0IGJlaW5nIGFibGUgdG8gbm90aWZ5IHRoZSBub2RlLCBhbmQgc28gbmVlZCB0b1xuICAvLyByZS1lc3RhYmxpc2ggdGhlIGNvbm5lY3Rpb24uXG4gIGludm9rZToge1xuICAgIGlkOiBcImxpc3RlbiBmb3IgaGFuZHNoYWtlIHN5blwiLFxuICAgIHNyYzogXCJsaXN0ZW5cIixcbiAgICBpbnB1dDogbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICBpbmNsdWRlOiBNU0dfSEFORFNIQUtFX1NZTixcbiAgICAgIHJlc3BvbnNlVHlwZTogXCJoYW5kc2hha2Uuc3luXCJcbiAgICB9KVxuICB9LFxuICBvbjoge1xuICAgIFwicmVxdWVzdC5zdWNjZXNzXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwicmVtb3ZlIHJlcXVlc3RcIlxuICAgIH0sXG4gICAgXCJyZXF1ZXN0LmZhaWxlZFwiOiB7XG4gICAgICBhY3Rpb25zOiBcInJlbW92ZSByZXF1ZXN0XCJcbiAgICB9LFxuICAgIFwicmVxdWVzdC5hYm9ydGVkXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwicmVtb3ZlIHJlcXVlc3RcIlxuICAgIH0sXG4gICAgXCJoYW5kc2hha2Uuc3luXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwic2V0IGNvbm5lY3Rpb24gY29uZmlnXCIsXG4gICAgICB0YXJnZXQ6IFwiLmhhbmRzaGFraW5nXCJcbiAgICB9XG4gIH0sXG4gIGluaXRpYWw6IFwiaWRsZVwiLFxuICBzdGF0ZXM6IHtcbiAgICBpZGxlOiB7XG4gICAgICBlbnRyeTogW3sgdHlwZTogXCJlbWl0IHN0YXR1c1wiLCBwYXJhbXM6IHsgc3RhdHVzOiBcImlkbGVcIiB9IH1dLFxuICAgICAgb246IHtcbiAgICAgICAgcG9zdDoge1xuICAgICAgICAgIGFjdGlvbnM6IFwiYnVmZmVyIG1lc3NhZ2VcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kc2hha2luZzoge1xuICAgICAgZ3VhcmQ6IFwiaGFzU291cmNlXCIsXG4gICAgICBlbnRyeTogW1wic2VuZCBoYW5kc2hha2Ugc3luIGFja1wiLCB7IHR5cGU6IFwiZW1pdCBzdGF0dXNcIiwgcGFyYW1zOiB7IHN0YXR1czogXCJoYW5kc2hha2luZ1wiIH0gfV0sXG4gICAgICBpbnZva2U6IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcImxpc3RlbiBmb3IgaGFuZHNoYWtlIGFja1wiLFxuICAgICAgICAgIHNyYzogXCJsaXN0ZW5cIixcbiAgICAgICAgICBpbnB1dDogbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICAgICAgICBpbmNsdWRlOiBNU0dfSEFORFNIQUtFX0FDSyxcbiAgICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgYG1lc3NhZ2UucmVjZWl2ZWRgIHJlc3BvbnNlVHlwZSB0byBwcmV2ZW50XG4gICAgICAgICAgICAvLyBidWZmZXJpbmcgdGhlIGFjayBtZXNzYWdlLiBXZSB0cmFuc2l0aW9uIHRvIHRoZSBjb25uZWN0ZWQgc3RhdGVcbiAgICAgICAgICAgIC8vIHVzaW5nIG9uRG9uZSBpbnN0ZWFkIG9mIGxpc3RlbmluZyB0byB0aGlzIGV2ZW50IHVzaW5nIGBvbmBcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogXCJoYW5kc2hha2UuY29tcGxldGVcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG9uRG9uZTogXCJjb25uZWN0ZWRcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwibGlzdGVuIGZvciBkaXNjb25uZWN0XCIsXG4gICAgICAgICAgc3JjOiBcImxpc3RlblwiLFxuICAgICAgICAgIGlucHV0OiBsaXN0ZW5JbnB1dEZyb21Db250ZXh0KHtcbiAgICAgICAgICAgIGluY2x1ZGU6IE1TR19ESVNDT05ORUNULFxuICAgICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6IFwiZGlzY29ubmVjdFwiXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcImxpc3RlbiBmb3IgbWVzc2FnZXNcIixcbiAgICAgICAgICBzcmM6IFwibGlzdGVuXCIsXG4gICAgICAgICAgaW5wdXQ6IGxpc3RlbklucHV0RnJvbUNvbnRleHQoe1xuICAgICAgICAgICAgZXhjbHVkZTogW1xuICAgICAgICAgICAgICBNU0dfRElTQ09OTkVDVCxcbiAgICAgICAgICAgICAgTVNHX0hBTkRTSEFLRV9TWU4sXG4gICAgICAgICAgICAgIE1TR19IQU5EU0hBS0VfQUNLLFxuICAgICAgICAgICAgICBNU0dfSEVBUlRCRUFULFxuICAgICAgICAgICAgICBNU0dfUkVTUE9OU0VcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgb246IHtcbiAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgIGFjdGlvbnM6IFwiY3JlYXRlIHJlcXVlc3RcIlxuICAgICAgICB9LFxuICAgICAgICBwb3N0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJidWZmZXIgbWVzc2FnZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWVzc2FnZS5yZWNlaXZlZFwiOiB7XG4gICAgICAgICAgYWN0aW9uczogXCJidWZmZXIgaW5jb21pbmcgbWVzc2FnZVwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc2Nvbm5lY3Q6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbm5lY3RlZDoge1xuICAgICAgZW50cnk6IFtcbiAgICAgICAgXCJmbHVzaCBoYW5kc2hha2UgYnVmZmVyXCIsXG4gICAgICAgIFwiZmx1c2ggYnVmZmVyXCIsXG4gICAgICAgIHsgdHlwZTogXCJlbWl0IHN0YXR1c1wiLCBwYXJhbXM6IHsgc3RhdHVzOiBcImNvbm5lY3RlZFwiIH0gfVxuICAgICAgXSxcbiAgICAgIGludm9rZTogW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwibGlzdGVuIGZvciBtZXNzYWdlc1wiLFxuICAgICAgICAgIHNyYzogXCJsaXN0ZW5cIixcbiAgICAgICAgICBpbnB1dDogbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICAgICAgICBleGNsdWRlOiBbXG4gICAgICAgICAgICAgIE1TR19ESVNDT05ORUNULFxuICAgICAgICAgICAgICBNU0dfSEFORFNIQUtFX1NZTixcbiAgICAgICAgICAgICAgTVNHX0hBTkRTSEFLRV9BQ0ssXG4gICAgICAgICAgICAgIE1TR19IRUFSVEJFQVQsXG4gICAgICAgICAgICAgIE1TR19SRVNQT05TRVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogXCJsaXN0ZW4gZm9yIGhlYXJ0YmVhdFwiLFxuICAgICAgICAgIHNyYzogXCJsaXN0ZW5cIixcbiAgICAgICAgICBpbnB1dDogbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICAgICAgICBpbmNsdWRlOiBNU0dfSEVBUlRCRUFULFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBcImhlYXJ0YmVhdC5yZWNlaXZlZFwiXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcImxpc3RlbiBmb3IgZGlzY29ubmVjdFwiLFxuICAgICAgICAgIHNyYzogXCJsaXN0ZW5cIixcbiAgICAgICAgICBpbnB1dDogbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICAgICAgICBpbmNsdWRlOiBNU0dfRElTQ09OTkVDVCxcbiAgICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBcImRpc2Nvbm5lY3RcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBvbjoge1xuICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJjcmVhdGUgcmVxdWVzdFwiXG4gICAgICAgIH0sXG4gICAgICAgIHBvc3Q6IHtcbiAgICAgICAgICBhY3Rpb25zOiBcInBvc3RcIlxuICAgICAgICB9LFxuICAgICAgICBkaXNjb25uZWN0OiB7XG4gICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIlxuICAgICAgICB9LFxuICAgICAgICBcIm1lc3NhZ2UucmVjZWl2ZWRcIjoge1xuICAgICAgICAgIGFjdGlvbnM6IFtcInNlbmQgcmVzcG9uc2VcIiwgXCJlbWl0IHJlY2VpdmVkIG1lc3NhZ2VcIl1cbiAgICAgICAgfSxcbiAgICAgICAgXCJoZWFydGJlYXQucmVjZWl2ZWRcIjoge1xuICAgICAgICAgIGFjdGlvbnM6IFtcInNlbmQgcmVzcG9uc2VcIiwgXCJlbWl0IGhlYXJ0YmVhdFwiXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KSwgY3JlYXRlTm9kZSA9IChpbnB1dCwgbWFjaGluZSA9IGNyZWF0ZU5vZGVNYWNoaW5lKCkpID0+IHtcbiAgY29uc3QgYWN0b3IgPSBjcmVhdGVBY3RvcihtYWNoaW5lLCB7XG4gICAgaW5wdXRcbiAgfSksIG9uID0gKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICBjb25zdCB7IHVuc3Vic2NyaWJlIH0gPSBhY3Rvci5vbihcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQHRvZG8gUmVjZWl2ZWRFbWl0RXZlbnQgY2F1c2VzIHRoaXNcbiAgICAgIHR5cGUsXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgaGFuZGxlcihldmVudC5tZXNzYWdlLmRhdGEpO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBvblN0YXR1cyA9IChoYW5kbGVyLCBmaWx0ZXIyKSA9PiB7XG4gICAgY29uc3QgeyB1bnN1YnNjcmliZSB9ID0gYWN0b3Iub24oXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEB0b2RvIFJlY2VpdmVkRW1pdEV2ZW50IGNhdXNlcyB0aGlzXG4gICAgICBcIl9zdGF0dXNcIixcbiAgICAgIChldmVudCkgPT4ge1xuICAgICAgICBmaWx0ZXIyICYmIGV2ZW50LnN0YXR1cyAhPT0gZmlsdGVyMiB8fCBoYW5kbGVyKGV2ZW50LnN0YXR1cyk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIHBvc3QgPSAodHlwZSwgZGF0YSkgPT4ge1xuICAgIGNvbnN0IF9kYXRhID0geyB0eXBlLCBkYXRhIH07XG4gICAgYWN0b3Iuc2VuZCh7IHR5cGU6IFwicG9zdFwiLCBkYXRhOiBfZGF0YSB9KTtcbiAgfSwgZmV0Y2ggPSAodHlwZSwgZGF0YSwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgcmVzcG9uc2VUaW1lb3V0ID0gRkVUQ0hfVElNRU9VVF9ERUZBVUxULCBzaWduYWwsIHN1cHByZXNzV2FybmluZ3MgfSA9IG9wdGlvbnMgfHwge30sIHJlc29sdmFibGUgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKSwgX2RhdGEgPSB7IHR5cGUsIGRhdGEgfTtcbiAgICByZXR1cm4gYWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcInBvc3RcIixcbiAgICAgIGRhdGE6IF9kYXRhLFxuICAgICAgcmVzb2x2YWJsZSxcbiAgICAgIG9wdGlvbnM6IHsgcmVzcG9uc2VUaW1lb3V0LCBzaWduYWwsIHN1cHByZXNzV2FybmluZ3MgfVxuICAgIH0pLCByZXNvbHZhYmxlLnByb21pc2U7XG4gIH0sIHN0b3AgPSAoKSA9PiB7XG4gICAgYWN0b3Iuc3RvcCgpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGFjdG9yLFxuICAgIGZldGNoLFxuICAgIG1hY2hpbmUsXG4gICAgb24sXG4gICAgb25TdGF0dXMsXG4gICAgcG9zdCxcbiAgICBzdGFydDogKCkgPT4gKGFjdG9yLnN0YXJ0KCksIHN0b3ApLFxuICAgIHN0b3BcbiAgfTtcbn07XG5leHBvcnQge1xuICBET01BSU4sXG4gIEZFVENIX1RJTUVPVVRfREVGQVVMVCxcbiAgSEFORFNIQUtFX0lOVEVSVkFMLFxuICBIQU5EU0hBS0VfTVNHX1RZUEVTLFxuICBIRUFSVEJFQVRfSU5URVJWQUwsXG4gIElOVEVSTkFMX01TR19UWVBFUyxcbiAgTVNHX0RJU0NPTk5FQ1QsXG4gIE1TR19IQU5EU0hBS0VfQUNLLFxuICBNU0dfSEFORFNIQUtFX1NZTixcbiAgTVNHX0hBTkRTSEFLRV9TWU5fQUNLLFxuICBNU0dfSEVBUlRCRUFULFxuICBNU0dfUkVTUE9OU0UsXG4gIFJFU1BPTlNFX1RJTUVPVVRfREVGQVVMVCxcbiAgY3JlYXRlQ29ubmVjdGlvbixcbiAgY3JlYXRlQ29ubmVjdGlvbk1hY2hpbmUsXG4gIGNyZWF0ZUNvbnRyb2xsZXIsXG4gIGNyZWF0ZUxpc3RlbkxvZ2ljLFxuICBjcmVhdGVOb2RlLFxuICBjcmVhdGVOb2RlTWFjaGluZSxcbiAgY3JlYXRlUmVxdWVzdE1hY2hpbmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/comlink/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@sanity/diff-match-patch/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DIFF_DELETE: () => (/* binding */ DIFF_DELETE),\n/* harmony export */   DIFF_EQUAL: () => (/* binding */ DIFF_EQUAL),\n/* harmony export */   DIFF_INSERT: () => (/* binding */ DIFF_INSERT),\n/* harmony export */   adjustIndiciesToUcs2: () => (/* binding */ adjustIndiciesToUcs2),\n/* harmony export */   applyPatches: () => (/* binding */ apply),\n/* harmony export */   cleanupEfficiency: () => (/* binding */ cleanupEfficiency),\n/* harmony export */   cleanupSemantic: () => (/* binding */ cleanupSemantic),\n/* harmony export */   makeDiff: () => (/* binding */ diff),\n/* harmony export */   makePatches: () => (/* binding */ make),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   parsePatch: () => (/* binding */ parse),\n/* harmony export */   stringifyPatch: () => (/* binding */ stringifyPatch),\n/* harmony export */   stringifyPatches: () => (/* binding */ stringify)\n/* harmony export */ });\nfunction cloneDiff(diff2) {\n  const [type, patch] = diff2;\n  return [type, patch];\n}\nfunction getCommonOverlap(textA, textB) {\n  let text1 = textA, text2 = textB;\n  const text1Length = text1.length, text2Length = text2.length;\n  if (text1Length === 0 || text2Length === 0)\n    return 0;\n  text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));\n  const textLength = Math.min(text1Length, text2Length);\n  if (text1 === text2)\n    return textLength;\n  let best = 0, length = 1;\n  for (let found = 0; found !== -1; ) {\n    const pattern = text1.substring(textLength - length);\n    if (found = text2.indexOf(pattern), found === -1)\n      return best;\n    length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);\n  }\n  return best;\n}\nfunction getCommonPrefix(text1, text2) {\n  if (!text1 || !text2 || text1[0] !== text2[0])\n    return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;\n  for (; pointerMin < pointerMid; )\n    text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction getCommonSuffix(text1, text2) {\n  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1])\n    return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;\n  for (; pointerMin < pointerMid; )\n    text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction isHighSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 55296 && charCode <= 56319;\n}\nfunction isLowSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 56320 && charCode <= 57343;\n}\nfunction bisect(text1, text2, deadline) {\n  const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);\n  for (let x = 0; x < vLength; x++)\n    v1[x] = -1, v2[x] = -1;\n  v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;\n  const delta = text1Length - text2Length, front = delta % 2 !== 0;\n  let k1start = 0, k1end = 0, k2start = 0, k2end = 0;\n  for (let d = 0; d < maxD && !(Date.now() > deadline); d++) {\n    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      const k1Offset = vOffset + k1;\n      let x1;\n      k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;\n      let y1 = x1 - k1;\n      for (; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1); )\n        x1++, y1++;\n      if (v1[k1Offset] = x1, x1 > text1Length)\n        k1end += 2;\n      else if (y1 > text2Length)\n        k1start += 2;\n      else if (front) {\n        const k2Offset = vOffset + delta - k1;\n        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n          const x2 = text1Length - v2[k2Offset];\n          if (x1 >= x2)\n            return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      const k2Offset = vOffset + k2;\n      let x2;\n      k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;\n      let y2 = x2 - k2;\n      for (; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1); )\n        x2++, y2++;\n      if (v2[k2Offset] = x2, x2 > text1Length)\n        k2end += 2;\n      else if (y2 > text2Length)\n        k2start += 2;\n      else if (!front) {\n        const k1Offset = vOffset + delta - k2;\n        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n          const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;\n          if (x2 = text1Length - x2, x1 >= x2)\n            return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n  }\n  return [\n    [DIFF_DELETE, text1],\n    [DIFF_INSERT, text2]\n  ];\n}\nfunction bisectSplit(text1, text2, x, y, deadline) {\n  const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, { checkLines: !1, deadline }), diffsb = doDiff(text1b, text2b, { checkLines: !1, deadline });\n  return diffs.concat(diffsb);\n}\nfunction findHalfMatch(text1, text2, timeout = 1) {\n  if (timeout <= 0)\n    return null;\n  const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;\n  if (longText.length < 4 || shortText.length * 2 < longText.length)\n    return null;\n  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));\n  let halfMatch;\n  if (halfMatch1 && halfMatch2)\n    halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;\n  else {\n    if (!halfMatch1 && !halfMatch2)\n      return null;\n    halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;\n  }\n  if (!halfMatch)\n    throw new Error(\"Unable to find a half match.\");\n  let text1A, text1B, text2A, text2B;\n  text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);\n  const midCommon = halfMatch[4];\n  return [text1A, text1B, text2A, text2B, midCommon];\n}\nfunction halfMatchI(longText, shortText, i) {\n  const seed = longText.slice(i, i + Math.floor(longText.length / 4));\n  let j = -1, bestCommon = \"\", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;\n  for (; (j = shortText.indexOf(seed, j + 1)) !== -1; ) {\n    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));\n    bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));\n  }\n  return bestCommon.length * 2 >= longText.length ? [\n    bestLongTextA || \"\",\n    bestLongTextB || \"\",\n    bestShortTextA || \"\",\n    bestShortTextB || \"\",\n    bestCommon || \"\"\n  ] : null;\n}\nfunction charsToLines(diffs, lineArray) {\n  for (let x = 0; x < diffs.length; x++) {\n    const chars = diffs[x][1], text = [];\n    for (let y = 0; y < chars.length; y++)\n      text[y] = lineArray[chars.charCodeAt(y)];\n    diffs[x][1] = text.join(\"\");\n  }\n}\nfunction linesToChars(textA, textB) {\n  const lineArray = [], lineHash = {};\n  lineArray[0] = \"\";\n  function diffLinesToMunge(text) {\n    let chars = \"\", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;\n    for (; lineEnd < text.length - 1; ) {\n      lineEnd = text.indexOf(`\n`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);\n      let line = text.slice(lineStart, lineEnd + 1);\n      (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  let maxLines = 4e4;\n  const chars1 = diffLinesToMunge(textA);\n  maxLines = 65535;\n  const chars2 = diffLinesToMunge(textB);\n  return { chars1, chars2, lineArray };\n}\nfunction doLineModeDiff(textA, textB, opts) {\n  let text1 = textA, text2 = textB;\n  const a = linesToChars(text1, text2);\n  text1 = a.chars1, text2 = a.chars2;\n  const linearray = a.lineArray;\n  let diffs = doDiff(text1, text2, {\n    checkLines: !1,\n    deadline: opts.deadline\n  });\n  charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\";\n  for (; pointer < diffs.length; ) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        if (countDelete >= 1 && countInsert >= 1) {\n          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;\n          const aa = doDiff(textDelete, textInsert, {\n            checkLines: !1,\n            deadline: opts.deadline\n          });\n          for (let j = aa.length - 1; j >= 0; j--)\n            diffs.splice(pointer, 0, aa[j]);\n          pointer += aa.length;\n        }\n        countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n    pointer++;\n  }\n  return diffs.pop(), diffs;\n}\nfunction computeDiff(text1, text2, opts) {\n  let diffs;\n  if (!text1)\n    return [[DIFF_INSERT, text2]];\n  if (!text2)\n    return [[DIFF_DELETE, text1]];\n  const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);\n  if (i !== -1)\n    return diffs = [\n      [DIFF_INSERT, longtext.substring(0, i)],\n      [DIFF_EQUAL, shorttext],\n      [DIFF_INSERT, longtext.substring(i + shorttext.length)]\n    ], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;\n  if (shorttext.length === 1)\n    return [\n      [DIFF_DELETE, text1],\n      [DIFF_INSERT, text2]\n    ];\n  const halfMatch = findHalfMatch(text1, text2);\n  if (halfMatch) {\n    const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);\n    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n  }\n  return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);\n}\nvar __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b))\n      __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  return a;\n};\nconst DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;\nfunction diff(textA, textB, opts) {\n  if (textA === null || textB === null)\n    throw new Error(\"Null input. (diff)\");\n  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));\n  return adjustDiffForSurrogatePairs(diffs), diffs;\n}\nfunction doDiff(textA, textB, options) {\n  let text1 = textA, text2 = textB;\n  if (text1 === text2)\n    return text1 ? [[DIFF_EQUAL, text1]] : [];\n  let commonlength = getCommonPrefix(text1, text2);\n  const commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);\n  const commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);\n  let diffs = computeDiff(text1, text2, options);\n  return commonprefix && diffs.unshift([DIFF_EQUAL, commonprefix]), commonsuffix && diffs.push([DIFF_EQUAL, commonsuffix]), diffs = cleanupMerge(diffs), diffs;\n}\nfunction createDeadLine(timeout) {\n  let t = 1;\n  return typeof timeout < \"u\" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;\n}\nfunction createInternalOpts(opts) {\n  return __spreadValues$2({\n    checkLines: !0,\n    deadline: createDeadLine(opts.timeout || 1)\n  }, opts);\n}\nfunction combineChar(data, char, dir) {\n  return dir === 1 ? data + char : char + data;\n}\nfunction splitChar(data, dir) {\n  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];\n}\nfunction hasSharedChar(diffs, i, j, dir) {\n  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];\n}\nfunction deisolateChar(diffs, i, dir) {\n  const inv = dir === 1 ? -1 : 1;\n  let insertIdx = null, deleteIdx = null, j = i + dir;\n  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {\n    const [op, text2] = diffs[j];\n    if (text2.length !== 0) {\n      if (op === DIFF_INSERT) {\n        insertIdx === null && (insertIdx = j);\n        continue;\n      } else if (op === DIFF_DELETE) {\n        deleteIdx === null && (deleteIdx = j);\n        continue;\n      } else if (op === DIFF_EQUAL) {\n        if (insertIdx === null && deleteIdx === null) {\n          const [rest, char2] = splitChar(diffs[i][1], dir);\n          diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);\n          return;\n        }\n        break;\n      }\n    }\n  }\n  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {\n    const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);\n    diffs[insertIdx][1] = insertText, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);\n    return;\n  }\n  const [text, char] = splitChar(diffs[i][1], dir);\n  diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [DIFF_INSERT, char]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [DIFF_DELETE, char]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);\n}\nfunction adjustDiffForSurrogatePairs(diffs) {\n  for (let i = 0; i < diffs.length; i++) {\n    const [diffType, diffText] = diffs[i];\n    if (diffText.length === 0) continue;\n    const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];\n    isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);\n  }\n  for (let i = 0; i < diffs.length; i++)\n    diffs[i][1].length === 0 && diffs.splice(i, 1);\n}\nfunction cleanupSemantic(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;\n  for (; pointer < diffs.length; )\n    diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;\n  for (hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);\n      overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;\n    }\n    pointer++;\n  }\n  return diffs;\n}\nconst nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\\s/, linebreakRegex = /[\\r\\n]/, blanklineEndRegex = /\\n\\r?\\n$/, blanklineStartRegex = /^\\r?\\n\\r?\\n/;\nfunction cleanupSemanticLossless(rawDiffs) {\n  const diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  function diffCleanupSemanticScore(one, two) {\n    if (!one || !two)\n      return 6;\n    const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);\n    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;\n  }\n  let pointer = 1;\n  for (; pointer < diffs.length - 1; ) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];\n      const commonOffset = getCommonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n      for (; edit.charAt(0) === equality2.charAt(0); ) {\n        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);\n        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);\n      }\n      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));\n    }\n    pointer++;\n  }\n  return diffs;\n}\nfunction cleanupMerge(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\", commonlength;\n  for (; pointer < diffs.length; )\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1], pointer++;\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1], pointer++;\n        break;\n      case DIFF_EQUAL:\n        countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(\n          0,\n          commonlength\n        ) : (diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation\");\n    }\n  diffs[diffs.length - 1][1] === \"\" && diffs.pop();\n  let hasChanges = !1;\n  for (pointer = 1; pointer < diffs.length - 1; )\n    diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction trueCount(...args) {\n  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);\n}\nfunction cleanupEfficiency(rawDiffs, editCost = 4) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;\n  for (; pointer < diffs.length; )\n    diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nvar __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b))\n      __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  return a;\n};\nconst DEFAULT_OPTIONS = {\n  /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   */\n  threshold: 0.5,\n  /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   */\n  distance: 1e3\n};\nfunction applyDefaults(options) {\n  return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);\n}\nconst MAX_BITS$1 = 32;\nfunction bitap(text, pattern, loc, opts = {}) {\n  if (pattern.length > MAX_BITS$1)\n    throw new Error(\"Pattern too long for this browser.\");\n  const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);\n  function getBitapScore(e, x) {\n    const accuracy = e / pattern.length, proximity = Math.abs(loc - x);\n    return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;\n  }\n  let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);\n  bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));\n  const matchmask = 1 << pattern.length - 1;\n  bestLoc = -1;\n  let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];\n  for (let d = 0; d < pattern.length; d++) {\n    for (binMin = 0, binMid = binMax; binMin < binMid; )\n      getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    binMax = binMid;\n    let start = Math.max(1, loc - binMid + 1);\n    const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (let j = finish; j >= start; j--) {\n      const charMatch = s[text.charAt(j - 1)];\n      if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {\n        const score = getBitapScore(d, j - 1);\n        if (score <= scoreThreshold)\n          if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc)\n            start = Math.max(1, 2 * loc - bestLoc);\n          else\n            break;\n      }\n    }\n    if (getBitapScore(d + 1, loc) > scoreThreshold)\n      break;\n    lastRd = rd;\n  }\n  return bestLoc;\n}\nfunction getAlphabetFromPattern(pattern) {\n  const s = {};\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] = 0;\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n  return s;\n}\nfunction match(text, pattern, searchLocation) {\n  if (text === null || pattern === null || searchLocation === null)\n    throw new Error(\"Null input. (match())\");\n  const loc = Math.max(0, Math.min(searchLocation, text.length));\n  if (text === pattern)\n    return 0;\n  if (text.length) {\n    if (text.substring(loc, loc + pattern.length) === pattern)\n      return loc;\n  } else return -1;\n  return bitap(text, pattern, loc);\n}\nfunction diffText1(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++)\n    diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction diffText2(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++)\n    diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction levenshtein(diffs) {\n  let leven = 0, insertions = 0, deletions = 0;\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0], data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n  }\n  return leven += Math.max(insertions, deletions), leven;\n}\nfunction xIndex(diffs, loc) {\n  let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;\n  for (x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > loc)); x++)\n    lastChars1 = chars1, lastChars2 = chars2;\n  return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (loc - lastChars1);\n}\nfunction countUtf8Bytes(str) {\n  let bytes = 0;\n  for (let i = 0; i < str.length; i++) {\n    const codePoint = str.codePointAt(i);\n    if (typeof codePoint > \"u\")\n      throw new Error(\"Failed to get codepoint\");\n    bytes += utf8len(codePoint);\n  }\n  return bytes;\n}\nfunction adjustIndiciesToUcs2(patches, base, options = {}) {\n  let byteOffset = 0, idx = 0;\n  function advanceTo(target) {\n    for (; byteOffset < target; ) {\n      const codePoint = base.codePointAt(idx);\n      if (typeof codePoint > \"u\")\n        return idx;\n      byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;\n    }\n    if (!options.allowExceedingIndices && byteOffset !== target)\n      throw new Error(\"Failed to determine byte offset\");\n    return idx;\n  }\n  const adjusted = [];\n  for (const patch of patches)\n    adjusted.push({\n      diffs: patch.diffs.map((diff2) => cloneDiff(diff2)),\n      start1: advanceTo(patch.start1),\n      start2: advanceTo(patch.start2),\n      utf8Start1: patch.utf8Start1,\n      utf8Start2: patch.utf8Start2,\n      length1: patch.length1,\n      length2: patch.length2,\n      utf8Length1: patch.utf8Length1,\n      utf8Length2: patch.utf8Length2\n    });\n  return adjusted;\n}\nfunction utf8len(codePoint) {\n  return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;\n}\nconst MAX_BITS = 32, DEFAULT_MARGIN = 4;\nfunction addPadding(patches, margin = DEFAULT_MARGIN) {\n  const paddingLength = margin;\n  let nullPadding = \"\";\n  for (let x = 1; x <= paddingLength; x++)\n    nullPadding += String.fromCharCode(x);\n  for (const p of patches)\n    p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;\n  let patch = patches[0], diffs = patch.diffs;\n  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL)\n    diffs.unshift([DIFF_EQUAL, nullPadding]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[0][1].length) {\n    const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;\n    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL)\n    diffs.push([DIFF_EQUAL, nullPadding]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  return nullPadding;\n}\nfunction createPatchObject(start1, start2) {\n  return {\n    diffs: [],\n    start1,\n    start2,\n    utf8Start1: start1,\n    utf8Start2: start2,\n    length1: 0,\n    length2: 0,\n    utf8Length1: 0,\n    utf8Length2: 0\n  };\n}\nfunction splitMax(patches, margin = DEFAULT_MARGIN) {\n  const patchSize = MAX_BITS;\n  for (let x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patchSize)\n      continue;\n    const bigpatch = patches[x];\n    patches.splice(x--, 1);\n    let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = \"\";\n    for (; bigpatch.diffs.length !== 0; ) {\n      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);\n      let empty = !0;\n      if (preContext !== \"\") {\n        const precontextByteCount = countUtf8Bytes(preContext);\n        patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([DIFF_EQUAL, preContext]);\n      }\n      for (; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin; ) {\n        const diffType = bigpatch.diffs[0][0];\n        let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);\n        if (diffType === DIFF_INSERT) {\n          patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;\n          const diff2 = bigpatch.diffs.shift();\n          diff2 && patch.diffs.push(diff2), empty = !1;\n        } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([diffType, diffText]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([diffType, diffText]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));\n      }\n      preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);\n      const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);\n      postContext !== \"\" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([DIFF_EQUAL, postContext])), empty || patches.splice(++x, 0, patch);\n    }\n  }\n}\nfunction apply(patches, originalText, opts = {}) {\n  if (typeof patches == \"string\")\n    throw new Error(\"Patches must be an array - pass the patch to `parsePatch()` first\");\n  let text = originalText;\n  if (patches.length === 0)\n    return [text, []];\n  const parsed = adjustIndiciesToUcs2(patches, text, {\n    allowExceedingIndices: opts.allowExceedingIndices\n  }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);\n  text = nullPadding + text + nullPadding, splitMax(parsed, margin);\n  let delta = 0;\n  const results = [];\n  for (let x = 0; x < parsed.length; x++) {\n    const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);\n    let startLoc, endLoc = -1;\n    if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(\n      text,\n      text1.substring(text1.length - MAX_BITS),\n      expectedLoc + text1.length - MAX_BITS\n    ), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1)\n      results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;\n    else {\n      results[x] = !0, delta = startLoc - expectedLoc;\n      let text2;\n      if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2)\n        text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);\n      else {\n        let diffs = diff(text1, text2, { checkLines: !1 });\n        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold)\n          results[x] = !1;\n        else {\n          diffs = cleanupSemanticLossless(diffs);\n          let index1 = 0, index2 = 0;\n          for (let y = 0; y < parsed[x].diffs.length; y++) {\n            const mod = parsed[x].diffs[y];\n            mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);\n          }\n        }\n      }\n    }\n  }\n  return text = text.substring(nullPadding.length, text.length - nullPadding.length), [text, results];\n}\nvar __defProp = Object.defineProperty, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b))\n      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  return a;\n};\nconst DEFAULT_OPTS = {\n  margin: 4\n};\nfunction getDefaultOpts(opts = {}) {\n  return __spreadValues(__spreadValues({}, DEFAULT_OPTS), opts);\n}\nfunction make(a, b, options) {\n  if (typeof a == \"string\" && typeof b == \"string\") {\n    let diffs = diff(a, b, { checkLines: !0 });\n    return diffs.length > 2 && (diffs = cleanupSemantic(diffs), diffs = cleanupEfficiency(diffs)), _make(a, diffs, getDefaultOpts(options));\n  }\n  if (a && Array.isArray(a) && typeof b > \"u\")\n    return _make(diffText1(a), a, getDefaultOpts(options));\n  if (typeof a == \"string\" && b && Array.isArray(b))\n    return _make(a, b, getDefaultOpts(options));\n  throw new Error(\"Unknown call format to make()\");\n}\nfunction _make(textA, diffs, options) {\n  if (diffs.length === 0)\n    return [];\n  const patches = [];\n  let patch = createPatchObject(0, 0), patchDiffLength = 0, charCount1 = 0, charCount2 = 0, utf8Count1 = 0, utf8Count2 = 0, prepatchText = textA, postpatchText = textA;\n  for (let x = 0; x < diffs.length; x++) {\n    const currentDiff = diffs[x], [diffType, diffText] = currentDiff, diffTextLength = diffText.length, diffByteLength = countUtf8Bytes(diffText);\n    switch (!patchDiffLength && diffType !== DIFF_EQUAL && (patch.start1 = charCount1, patch.start2 = charCount2, patch.utf8Start1 = utf8Count1, patch.utf8Start2 = utf8Count2), diffType) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = currentDiff, patch.length2 += diffTextLength, patch.utf8Length2 += diffByteLength, postpatchText = postpatchText.substring(0, charCount2) + diffText + postpatchText.substring(charCount2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.diffs[patchDiffLength++] = currentDiff, postpatchText = postpatchText.substring(0, charCount2) + postpatchText.substring(charCount2 + diffTextLength);\n        break;\n      case DIFF_EQUAL:\n        diffTextLength <= 2 * options.margin && patchDiffLength && diffs.length !== x + 1 ? (patch.diffs[patchDiffLength++] = currentDiff, patch.length1 += diffTextLength, patch.length2 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.utf8Length2 += diffByteLength) : diffTextLength >= 2 * options.margin && patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch), patch = createPatchObject(-1, -1), patchDiffLength = 0, prepatchText = postpatchText, charCount1 = charCount2, utf8Count1 = utf8Count2);\n        break;\n      default:\n        throw new Error(\"Unknown diff type\");\n    }\n    diffType !== DIFF_INSERT && (charCount1 += diffTextLength, utf8Count1 += diffByteLength), diffType !== DIFF_DELETE && (charCount2 += diffTextLength, utf8Count2 += diffByteLength);\n  }\n  return patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch)), patches;\n}\nfunction addContext(patch, text, opts) {\n  if (text.length === 0)\n    return;\n  let pattern = text.substring(patch.start2, patch.start2 + patch.length1), padding = 0;\n  for (; text.indexOf(pattern) !== text.lastIndexOf(pattern) && pattern.length < MAX_BITS - opts.margin - opts.margin; )\n    padding += opts.margin, pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);\n  padding += opts.margin;\n  let prefixStart = patch.start2 - padding;\n  prefixStart >= 1 && isLowSurrogate(text[prefixStart]) && prefixStart--;\n  const prefix = text.substring(prefixStart, patch.start2);\n  prefix && patch.diffs.unshift([DIFF_EQUAL, prefix]);\n  const prefixLength = prefix.length, prefixUtf8Length = countUtf8Bytes(prefix);\n  let suffixEnd = patch.start2 + patch.length1 + padding;\n  suffixEnd < text.length && isLowSurrogate(text[suffixEnd]) && suffixEnd++;\n  const suffix = text.substring(patch.start2 + patch.length1, suffixEnd);\n  suffix && patch.diffs.push([DIFF_EQUAL, suffix]);\n  const suffixLength = suffix.length, suffixUtf8Length = countUtf8Bytes(suffix);\n  patch.start1 -= prefixLength, patch.start2 -= prefixLength, patch.utf8Start1 -= prefixUtf8Length, patch.utf8Start2 -= prefixUtf8Length, patch.length1 += prefixLength + suffixLength, patch.length2 += prefixLength + suffixLength, patch.utf8Length1 += prefixUtf8Length + suffixUtf8Length, patch.utf8Length2 += prefixUtf8Length + suffixUtf8Length;\n}\nconst patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\nfunction parse(textline) {\n  if (!textline)\n    return [];\n  const patches = [], lines = textline.split(`\n`);\n  let textPointer = 0;\n  for (; textPointer < lines.length; ) {\n    const m = lines[textPointer].match(patchHeader);\n    if (!m)\n      throw new Error(`Invalid patch string: ${lines[textPointer]}`);\n    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));\n    for (patches.push(patch), m[2] === \"\" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === \"0\" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === \"\" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === \"0\" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length; ) {\n      const currentLine = lines[textPointer], sign = currentLine.charAt(0);\n      if (sign === \"@\")\n        break;\n      if (sign === \"\") {\n        textPointer++;\n        continue;\n      }\n      let line;\n      try {\n        line = decodeURI(currentLine.slice(1));\n      } catch (ex) {\n        throw new Error(`Illegal escape in parse: ${currentLine}`);\n      }\n      const utf8Diff = countUtf8Bytes(line) - line.length;\n      if (sign === \"-\")\n        patch.diffs.push([DIFF_DELETE, line]), patch.length1 -= utf8Diff;\n      else if (sign === \"+\")\n        patch.diffs.push([DIFF_INSERT, line]), patch.length2 -= utf8Diff;\n      else if (sign === \" \")\n        patch.diffs.push([DIFF_EQUAL, line]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;\n      else\n        throw new Error(`Invalid patch mode \"${sign}\" in: ${line}`);\n      textPointer++;\n    }\n  }\n  return patches;\n}\nfunction toInt(num) {\n  return parseInt(num, 10);\n}\nfunction stringify(patches) {\n  return patches.map(stringifyPatch).join(\"\");\n}\nfunction stringifyPatch(patch) {\n  const { utf8Length1, utf8Length2, utf8Start1, utf8Start2, diffs } = patch;\n  let coords1;\n  utf8Length1 === 0 ? coords1 = `${utf8Start1},0` : utf8Length1 === 1 ? coords1 = `${utf8Start1 + 1}` : coords1 = `${utf8Start1 + 1},${utf8Length1}`;\n  let coords2;\n  utf8Length2 === 0 ? coords2 = `${utf8Start2},0` : utf8Length2 === 1 ? coords2 = `${utf8Start2 + 1}` : coords2 = `${utf8Start2 + 1},${utf8Length2}`;\n  const text = [`@@ -${coords1} +${coords2} @@\n`];\n  let op;\n  for (let x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        op = \"+\";\n        break;\n      case DIFF_DELETE:\n        op = \"-\";\n        break;\n      case DIFF_EQUAL:\n        op = \" \";\n        break;\n      default:\n        throw new Error(\"Unknown patch operation.\");\n    }\n    text[x + 1] = `${op + encodeURI(diffs[x][1])}\n`;\n  }\n  return text.join(\"\").replace(/%20/g, \" \");\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9kaWZmLW1hdGNoLXBhdGNoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNDQUFzQztBQUN4RCxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrRUFBK0U7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1IQUFtSDtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtS0FBbUssMEJBQTBCLHFDQUFxQywwQkFBMEI7QUFDNVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOEdBQThHO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNEJBQTRCO0FBQ3JDO0FBQ0E7QUFDQSwrQ0FBK0MsbUJBQW1CO0FBQ2xFO0FBQ0EsdWpCQUF1akIsNEJBQTRCO0FBQ25sQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSyxRQUFRLEtBQUs7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwREFBMEQ7QUFDcEU7QUFDQSxtQ0FBbUMsV0FBVyx1Q0FBdUMsZUFBZSxpQkFBaUIsZUFBZSxHQUFHLFlBQVk7QUFDbko7QUFDQSxtQ0FBbUMsV0FBVyx1Q0FBdUMsZUFBZSxpQkFBaUIsZUFBZSxHQUFHLFlBQVk7QUFDbkosdUJBQXVCLFNBQVMsR0FBRyxTQUFTO0FBQzVDO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBZUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3ljX2RpcmVjdG9yeS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2RpZmYtbWF0Y2gtcGF0Y2gvZGlzdC9pbmRleC5qcz83ZTY2Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGNsb25lRGlmZihkaWZmMikge1xuICBjb25zdCBbdHlwZSwgcGF0Y2hdID0gZGlmZjI7XG4gIHJldHVybiBbdHlwZSwgcGF0Y2hdO1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uT3ZlcmxhcCh0ZXh0QSwgdGV4dEIpIHtcbiAgbGV0IHRleHQxID0gdGV4dEEsIHRleHQyID0gdGV4dEI7XG4gIGNvbnN0IHRleHQxTGVuZ3RoID0gdGV4dDEubGVuZ3RoLCB0ZXh0Mkxlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgaWYgKHRleHQxTGVuZ3RoID09PSAwIHx8IHRleHQyTGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAwO1xuICB0ZXh0MUxlbmd0aCA+IHRleHQyTGVuZ3RoID8gdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDFMZW5ndGggLSB0ZXh0Mkxlbmd0aCkgOiB0ZXh0MUxlbmd0aCA8IHRleHQyTGVuZ3RoICYmICh0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0MUxlbmd0aCkpO1xuICBjb25zdCB0ZXh0TGVuZ3RoID0gTWF0aC5taW4odGV4dDFMZW5ndGgsIHRleHQyTGVuZ3RoKTtcbiAgaWYgKHRleHQxID09PSB0ZXh0MilcbiAgICByZXR1cm4gdGV4dExlbmd0aDtcbiAgbGV0IGJlc3QgPSAwLCBsZW5ndGggPSAxO1xuICBmb3IgKGxldCBmb3VuZCA9IDA7IGZvdW5kICE9PSAtMTsgKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IHRleHQxLnN1YnN0cmluZyh0ZXh0TGVuZ3RoIC0gbGVuZ3RoKTtcbiAgICBpZiAoZm91bmQgPSB0ZXh0Mi5pbmRleE9mKHBhdHRlcm4pLCBmb3VuZCA9PT0gLTEpXG4gICAgICByZXR1cm4gYmVzdDtcbiAgICBsZW5ndGggKz0gZm91bmQsIChmb3VuZCA9PT0gMCB8fCB0ZXh0MS5zdWJzdHJpbmcodGV4dExlbmd0aCAtIGxlbmd0aCkgPT09IHRleHQyLnN1YnN0cmluZygwLCBsZW5ndGgpKSAmJiAoYmVzdCA9IGxlbmd0aCwgbGVuZ3RoKyspO1xuICB9XG4gIHJldHVybiBiZXN0O1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uUHJlZml4KHRleHQxLCB0ZXh0Mikge1xuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MVswXSAhPT0gdGV4dDJbMF0pXG4gICAgcmV0dXJuIDA7XG4gIGxldCBwb2ludGVyTWluID0gMCwgcG9pbnRlck1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKSwgcG9pbnRlck1pZCA9IHBvaW50ZXJNYXgsIHBvaW50ZXJTdGFydCA9IDA7XG4gIGZvciAoOyBwb2ludGVyTWluIDwgcG9pbnRlck1pZDsgKVxuICAgIHRleHQxLnN1YnN0cmluZyhwb2ludGVyU3RhcnQsIHBvaW50ZXJNaWQpID09PSB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlclN0YXJ0LCBwb2ludGVyTWlkKSA/IChwb2ludGVyTWluID0gcG9pbnRlck1pZCwgcG9pbnRlclN0YXJ0ID0gcG9pbnRlck1pbikgOiBwb2ludGVyTWF4ID0gcG9pbnRlck1pZCwgcG9pbnRlck1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJNYXggLSBwb2ludGVyTWluKSAvIDIgKyBwb2ludGVyTWluKTtcbiAgcmV0dXJuIHBvaW50ZXJNaWQ7XG59XG5mdW5jdGlvbiBnZXRDb21tb25TdWZmaXgodGV4dDEsIHRleHQyKSB7XG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxW3RleHQxLmxlbmd0aCAtIDFdICE9PSB0ZXh0Mlt0ZXh0Mi5sZW5ndGggLSAxXSlcbiAgICByZXR1cm4gMDtcbiAgbGV0IHBvaW50ZXJNaW4gPSAwLCBwb2ludGVyTWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpLCBwb2ludGVyTWlkID0gcG9pbnRlck1heCwgcG9pbnRlckVuZCA9IDA7XG4gIGZvciAoOyBwb2ludGVyTWluIDwgcG9pbnRlck1pZDsgKVxuICAgIHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVyTWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyRW5kKSA9PT0gdGV4dDIuc3Vic3RyaW5nKHRleHQyLmxlbmd0aCAtIHBvaW50ZXJNaWQsIHRleHQyLmxlbmd0aCAtIHBvaW50ZXJFbmQpID8gKHBvaW50ZXJNaW4gPSBwb2ludGVyTWlkLCBwb2ludGVyRW5kID0gcG9pbnRlck1pbikgOiBwb2ludGVyTWF4ID0gcG9pbnRlck1pZCwgcG9pbnRlck1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJNYXggLSBwb2ludGVyTWluKSAvIDIgKyBwb2ludGVyTWluKTtcbiAgcmV0dXJuIHBvaW50ZXJNaWQ7XG59XG5mdW5jdGlvbiBpc0hpZ2hTdXJyb2dhdGUoY2hhcikge1xuICBjb25zdCBjaGFyQ29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDU1Mjk2ICYmIGNoYXJDb2RlIDw9IDU2MzE5O1xufVxuZnVuY3Rpb24gaXNMb3dTdXJyb2dhdGUoY2hhcikge1xuICBjb25zdCBjaGFyQ29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDU2MzIwICYmIGNoYXJDb2RlIDw9IDU3MzQzO1xufVxuZnVuY3Rpb24gYmlzZWN0KHRleHQxLCB0ZXh0MiwgZGVhZGxpbmUpIHtcbiAgY29uc3QgdGV4dDFMZW5ndGggPSB0ZXh0MS5sZW5ndGgsIHRleHQyTGVuZ3RoID0gdGV4dDIubGVuZ3RoLCBtYXhEID0gTWF0aC5jZWlsKCh0ZXh0MUxlbmd0aCArIHRleHQyTGVuZ3RoKSAvIDIpLCB2T2Zmc2V0ID0gbWF4RCwgdkxlbmd0aCA9IDIgKiBtYXhELCB2MSA9IG5ldyBBcnJheSh2TGVuZ3RoKSwgdjIgPSBuZXcgQXJyYXkodkxlbmd0aCk7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgdkxlbmd0aDsgeCsrKVxuICAgIHYxW3hdID0gLTEsIHYyW3hdID0gLTE7XG4gIHYxW3ZPZmZzZXQgKyAxXSA9IDAsIHYyW3ZPZmZzZXQgKyAxXSA9IDA7XG4gIGNvbnN0IGRlbHRhID0gdGV4dDFMZW5ndGggLSB0ZXh0Mkxlbmd0aCwgZnJvbnQgPSBkZWx0YSAlIDIgIT09IDA7XG4gIGxldCBrMXN0YXJ0ID0gMCwgazFlbmQgPSAwLCBrMnN0YXJ0ID0gMCwgazJlbmQgPSAwO1xuICBmb3IgKGxldCBkID0gMDsgZCA8IG1heEQgJiYgIShEYXRlLm5vdygpID4gZGVhZGxpbmUpOyBkKyspIHtcbiAgICBmb3IgKGxldCBrMSA9IC1kICsgazFzdGFydDsgazEgPD0gZCAtIGsxZW5kOyBrMSArPSAyKSB7XG4gICAgICBjb25zdCBrMU9mZnNldCA9IHZPZmZzZXQgKyBrMTtcbiAgICAgIGxldCB4MTtcbiAgICAgIGsxID09PSAtZCB8fCBrMSAhPT0gZCAmJiB2MVtrMU9mZnNldCAtIDFdIDwgdjFbazFPZmZzZXQgKyAxXSA/IHgxID0gdjFbazFPZmZzZXQgKyAxXSA6IHgxID0gdjFbazFPZmZzZXQgLSAxXSArIDE7XG4gICAgICBsZXQgeTEgPSB4MSAtIGsxO1xuICAgICAgZm9yICg7IHgxIDwgdGV4dDFMZW5ndGggJiYgeTEgPCB0ZXh0Mkxlbmd0aCAmJiB0ZXh0MS5jaGFyQXQoeDEpID09PSB0ZXh0Mi5jaGFyQXQoeTEpOyApXG4gICAgICAgIHgxKyssIHkxKys7XG4gICAgICBpZiAodjFbazFPZmZzZXRdID0geDEsIHgxID4gdGV4dDFMZW5ndGgpXG4gICAgICAgIGsxZW5kICs9IDI7XG4gICAgICBlbHNlIGlmICh5MSA+IHRleHQyTGVuZ3RoKVxuICAgICAgICBrMXN0YXJ0ICs9IDI7XG4gICAgICBlbHNlIGlmIChmcm9udCkge1xuICAgICAgICBjb25zdCBrMk9mZnNldCA9IHZPZmZzZXQgKyBkZWx0YSAtIGsxO1xuICAgICAgICBpZiAoazJPZmZzZXQgPj0gMCAmJiBrMk9mZnNldCA8IHZMZW5ndGggJiYgdjJbazJPZmZzZXRdICE9PSAtMSkge1xuICAgICAgICAgIGNvbnN0IHgyID0gdGV4dDFMZW5ndGggLSB2MltrMk9mZnNldF07XG4gICAgICAgICAgaWYgKHgxID49IHgyKVxuICAgICAgICAgICAgcmV0dXJuIGJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgazIgPSAtZCArIGsyc3RhcnQ7IGsyIDw9IGQgLSBrMmVuZDsgazIgKz0gMikge1xuICAgICAgY29uc3QgazJPZmZzZXQgPSB2T2Zmc2V0ICsgazI7XG4gICAgICBsZXQgeDI7XG4gICAgICBrMiA9PT0gLWQgfHwgazIgIT09IGQgJiYgdjJbazJPZmZzZXQgLSAxXSA8IHYyW2syT2Zmc2V0ICsgMV0gPyB4MiA9IHYyW2syT2Zmc2V0ICsgMV0gOiB4MiA9IHYyW2syT2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgbGV0IHkyID0geDIgLSBrMjtcbiAgICAgIGZvciAoOyB4MiA8IHRleHQxTGVuZ3RoICYmIHkyIDwgdGV4dDJMZW5ndGggJiYgdGV4dDEuY2hhckF0KHRleHQxTGVuZ3RoIC0geDIgLSAxKSA9PT0gdGV4dDIuY2hhckF0KHRleHQyTGVuZ3RoIC0geTIgLSAxKTsgKVxuICAgICAgICB4MisrLCB5MisrO1xuICAgICAgaWYgKHYyW2syT2Zmc2V0XSA9IHgyLCB4MiA+IHRleHQxTGVuZ3RoKVxuICAgICAgICBrMmVuZCArPSAyO1xuICAgICAgZWxzZSBpZiAoeTIgPiB0ZXh0Mkxlbmd0aClcbiAgICAgICAgazJzdGFydCArPSAyO1xuICAgICAgZWxzZSBpZiAoIWZyb250KSB7XG4gICAgICAgIGNvbnN0IGsxT2Zmc2V0ID0gdk9mZnNldCArIGRlbHRhIC0gazI7XG4gICAgICAgIGlmIChrMU9mZnNldCA+PSAwICYmIGsxT2Zmc2V0IDwgdkxlbmd0aCAmJiB2MVtrMU9mZnNldF0gIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgeDEgPSB2MVtrMU9mZnNldF0sIHkxID0gdk9mZnNldCArIHgxIC0gazFPZmZzZXQ7XG4gICAgICAgICAgaWYgKHgyID0gdGV4dDFMZW5ndGggLSB4MiwgeDEgPj0geDIpXG4gICAgICAgICAgICByZXR1cm4gYmlzZWN0U3BsaXQodGV4dDEsIHRleHQyLCB4MSwgeTEsIGRlYWRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gW1xuICAgIFtESUZGX0RFTEVURSwgdGV4dDFdLFxuICAgIFtESUZGX0lOU0VSVCwgdGV4dDJdXG4gIF07XG59XG5mdW5jdGlvbiBiaXNlY3RTcGxpdCh0ZXh0MSwgdGV4dDIsIHgsIHksIGRlYWRsaW5lKSB7XG4gIGNvbnN0IHRleHQxYSA9IHRleHQxLnN1YnN0cmluZygwLCB4KSwgdGV4dDJhID0gdGV4dDIuc3Vic3RyaW5nKDAsIHkpLCB0ZXh0MWIgPSB0ZXh0MS5zdWJzdHJpbmcoeCksIHRleHQyYiA9IHRleHQyLnN1YnN0cmluZyh5KSwgZGlmZnMgPSBkb0RpZmYodGV4dDFhLCB0ZXh0MmEsIHsgY2hlY2tMaW5lczogITEsIGRlYWRsaW5lIH0pLCBkaWZmc2IgPSBkb0RpZmYodGV4dDFiLCB0ZXh0MmIsIHsgY2hlY2tMaW5lczogITEsIGRlYWRsaW5lIH0pO1xuICByZXR1cm4gZGlmZnMuY29uY2F0KGRpZmZzYik7XG59XG5mdW5jdGlvbiBmaW5kSGFsZk1hdGNoKHRleHQxLCB0ZXh0MiwgdGltZW91dCA9IDEpIHtcbiAgaWYgKHRpbWVvdXQgPD0gMClcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgbG9uZ1RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyLCBzaG9ydFRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICBpZiAobG9uZ1RleHQubGVuZ3RoIDwgNCB8fCBzaG9ydFRleHQubGVuZ3RoICogMiA8IGxvbmdUZXh0Lmxlbmd0aClcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgaGFsZk1hdGNoMSA9IGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgTWF0aC5jZWlsKGxvbmdUZXh0Lmxlbmd0aCAvIDQpKSwgaGFsZk1hdGNoMiA9IGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgTWF0aC5jZWlsKGxvbmdUZXh0Lmxlbmd0aCAvIDIpKTtcbiAgbGV0IGhhbGZNYXRjaDtcbiAgaWYgKGhhbGZNYXRjaDEgJiYgaGFsZk1hdGNoMilcbiAgICBoYWxmTWF0Y2ggPSBoYWxmTWF0Y2gxWzRdLmxlbmd0aCA+IGhhbGZNYXRjaDJbNF0ubGVuZ3RoID8gaGFsZk1hdGNoMSA6IGhhbGZNYXRjaDI7XG4gIGVsc2Uge1xuICAgIGlmICghaGFsZk1hdGNoMSAmJiAhaGFsZk1hdGNoMilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGhhbGZNYXRjaDIgPyBoYWxmTWF0Y2gxIHx8IChoYWxmTWF0Y2ggPSBoYWxmTWF0Y2gyKSA6IGhhbGZNYXRjaCA9IGhhbGZNYXRjaDE7XG4gIH1cbiAgaWYgKCFoYWxmTWF0Y2gpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgYSBoYWxmIG1hdGNoLlwiKTtcbiAgbGV0IHRleHQxQSwgdGV4dDFCLCB0ZXh0MkEsIHRleHQyQjtcbiAgdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gKHRleHQxQSA9IGhhbGZNYXRjaFswXSwgdGV4dDFCID0gaGFsZk1hdGNoWzFdLCB0ZXh0MkEgPSBoYWxmTWF0Y2hbMl0sIHRleHQyQiA9IGhhbGZNYXRjaFszXSkgOiAodGV4dDJBID0gaGFsZk1hdGNoWzBdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbMV0sIHRleHQxQSA9IGhhbGZNYXRjaFsyXSwgdGV4dDFCID0gaGFsZk1hdGNoWzNdKTtcbiAgY29uc3QgbWlkQ29tbW9uID0gaGFsZk1hdGNoWzRdO1xuICByZXR1cm4gW3RleHQxQSwgdGV4dDFCLCB0ZXh0MkEsIHRleHQyQiwgbWlkQ29tbW9uXTtcbn1cbmZ1bmN0aW9uIGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgaSkge1xuICBjb25zdCBzZWVkID0gbG9uZ1RleHQuc2xpY2UoaSwgaSArIE1hdGguZmxvb3IobG9uZ1RleHQubGVuZ3RoIC8gNCkpO1xuICBsZXQgaiA9IC0xLCBiZXN0Q29tbW9uID0gXCJcIiwgYmVzdExvbmdUZXh0QSwgYmVzdExvbmdUZXh0QiwgYmVzdFNob3J0VGV4dEEsIGJlc3RTaG9ydFRleHRCO1xuICBmb3IgKDsgKGogPSBzaG9ydFRleHQuaW5kZXhPZihzZWVkLCBqICsgMSkpICE9PSAtMTsgKSB7XG4gICAgY29uc3QgcHJlZml4TGVuZ3RoID0gZ2V0Q29tbW9uUHJlZml4KGxvbmdUZXh0LnNsaWNlKGkpLCBzaG9ydFRleHQuc2xpY2UoaikpLCBzdWZmaXhMZW5ndGggPSBnZXRDb21tb25TdWZmaXgobG9uZ1RleHQuc2xpY2UoMCwgaSksIHNob3J0VGV4dC5zbGljZSgwLCBqKSk7XG4gICAgYmVzdENvbW1vbi5sZW5ndGggPCBzdWZmaXhMZW5ndGggKyBwcmVmaXhMZW5ndGggJiYgKGJlc3RDb21tb24gPSBzaG9ydFRleHQuc2xpY2UoaiAtIHN1ZmZpeExlbmd0aCwgaikgKyBzaG9ydFRleHQuc2xpY2UoaiwgaiArIHByZWZpeExlbmd0aCksIGJlc3RMb25nVGV4dEEgPSBsb25nVGV4dC5zbGljZSgwLCBpIC0gc3VmZml4TGVuZ3RoKSwgYmVzdExvbmdUZXh0QiA9IGxvbmdUZXh0LnNsaWNlKGkgKyBwcmVmaXhMZW5ndGgpLCBiZXN0U2hvcnRUZXh0QSA9IHNob3J0VGV4dC5zbGljZSgwLCBqIC0gc3VmZml4TGVuZ3RoKSwgYmVzdFNob3J0VGV4dEIgPSBzaG9ydFRleHQuc2xpY2UoaiArIHByZWZpeExlbmd0aCkpO1xuICB9XG4gIHJldHVybiBiZXN0Q29tbW9uLmxlbmd0aCAqIDIgPj0gbG9uZ1RleHQubGVuZ3RoID8gW1xuICAgIGJlc3RMb25nVGV4dEEgfHwgXCJcIixcbiAgICBiZXN0TG9uZ1RleHRCIHx8IFwiXCIsXG4gICAgYmVzdFNob3J0VGV4dEEgfHwgXCJcIixcbiAgICBiZXN0U2hvcnRUZXh0QiB8fCBcIlwiLFxuICAgIGJlc3RDb21tb24gfHwgXCJcIlxuICBdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNoYXJzVG9MaW5lcyhkaWZmcywgbGluZUFycmF5KSB7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBjaGFycyA9IGRpZmZzW3hdWzFdLCB0ZXh0ID0gW107XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjaGFycy5sZW5ndGg7IHkrKylcbiAgICAgIHRleHRbeV0gPSBsaW5lQXJyYXlbY2hhcnMuY2hhckNvZGVBdCh5KV07XG4gICAgZGlmZnNbeF1bMV0gPSB0ZXh0LmpvaW4oXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpbmVzVG9DaGFycyh0ZXh0QSwgdGV4dEIpIHtcbiAgY29uc3QgbGluZUFycmF5ID0gW10sIGxpbmVIYXNoID0ge307XG4gIGxpbmVBcnJheVswXSA9IFwiXCI7XG4gIGZ1bmN0aW9uIGRpZmZMaW5lc1RvTXVuZ2UodGV4dCkge1xuICAgIGxldCBjaGFycyA9IFwiXCIsIGxpbmVTdGFydCA9IDAsIGxpbmVFbmQgPSAtMSwgbGluZUFycmF5TGVuZ3RoID0gbGluZUFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKDsgbGluZUVuZCA8IHRleHQubGVuZ3RoIC0gMTsgKSB7XG4gICAgICBsaW5lRW5kID0gdGV4dC5pbmRleE9mKGBcbmAsIGxpbmVTdGFydCksIGxpbmVFbmQgPT09IC0xICYmIChsaW5lRW5kID0gdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBsaW5lID0gdGV4dC5zbGljZShsaW5lU3RhcnQsIGxpbmVFbmQgKyAxKTtcbiAgICAgIChsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eSA/IGxpbmVIYXNoLmhhc093blByb3BlcnR5KGxpbmUpIDogbGluZUhhc2hbbGluZV0gIT09IHZvaWQgMCkgPyBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVIYXNoW2xpbmVdKSA6IChsaW5lQXJyYXlMZW5ndGggPT09IG1heExpbmVzICYmIChsaW5lID0gdGV4dC5zbGljZShsaW5lU3RhcnQpLCBsaW5lRW5kID0gdGV4dC5sZW5ndGgpLCBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVBcnJheUxlbmd0aCksIGxpbmVIYXNoW2xpbmVdID0gbGluZUFycmF5TGVuZ3RoLCBsaW5lQXJyYXlbbGluZUFycmF5TGVuZ3RoKytdID0gbGluZSksIGxpbmVTdGFydCA9IGxpbmVFbmQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH1cbiAgbGV0IG1heExpbmVzID0gNGU0O1xuICBjb25zdCBjaGFyczEgPSBkaWZmTGluZXNUb011bmdlKHRleHRBKTtcbiAgbWF4TGluZXMgPSA2NTUzNTtcbiAgY29uc3QgY2hhcnMyID0gZGlmZkxpbmVzVG9NdW5nZSh0ZXh0Qik7XG4gIHJldHVybiB7IGNoYXJzMSwgY2hhcnMyLCBsaW5lQXJyYXkgfTtcbn1cbmZ1bmN0aW9uIGRvTGluZU1vZGVEaWZmKHRleHRBLCB0ZXh0Qiwgb3B0cykge1xuICBsZXQgdGV4dDEgPSB0ZXh0QSwgdGV4dDIgPSB0ZXh0QjtcbiAgY29uc3QgYSA9IGxpbmVzVG9DaGFycyh0ZXh0MSwgdGV4dDIpO1xuICB0ZXh0MSA9IGEuY2hhcnMxLCB0ZXh0MiA9IGEuY2hhcnMyO1xuICBjb25zdCBsaW5lYXJyYXkgPSBhLmxpbmVBcnJheTtcbiAgbGV0IGRpZmZzID0gZG9EaWZmKHRleHQxLCB0ZXh0Miwge1xuICAgIGNoZWNrTGluZXM6ICExLFxuICAgIGRlYWRsaW5lOiBvcHRzLmRlYWRsaW5lXG4gIH0pO1xuICBjaGFyc1RvTGluZXMoZGlmZnMsIGxpbmVhcnJheSksIGRpZmZzID0gY2xlYW51cFNlbWFudGljKGRpZmZzKSwgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgXCJcIl0pO1xuICBsZXQgcG9pbnRlciA9IDAsIGNvdW50RGVsZXRlID0gMCwgY291bnRJbnNlcnQgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCI7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudEluc2VydCsrLCB0ZXh0SW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGNvdW50RGVsZXRlKyssIHRleHREZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBpZiAoY291bnREZWxldGUgPj0gMSAmJiBjb3VudEluc2VydCA+PSAxKSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0LCBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0KSwgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0O1xuICAgICAgICAgIGNvbnN0IGFhID0gZG9EaWZmKHRleHREZWxldGUsIHRleHRJbnNlcnQsIHtcbiAgICAgICAgICAgIGNoZWNrTGluZXM6ICExLFxuICAgICAgICAgICAgZGVhZGxpbmU6IG9wdHMuZGVhZGxpbmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gYWEubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgYWFbal0pO1xuICAgICAgICAgIHBvaW50ZXIgKz0gYWEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50SW5zZXJ0ID0gMCwgY291bnREZWxldGUgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkaWZmIG9wZXJhdGlvbi5cIik7XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICByZXR1cm4gZGlmZnMucG9wKCksIGRpZmZzO1xufVxuZnVuY3Rpb24gY29tcHV0ZURpZmYodGV4dDEsIHRleHQyLCBvcHRzKSB7XG4gIGxldCBkaWZmcztcbiAgaWYgKCF0ZXh0MSlcbiAgICByZXR1cm4gW1tESUZGX0lOU0VSVCwgdGV4dDJdXTtcbiAgaWYgKCF0ZXh0MilcbiAgICByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdXTtcbiAgY29uc3QgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyLCBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxLCBpID0gbG9uZ3RleHQuaW5kZXhPZihzaG9ydHRleHQpO1xuICBpZiAoaSAhPT0gLTEpXG4gICAgcmV0dXJuIGRpZmZzID0gW1xuICAgICAgW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSldLFxuICAgICAgW0RJRkZfRVFVQUwsIHNob3J0dGV4dF0sXG4gICAgICBbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgc2hvcnR0ZXh0Lmxlbmd0aCldXG4gICAgXSwgdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoICYmIChkaWZmc1swXVswXSA9IERJRkZfREVMRVRFLCBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFKSwgZGlmZnM7XG4gIGlmIChzaG9ydHRleHQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiBbXG4gICAgICBbRElGRl9ERUxFVEUsIHRleHQxXSxcbiAgICAgIFtESUZGX0lOU0VSVCwgdGV4dDJdXG4gICAgXTtcbiAgY29uc3QgaGFsZk1hdGNoID0gZmluZEhhbGZNYXRjaCh0ZXh0MSwgdGV4dDIpO1xuICBpZiAoaGFsZk1hdGNoKSB7XG4gICAgY29uc3QgdGV4dDFBID0gaGFsZk1hdGNoWzBdLCB0ZXh0MUIgPSBoYWxmTWF0Y2hbMV0sIHRleHQyQSA9IGhhbGZNYXRjaFsyXSwgdGV4dDJCID0gaGFsZk1hdGNoWzNdLCBtaWRDb21tb24gPSBoYWxmTWF0Y2hbNF0sIGRpZmZzQSA9IGRvRGlmZih0ZXh0MUEsIHRleHQyQSwgb3B0cyksIGRpZmZzQiA9IGRvRGlmZih0ZXh0MUIsIHRleHQyQiwgb3B0cyk7XG4gICAgcmV0dXJuIGRpZmZzQS5jb25jYXQoW1tESUZGX0VRVUFMLCBtaWRDb21tb25dXSwgZGlmZnNCKTtcbiAgfVxuICByZXR1cm4gb3B0cy5jaGVja0xpbmVzICYmIHRleHQxLmxlbmd0aCA+IDEwMCAmJiB0ZXh0Mi5sZW5ndGggPiAxMDAgPyBkb0xpbmVNb2RlRGlmZih0ZXh0MSwgdGV4dDIsIG9wdHMpIDogYmlzZWN0KHRleHQxLCB0ZXh0Miwgb3B0cy5kZWFkbGluZSk7XG59XG52YXIgX19kZWZQcm9wJDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZ2V0T3duUHJvcFN5bWJvbHMkMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIF9faGFzT3duUHJvcCQyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgX19wcm9wSXNFbnVtJDIgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBfX2RlZk5vcm1hbFByb3AkMiA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMihvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fc3ByZWFkVmFsdWVzJDIgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgX19oYXNPd25Qcm9wJDIuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AkMihhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMkMilcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMkMihiKSlcbiAgICAgIF9fcHJvcElzRW51bSQyLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDIoYSwgcHJvcCwgYltwcm9wXSk7XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IERJRkZfREVMRVRFID0gLTEsIERJRkZfSU5TRVJUID0gMSwgRElGRl9FUVVBTCA9IDA7XG5mdW5jdGlvbiBkaWZmKHRleHRBLCB0ZXh0Qiwgb3B0cykge1xuICBpZiAodGV4dEEgPT09IG51bGwgfHwgdGV4dEIgPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBpbnB1dC4gKGRpZmYpXCIpO1xuICBjb25zdCBkaWZmcyA9IGRvRGlmZih0ZXh0QSwgdGV4dEIsIGNyZWF0ZUludGVybmFsT3B0cyhvcHRzIHx8IHt9KSk7XG4gIHJldHVybiBhZGp1c3REaWZmRm9yU3Vycm9nYXRlUGFpcnMoZGlmZnMpLCBkaWZmcztcbn1cbmZ1bmN0aW9uIGRvRGlmZih0ZXh0QSwgdGV4dEIsIG9wdGlvbnMpIHtcbiAgbGV0IHRleHQxID0gdGV4dEEsIHRleHQyID0gdGV4dEI7XG4gIGlmICh0ZXh0MSA9PT0gdGV4dDIpXG4gICAgcmV0dXJuIHRleHQxID8gW1tESUZGX0VRVUFMLCB0ZXh0MV1dIDogW107XG4gIGxldCBjb21tb25sZW5ndGggPSBnZXRDb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcbiAgY29uc3QgY29tbW9ucHJlZml4ID0gdGV4dDEuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpO1xuICBjb25zdCBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSwgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgbGV0IGRpZmZzID0gY29tcHV0ZURpZmYodGV4dDEsIHRleHQyLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbW1vbnByZWZpeCAmJiBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBjb21tb25wcmVmaXhdKSwgY29tbW9uc3VmZml4ICYmIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGNvbW1vbnN1ZmZpeF0pLCBkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcyksIGRpZmZzO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVhZExpbmUodGltZW91dCkge1xuICBsZXQgdCA9IDE7XG4gIHJldHVybiB0eXBlb2YgdGltZW91dCA8IFwidVwiICYmICh0ID0gdGltZW91dCA8PSAwID8gTnVtYmVyLk1BWF9WQUxVRSA6IHRpbWVvdXQpLCBEYXRlLm5vdygpICsgdCAqIDFlMztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsT3B0cyhvcHRzKSB7XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyQyKHtcbiAgICBjaGVja0xpbmVzOiAhMCxcbiAgICBkZWFkbGluZTogY3JlYXRlRGVhZExpbmUob3B0cy50aW1lb3V0IHx8IDEpXG4gIH0sIG9wdHMpO1xufVxuZnVuY3Rpb24gY29tYmluZUNoYXIoZGF0YSwgY2hhciwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBkYXRhICsgY2hhciA6IGNoYXIgKyBkYXRhO1xufVxuZnVuY3Rpb24gc3BsaXRDaGFyKGRhdGEsIGRpcikge1xuICByZXR1cm4gZGlyID09PSAxID8gW2RhdGEuc3Vic3RyaW5nKDAsIGRhdGEubGVuZ3RoIC0gMSksIGRhdGFbZGF0YS5sZW5ndGggLSAxXV0gOiBbZGF0YS5zdWJzdHJpbmcoMSksIGRhdGFbMF1dO1xufVxuZnVuY3Rpb24gaGFzU2hhcmVkQ2hhcihkaWZmcywgaSwgaiwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBkaWZmc1tpXVsxXVtkaWZmc1tpXVsxXS5sZW5ndGggLSAxXSA9PT0gZGlmZnNbal1bMV1bZGlmZnNbal1bMV0ubGVuZ3RoIC0gMV0gOiBkaWZmc1tpXVsxXVswXSA9PT0gZGlmZnNbal1bMV1bMF07XG59XG5mdW5jdGlvbiBkZWlzb2xhdGVDaGFyKGRpZmZzLCBpLCBkaXIpIHtcbiAgY29uc3QgaW52ID0gZGlyID09PSAxID8gLTEgOiAxO1xuICBsZXQgaW5zZXJ0SWR4ID0gbnVsbCwgZGVsZXRlSWR4ID0gbnVsbCwgaiA9IGkgKyBkaXI7XG4gIGZvciAoOyBqID49IDAgJiYgaiA8IGRpZmZzLmxlbmd0aCAmJiAoaW5zZXJ0SWR4ID09PSBudWxsIHx8IGRlbGV0ZUlkeCA9PT0gbnVsbCk7IGogKz0gZGlyKSB7XG4gICAgY29uc3QgW29wLCB0ZXh0Ml0gPSBkaWZmc1tqXTtcbiAgICBpZiAodGV4dDIubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpZiAob3AgPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgIGluc2VydElkeCA9PT0gbnVsbCAmJiAoaW5zZXJ0SWR4ID0gaik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChvcCA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgZGVsZXRlSWR4ID09PSBudWxsICYmIChkZWxldGVJZHggPSBqKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKG9wID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgIGlmIChpbnNlcnRJZHggPT09IG51bGwgJiYgZGVsZXRlSWR4ID09PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgW3Jlc3QsIGNoYXIyXSA9IHNwbGl0Q2hhcihkaWZmc1tpXVsxXSwgZGlyKTtcbiAgICAgICAgICBkaWZmc1tpXVsxXSA9IHJlc3QsIGRpZmZzW2pdWzFdID0gY29tYmluZUNoYXIoZGlmZnNbal1bMV0sIGNoYXIyLCBpbnYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGluc2VydElkeCAhPT0gbnVsbCAmJiBkZWxldGVJZHggIT09IG51bGwgJiYgaGFzU2hhcmVkQ2hhcihkaWZmcywgaW5zZXJ0SWR4LCBkZWxldGVJZHgsIGRpcikpIHtcbiAgICBjb25zdCBbaW5zZXJ0VGV4dCwgaW5zZXJ0Q2hhcl0gPSBzcGxpdENoYXIoZGlmZnNbaW5zZXJ0SWR4XVsxXSwgaW52KSwgW2RlbGV0ZVRleHRdID0gc3BsaXRDaGFyKGRpZmZzW2RlbGV0ZUlkeF1bMV0sIGludik7XG4gICAgZGlmZnNbaW5zZXJ0SWR4XVsxXSA9IGluc2VydFRleHQsIGRpZmZzW2RlbGV0ZUlkeF1bMV0gPSBkZWxldGVUZXh0LCBkaWZmc1tpXVsxXSA9IGNvbWJpbmVDaGFyKGRpZmZzW2ldWzFdLCBpbnNlcnRDaGFyLCBkaXIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbdGV4dCwgY2hhcl0gPSBzcGxpdENoYXIoZGlmZnNbaV1bMV0sIGRpcik7XG4gIGRpZmZzW2ldWzFdID0gdGV4dCwgaW5zZXJ0SWR4ID09PSBudWxsID8gKGRpZmZzLnNwbGljZShqLCAwLCBbRElGRl9JTlNFUlQsIGNoYXJdKSwgZGVsZXRlSWR4ICE9PSBudWxsICYmIGRlbGV0ZUlkeCA+PSBqICYmIGRlbGV0ZUlkeCsrKSA6IGRpZmZzW2luc2VydElkeF1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tpbnNlcnRJZHhdWzFdLCBjaGFyLCBpbnYpLCBkZWxldGVJZHggPT09IG51bGwgPyBkaWZmcy5zcGxpY2UoaiwgMCwgW0RJRkZfREVMRVRFLCBjaGFyXSkgOiBkaWZmc1tkZWxldGVJZHhdWzFdID0gY29tYmluZUNoYXIoZGlmZnNbZGVsZXRlSWR4XVsxXSwgY2hhciwgaW52KTtcbn1cbmZ1bmN0aW9uIGFkanVzdERpZmZGb3JTdXJyb2dhdGVQYWlycyhkaWZmcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgW2RpZmZUeXBlLCBkaWZmVGV4dF0gPSBkaWZmc1tpXTtcbiAgICBpZiAoZGlmZlRleHQubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICBjb25zdCBmaXJzdENoYXIgPSBkaWZmVGV4dFswXSwgbGFzdENoYXIgPSBkaWZmVGV4dFtkaWZmVGV4dC5sZW5ndGggLSAxXTtcbiAgICBpc0hpZ2hTdXJyb2dhdGUobGFzdENoYXIpICYmIGRpZmZUeXBlID09PSBESUZGX0VRVUFMICYmIGRlaXNvbGF0ZUNoYXIoZGlmZnMsIGksIDEpLCBpc0xvd1N1cnJvZ2F0ZShmaXJzdENoYXIpICYmIGRpZmZUeXBlID09PSBESUZGX0VRVUFMICYmIGRlaXNvbGF0ZUNoYXIoZGlmZnMsIGksIC0xKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmZzLmxlbmd0aDsgaSsrKVxuICAgIGRpZmZzW2ldWzFdLmxlbmd0aCA9PT0gMCAmJiBkaWZmcy5zcGxpY2UoaSwgMSk7XG59XG5mdW5jdGlvbiBjbGVhbnVwU2VtYW50aWMocmF3RGlmZnMpIHtcbiAgbGV0IGRpZmZzID0gcmF3RGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSksIGhhc0NoYW5nZXMgPSAhMTtcbiAgY29uc3QgZXF1YWxpdGllcyA9IFtdO1xuICBsZXQgZXF1YWxpdGllc0xlbmd0aCA9IDAsIGxhc3RFcXVhbGl0eSA9IG51bGwsIHBvaW50ZXIgPSAwLCBsZW5ndGhJbnNlcnRpb25zMSA9IDAsIGxlbmd0aERlbGV0aW9uczEgPSAwLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwO1xuICBmb3IgKDsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKVxuICAgIGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0VRVUFMID8gKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXIsIGxlbmd0aEluc2VydGlvbnMxID0gbGVuZ3RoSW5zZXJ0aW9uczIsIGxlbmd0aERlbGV0aW9uczEgPSBsZW5ndGhEZWxldGlvbnMyLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwLCBsYXN0RXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXSkgOiAoZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfSU5TRVJUID8gbGVuZ3RoSW5zZXJ0aW9uczIgKz0gZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDogbGVuZ3RoRGVsZXRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGgsIGxhc3RFcXVhbGl0eSAmJiBsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aEluc2VydGlvbnMxLCBsZW5ndGhEZWxldGlvbnMxKSAmJiBsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aEluc2VydGlvbnMyLCBsZW5ndGhEZWxldGlvbnMyKSAmJiAoZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLCBbRElGRl9ERUxFVEUsIGxhc3RFcXVhbGl0eV0pLCBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQsIGVxdWFsaXRpZXNMZW5ndGgtLSwgZXF1YWxpdGllc0xlbmd0aC0tLCBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xLCBsZW5ndGhJbnNlcnRpb25zMSA9IDAsIGxlbmd0aERlbGV0aW9uczEgPSAwLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwLCBsYXN0RXF1YWxpdHkgPSBudWxsLCBoYXNDaGFuZ2VzID0gITApKSwgcG9pbnRlcisrO1xuICBmb3IgKGhhc0NoYW5nZXMgJiYgKGRpZmZzID0gY2xlYW51cE1lcmdlKGRpZmZzKSksIGRpZmZzID0gY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpLCBwb2ludGVyID0gMTsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9ERUxFVEUgJiYgZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICBjb25zdCBkZWxldGlvbiA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSwgaW5zZXJ0aW9uID0gZGlmZnNbcG9pbnRlcl1bMV0sIG92ZXJsYXBMZW5ndGgxID0gZ2V0Q29tbW9uT3ZlcmxhcChkZWxldGlvbiwgaW5zZXJ0aW9uKSwgb3ZlcmxhcExlbmd0aDIgPSBnZXRDb21tb25PdmVybGFwKGluc2VydGlvbiwgZGVsZXRpb24pO1xuICAgICAgb3ZlcmxhcExlbmd0aDEgPj0gb3ZlcmxhcExlbmd0aDIgPyAob3ZlcmxhcExlbmd0aDEgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fCBvdmVybGFwTGVuZ3RoMSA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikgJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9FUVVBTCwgaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwTGVuZ3RoMSldKSwgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKDAsIGRlbGV0aW9uLmxlbmd0aCAtIG92ZXJsYXBMZW5ndGgxKSwgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZyhvdmVybGFwTGVuZ3RoMSksIHBvaW50ZXIrKykgOiAob3ZlcmxhcExlbmd0aDIgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fCBvdmVybGFwTGVuZ3RoMiA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikgJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9FUVVBTCwgZGVsZXRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBMZW5ndGgyKV0pLCBkaWZmc1twb2ludGVyIC0gMV1bMF0gPSBESUZGX0lOU0VSVCwgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBpbnNlcnRpb24ubGVuZ3RoIC0gb3ZlcmxhcExlbmd0aDIpLCBkaWZmc1twb2ludGVyICsgMV1bMF0gPSBESUZGX0RFTEVURSwgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKG92ZXJsYXBMZW5ndGgyKSwgcG9pbnRlcisrKSwgcG9pbnRlcisrO1xuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufVxuY29uc3Qgbm9uQWxwaGFOdW1lcmljUmVnZXggPSAvW15hLXpBLVowLTldLywgd2hpdGVzcGFjZVJlZ2V4ID0gL1xccy8sIGxpbmVicmVha1JlZ2V4ID0gL1tcXHJcXG5dLywgYmxhbmtsaW5lRW5kUmVnZXggPSAvXFxuXFxyP1xcbiQvLCBibGFua2xpbmVTdGFydFJlZ2V4ID0gL15cXHI/XFxuXFxyP1xcbi87XG5mdW5jdGlvbiBjbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhyYXdEaWZmcykge1xuICBjb25zdCBkaWZmcyA9IHJhd0RpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpO1xuICBmdW5jdGlvbiBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUob25lLCB0d28pIHtcbiAgICBpZiAoIW9uZSB8fCAhdHdvKVxuICAgICAgcmV0dXJuIDY7XG4gICAgY29uc3QgY2hhcjEgPSBvbmUuY2hhckF0KG9uZS5sZW5ndGggLSAxKSwgY2hhcjIgPSB0d28uY2hhckF0KDApLCBub25BbHBoYU51bWVyaWMxID0gY2hhcjEubWF0Y2gobm9uQWxwaGFOdW1lcmljUmVnZXgpLCBub25BbHBoYU51bWVyaWMyID0gY2hhcjIubWF0Y2gobm9uQWxwaGFOdW1lcmljUmVnZXgpLCB3aGl0ZXNwYWNlMSA9IG5vbkFscGhhTnVtZXJpYzEgJiYgY2hhcjEubWF0Y2god2hpdGVzcGFjZVJlZ2V4KSwgd2hpdGVzcGFjZTIgPSBub25BbHBoYU51bWVyaWMyICYmIGNoYXIyLm1hdGNoKHdoaXRlc3BhY2VSZWdleCksIGxpbmVCcmVhazEgPSB3aGl0ZXNwYWNlMSAmJiBjaGFyMS5tYXRjaChsaW5lYnJlYWtSZWdleCksIGxpbmVCcmVhazIgPSB3aGl0ZXNwYWNlMiAmJiBjaGFyMi5tYXRjaChsaW5lYnJlYWtSZWdleCksIGJsYW5rTGluZTEgPSBsaW5lQnJlYWsxICYmIG9uZS5tYXRjaChibGFua2xpbmVFbmRSZWdleCksIGJsYW5rTGluZTIgPSBsaW5lQnJlYWsyICYmIHR3by5tYXRjaChibGFua2xpbmVTdGFydFJlZ2V4KTtcbiAgICByZXR1cm4gYmxhbmtMaW5lMSB8fCBibGFua0xpbmUyID8gNSA6IGxpbmVCcmVhazEgfHwgbGluZUJyZWFrMiA/IDQgOiBub25BbHBoYU51bWVyaWMxICYmICF3aGl0ZXNwYWNlMSAmJiB3aGl0ZXNwYWNlMiA/IDMgOiB3aGl0ZXNwYWNlMSB8fCB3aGl0ZXNwYWNlMiA/IDIgOiBub25BbHBoYU51bWVyaWMxIHx8IG5vbkFscGhhTnVtZXJpYzIgPyAxIDogMDtcbiAgfVxuICBsZXQgcG9pbnRlciA9IDE7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMTsgKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmc1twb2ludGVyICsgMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgIGxldCBlcXVhbGl0eTEgPSBkaWZmc1twb2ludGVyIC0gMV1bMV0sIGVkaXQgPSBkaWZmc1twb2ludGVyXVsxXSwgZXF1YWxpdHkyID0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgY29uc3QgY29tbW9uT2Zmc2V0ID0gZ2V0Q29tbW9uU3VmZml4KGVxdWFsaXR5MSwgZWRpdCk7XG4gICAgICBpZiAoY29tbW9uT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGNvbW1vblN0cmluZyA9IGVkaXQuc3Vic3RyaW5nKGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkxID0gZXF1YWxpdHkxLnN1YnN0cmluZygwLCBlcXVhbGl0eTEubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KSwgZWRpdCA9IGNvbW1vblN0cmluZyArIGVkaXQuc3Vic3RyaW5nKDAsIGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KSwgZXF1YWxpdHkyID0gY29tbW9uU3RyaW5nICsgZXF1YWxpdHkyO1xuICAgICAgfVxuICAgICAgbGV0IGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTEsIGJlc3RFZGl0ID0gZWRpdCwgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MiwgYmVzdFNjb3JlID0gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgKyBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgIGZvciAoOyBlZGl0LmNoYXJBdCgwKSA9PT0gZXF1YWxpdHkyLmNoYXJBdCgwKTsgKSB7XG4gICAgICAgIGVxdWFsaXR5MSArPSBlZGl0LmNoYXJBdCgwKSwgZWRpdCA9IGVkaXQuc3Vic3RyaW5nKDEpICsgZXF1YWxpdHkyLmNoYXJBdCgwKSwgZXF1YWxpdHkyID0gZXF1YWxpdHkyLnN1YnN0cmluZygxKTtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZXF1YWxpdHkxLCBlZGl0KSArIGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgICBzY29yZSA+PSBiZXN0U2NvcmUgJiYgKGJlc3RTY29yZSA9IHNjb3JlLCBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxLCBiZXN0RWRpdCA9IGVkaXQsIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTIpO1xuICAgICAgfVxuICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICE9PSBiZXN0RXF1YWxpdHkxICYmIChiZXN0RXF1YWxpdHkxID8gZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gYmVzdEVxdWFsaXR5MSA6IChkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpLCBwb2ludGVyLS0pLCBkaWZmc1twb2ludGVyXVsxXSA9IGJlc3RFZGl0LCBiZXN0RXF1YWxpdHkyID8gZGlmZnNbcG9pbnRlciArIDFdWzFdID0gYmVzdEVxdWFsaXR5MiA6IChkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpLCBwb2ludGVyLS0pKTtcbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIHJldHVybiBkaWZmcztcbn1cbmZ1bmN0aW9uIGNsZWFudXBNZXJnZShyYXdEaWZmcykge1xuICBsZXQgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKTtcbiAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgXCJcIl0pO1xuICBsZXQgcG9pbnRlciA9IDAsIGNvdW50RGVsZXRlID0gMCwgY291bnRJbnNlcnQgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCIsIGNvbW1vbmxlbmd0aDtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7IClcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudEluc2VydCsrLCB0ZXh0SW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdLCBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgY291bnREZWxldGUrKywgdGV4dERlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXSwgcG9pbnRlcisrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgY291bnREZWxldGUgKyBjb3VudEluc2VydCA+IDEgPyAoY291bnREZWxldGUgIT09IDAgJiYgY291bnRJbnNlcnQgIT09IDAgJiYgKGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblByZWZpeCh0ZXh0SW5zZXJ0LCB0ZXh0RGVsZXRlKSwgY29tbW9ubGVuZ3RoICE9PSAwICYmIChwb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCA+IDAgJiYgZGlmZnNbcG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQgLSAxXVswXSA9PT0gRElGRl9FUVVBTCA/IGRpZmZzW3BvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0IC0gMV1bMV0gKz0gdGV4dEluc2VydC5zdWJzdHJpbmcoXG4gICAgICAgICAgMCxcbiAgICAgICAgICBjb21tb25sZW5ndGhcbiAgICAgICAgKSA6IChkaWZmcy5zcGxpY2UoMCwgMCwgW0RJRkZfRVFVQUwsIHRleHRJbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCldKSwgcG9pbnRlcisrKSwgdGV4dEluc2VydCA9IHRleHRJbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIHRleHREZWxldGUgPSB0ZXh0RGVsZXRlLnN1YnN0cmluZyhjb21tb25sZW5ndGgpKSwgY29tbW9ubGVuZ3RoID0gZ2V0Q29tbW9uU3VmZml4KHRleHRJbnNlcnQsIHRleHREZWxldGUpLCBjb21tb25sZW5ndGggIT09IDAgJiYgKGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dEluc2VydC5zdWJzdHJpbmcodGV4dEluc2VydC5sZW5ndGggLSBjb21tb25sZW5ndGgpICsgZGlmZnNbcG9pbnRlcl1bMV0sIHRleHRJbnNlcnQgPSB0ZXh0SW5zZXJ0LnN1YnN0cmluZygwLCB0ZXh0SW5zZXJ0Lmxlbmd0aCAtIGNvbW1vbmxlbmd0aCksIHRleHREZWxldGUgPSB0ZXh0RGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0RGVsZXRlLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCkpKSwgcG9pbnRlciAtPSBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0LCBkaWZmcy5zcGxpY2UocG9pbnRlciwgY291bnREZWxldGUgKyBjb3VudEluc2VydCksIHRleHREZWxldGUubGVuZ3RoICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfREVMRVRFLCB0ZXh0RGVsZXRlXSksIHBvaW50ZXIrKyksIHRleHRJbnNlcnQubGVuZ3RoICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfSU5TRVJULCB0ZXh0SW5zZXJ0XSksIHBvaW50ZXIrKyksIHBvaW50ZXIrKykgOiBwb2ludGVyICE9PSAwICYmIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCA/IChkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV0sIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKSkgOiBwb2ludGVyKyssIGNvdW50SW5zZXJ0ID0gMCwgY291bnREZWxldGUgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkaWZmIG9wZXJhdGlvblwiKTtcbiAgICB9XG4gIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdID09PSBcIlwiICYmIGRpZmZzLnBvcCgpO1xuICBsZXQgaGFzQ2hhbmdlcyA9ICExO1xuICBmb3IgKHBvaW50ZXIgPSAxOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMTsgKVxuICAgIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmc1twb2ludGVyICsgMV1bMF0gPT09IERJRkZfRVFVQUwgJiYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLSBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSA9PT0gZGlmZnNbcG9pbnRlciAtIDFdWzFdID8gKGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpLCBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyICsgMV1bMV0sIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSksIGhhc0NoYW5nZXMgPSAhMCkgOiBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgPT09IGRpZmZzW3BvaW50ZXIgKyAxXVsxXSAmJiAoZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXSwgZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgKyBkaWZmc1twb2ludGVyICsgMV1bMV0sIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSksIGhhc0NoYW5nZXMgPSAhMCkpLCBwb2ludGVyKys7XG4gIHJldHVybiBoYXNDaGFuZ2VzICYmIChkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcykpLCBkaWZmcztcbn1cbmZ1bmN0aW9uIHRydWVDb3VudCguLi5hcmdzKSB7XG4gIHJldHVybiBhcmdzLnJlZHVjZSgobiwgYm9vbCkgPT4gbiArIChib29sID8gMSA6IDApLCAwKTtcbn1cbmZ1bmN0aW9uIGNsZWFudXBFZmZpY2llbmN5KHJhd0RpZmZzLCBlZGl0Q29zdCA9IDQpIHtcbiAgbGV0IGRpZmZzID0gcmF3RGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSksIGhhc0NoYW5nZXMgPSAhMTtcbiAgY29uc3QgZXF1YWxpdGllcyA9IFtdO1xuICBsZXQgZXF1YWxpdGllc0xlbmd0aCA9IDAsIGxhc3RFcXVhbGl0eSA9IG51bGwsIHBvaW50ZXIgPSAwLCBwcmVJbnMgPSAhMSwgcHJlRGVsID0gITEsIHBvc3RJbnMgPSAhMSwgcG9zdERlbCA9ICExO1xuICBmb3IgKDsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKVxuICAgIGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0VRVUFMID8gKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCA8IGVkaXRDb3N0ICYmIChwb3N0SW5zIHx8IHBvc3REZWwpID8gKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXIsIHByZUlucyA9IHBvc3RJbnMsIHByZURlbCA9IHBvc3REZWwsIGxhc3RFcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdKSA6IChlcXVhbGl0aWVzTGVuZ3RoID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCksIHBvc3RJbnMgPSAhMSwgcG9zdERlbCA9ICExKSA6IChkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9ERUxFVEUgPyBwb3N0RGVsID0gITAgOiBwb3N0SW5zID0gITAsIGxhc3RFcXVhbGl0eSAmJiAocHJlSW5zICYmIHByZURlbCAmJiBwb3N0SW5zICYmIHBvc3REZWwgfHwgbGFzdEVxdWFsaXR5Lmxlbmd0aCA8IGVkaXRDb3N0IC8gMiAmJiB0cnVlQ291bnQocHJlSW5zLCBwcmVEZWwsIHBvc3RJbnMsIHBvc3REZWwpID09PSAzKSAmJiAoZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLCBbRElGRl9ERUxFVEUsIGxhc3RFcXVhbGl0eV0pLCBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQsIGVxdWFsaXRpZXNMZW5ndGgtLSwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgcHJlSW5zICYmIHByZURlbCA/IChwb3N0SW5zID0gITAsIHBvc3REZWwgPSAhMCwgZXF1YWxpdGllc0xlbmd0aCA9IDApIDogKGVxdWFsaXRpZXNMZW5ndGgtLSwgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMSwgcG9zdElucyA9ICExLCBwb3N0RGVsID0gITEpLCBoYXNDaGFuZ2VzID0gITApKSwgcG9pbnRlcisrO1xuICByZXR1cm4gaGFzQ2hhbmdlcyAmJiAoZGlmZnMgPSBjbGVhbnVwTWVyZ2UoZGlmZnMpKSwgZGlmZnM7XG59XG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZ2V0T3duUHJvcFN5bWJvbHMkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIF9faGFzT3duUHJvcCQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgX19wcm9wSXNFbnVtJDEgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fc3ByZWFkVmFsdWVzJDEgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgX19oYXNPd25Qcm9wJDEuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AkMShhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMkMSlcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMkMShiKSlcbiAgICAgIF9fcHJvcElzRW51bSQxLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDEoYSwgcHJvcCwgYltwcm9wXSk7XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgLyoqXG4gICAqIEF0IHdoYXQgcG9pbnQgaXMgbm8gbWF0Y2ggZGVjbGFyZWQgKDAuMCA9IHBlcmZlY3Rpb24sIDEuMCA9IHZlcnkgbG9vc2UpLlxuICAgKi9cbiAgdGhyZXNob2xkOiAwLjUsXG4gIC8qKlxuICAgKiBIb3cgZmFyIHRvIHNlYXJjaCBmb3IgYSBtYXRjaCAoMCA9IGV4YWN0IGxvY2F0aW9uLCAxMDAwKyA9IGJyb2FkIG1hdGNoKS5cbiAgICogQSBtYXRjaCB0aGlzIG1hbnkgY2hhcmFjdGVycyBhd2F5IGZyb20gdGhlIGV4cGVjdGVkIGxvY2F0aW9uIHdpbGwgYWRkXG4gICAqIDEuMCB0byB0aGUgc2NvcmUgKDAuMCBpcyBhIHBlcmZlY3QgbWF0Y2gpLlxuICAgKi9cbiAgZGlzdGFuY2U6IDFlM1xufTtcbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMob3B0aW9ucykge1xuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMkMShfX3NwcmVhZFZhbHVlcyQxKHt9LCBERUZBVUxUX09QVElPTlMpLCBvcHRpb25zKTtcbn1cbmNvbnN0IE1BWF9CSVRTJDEgPSAzMjtcbmZ1bmN0aW9uIGJpdGFwKHRleHQsIHBhdHRlcm4sIGxvYywgb3B0cyA9IHt9KSB7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9CSVRTJDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0dGVybiB0b28gbG9uZyBmb3IgdGhpcyBicm93c2VyLlwiKTtcbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdHMob3B0cyksIHMgPSBnZXRBbHBoYWJldEZyb21QYXR0ZXJuKHBhdHRlcm4pO1xuICBmdW5jdGlvbiBnZXRCaXRhcFNjb3JlKGUsIHgpIHtcbiAgICBjb25zdCBhY2N1cmFjeSA9IGUgLyBwYXR0ZXJuLmxlbmd0aCwgcHJveGltaXR5ID0gTWF0aC5hYnMobG9jIC0geCk7XG4gICAgcmV0dXJuIG9wdGlvbnMuZGlzdGFuY2UgPyBhY2N1cmFjeSArIHByb3hpbWl0eSAvIG9wdGlvbnMuZGlzdGFuY2UgOiBwcm94aW1pdHkgPyAxIDogYWNjdXJhY3k7XG4gIH1cbiAgbGV0IHNjb3JlVGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQsIGJlc3RMb2MgPSB0ZXh0LmluZGV4T2YocGF0dGVybiwgbG9jKTtcbiAgYmVzdExvYyAhPT0gLTEgJiYgKHNjb3JlVGhyZXNob2xkID0gTWF0aC5taW4oZ2V0Qml0YXBTY29yZSgwLCBiZXN0TG9jKSwgc2NvcmVUaHJlc2hvbGQpLCBiZXN0TG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCksIGJlc3RMb2MgIT09IC0xICYmIChzY29yZVRocmVzaG9sZCA9IE1hdGgubWluKGdldEJpdGFwU2NvcmUoMCwgYmVzdExvYyksIHNjb3JlVGhyZXNob2xkKSkpO1xuICBjb25zdCBtYXRjaG1hc2sgPSAxIDw8IHBhdHRlcm4ubGVuZ3RoIC0gMTtcbiAgYmVzdExvYyA9IC0xO1xuICBsZXQgYmluTWluLCBiaW5NaWQsIGJpbk1heCA9IHBhdHRlcm4ubGVuZ3RoICsgdGV4dC5sZW5ndGgsIGxhc3RSZCA9IFtdO1xuICBmb3IgKGxldCBkID0gMDsgZCA8IHBhdHRlcm4ubGVuZ3RoOyBkKyspIHtcbiAgICBmb3IgKGJpbk1pbiA9IDAsIGJpbk1pZCA9IGJpbk1heDsgYmluTWluIDwgYmluTWlkOyApXG4gICAgICBnZXRCaXRhcFNjb3JlKGQsIGxvYyArIGJpbk1pZCkgPD0gc2NvcmVUaHJlc2hvbGQgPyBiaW5NaW4gPSBiaW5NaWQgOiBiaW5NYXggPSBiaW5NaWQsIGJpbk1pZCA9IE1hdGguZmxvb3IoKGJpbk1heCAtIGJpbk1pbikgLyAyICsgYmluTWluKTtcbiAgICBiaW5NYXggPSBiaW5NaWQ7XG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoMSwgbG9jIC0gYmluTWlkICsgMSk7XG4gICAgY29uc3QgZmluaXNoID0gTWF0aC5taW4obG9jICsgYmluTWlkLCB0ZXh0Lmxlbmd0aCkgKyBwYXR0ZXJuLmxlbmd0aCwgcmQgPSBuZXcgQXJyYXkoZmluaXNoICsgMik7XG4gICAgcmRbZmluaXNoICsgMV0gPSAoMSA8PCBkKSAtIDE7XG4gICAgZm9yIChsZXQgaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgai0tKSB7XG4gICAgICBjb25zdCBjaGFyTWF0Y2ggPSBzW3RleHQuY2hhckF0KGogLSAxKV07XG4gICAgICBpZiAoZCA9PT0gMCA/IHJkW2pdID0gKHJkW2ogKyAxXSA8PCAxIHwgMSkgJiBjaGFyTWF0Y2ggOiByZFtqXSA9IChyZFtqICsgMV0gPDwgMSB8IDEpICYgY2hhck1hdGNoIHwgKChsYXN0UmRbaiArIDFdIHwgbGFzdFJkW2pdKSA8PCAxIHwgMSkgfCBsYXN0UmRbaiArIDFdLCByZFtqXSAmIG1hdGNobWFzaykge1xuICAgICAgICBjb25zdCBzY29yZSA9IGdldEJpdGFwU2NvcmUoZCwgaiAtIDEpO1xuICAgICAgICBpZiAoc2NvcmUgPD0gc2NvcmVUaHJlc2hvbGQpXG4gICAgICAgICAgaWYgKHNjb3JlVGhyZXNob2xkID0gc2NvcmUsIGJlc3RMb2MgPSBqIC0gMSwgYmVzdExvYyA+IGxvYylcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGxvYyAtIGJlc3RMb2MpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2V0Qml0YXBTY29yZShkICsgMSwgbG9jKSA+IHNjb3JlVGhyZXNob2xkKVxuICAgICAgYnJlYWs7XG4gICAgbGFzdFJkID0gcmQ7XG4gIH1cbiAgcmV0dXJuIGJlc3RMb2M7XG59XG5mdW5jdGlvbiBnZXRBbHBoYWJldEZyb21QYXR0ZXJuKHBhdHRlcm4pIHtcbiAgY29uc3QgcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspXG4gICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspXG4gICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCBwYXR0ZXJuLmxlbmd0aCAtIGkgLSAxO1xuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIG1hdGNoKHRleHQsIHBhdHRlcm4sIHNlYXJjaExvY2F0aW9uKSB7XG4gIGlmICh0ZXh0ID09PSBudWxsIHx8IHBhdHRlcm4gPT09IG51bGwgfHwgc2VhcmNoTG9jYXRpb24gPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBpbnB1dC4gKG1hdGNoKCkpXCIpO1xuICBjb25zdCBsb2MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZWFyY2hMb2NhdGlvbiwgdGV4dC5sZW5ndGgpKTtcbiAgaWYgKHRleHQgPT09IHBhdHRlcm4pXG4gICAgcmV0dXJuIDA7XG4gIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgIGlmICh0ZXh0LnN1YnN0cmluZyhsb2MsIGxvYyArIHBhdHRlcm4ubGVuZ3RoKSA9PT0gcGF0dGVybilcbiAgICAgIHJldHVybiBsb2M7XG4gIH0gZWxzZSByZXR1cm4gLTE7XG4gIHJldHVybiBiaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MpO1xufVxuZnVuY3Rpb24gZGlmZlRleHQxKGRpZmZzKSB7XG4gIGNvbnN0IHRleHQgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKylcbiAgICBkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQgJiYgKHRleHRbeF0gPSBkaWZmc1t4XVsxXSk7XG4gIHJldHVybiB0ZXh0LmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBkaWZmVGV4dDIoZGlmZnMpIHtcbiAgY29uc3QgdGV4dCA9IFtdO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKVxuICAgIGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSAmJiAodGV4dFt4XSA9IGRpZmZzW3hdWzFdKTtcbiAgcmV0dXJuIHRleHQuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGxldmVuc2h0ZWluKGRpZmZzKSB7XG4gIGxldCBsZXZlbiA9IDAsIGluc2VydGlvbnMgPSAwLCBkZWxldGlvbnMgPSAwO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3Qgb3AgPSBkaWZmc1t4XVswXSwgZGF0YSA9IGRpZmZzW3hdWzFdO1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGluc2VydGlvbnMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgZGVsZXRpb25zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgbGV2ZW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKSwgaW5zZXJ0aW9ucyA9IDAsIGRlbGV0aW9ucyA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkaWZmIG9wZXJhdGlvbi5cIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZXZlbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpLCBsZXZlbjtcbn1cbmZ1bmN0aW9uIHhJbmRleChkaWZmcywgbG9jKSB7XG4gIGxldCBjaGFyczEgPSAwLCBjaGFyczIgPSAwLCBsYXN0Q2hhcnMxID0gMCwgbGFzdENoYXJzMiA9IDAsIHg7XG4gIGZvciAoeCA9IDA7IHggPCBkaWZmcy5sZW5ndGggJiYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0lOU0VSVCAmJiAoY2hhcnMxICs9IGRpZmZzW3hdWzFdLmxlbmd0aCksIGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSAmJiAoY2hhcnMyICs9IGRpZmZzW3hdWzFdLmxlbmd0aCksICEoY2hhcnMxID4gbG9jKSk7IHgrKylcbiAgICBsYXN0Q2hhcnMxID0gY2hhcnMxLCBsYXN0Q2hhcnMyID0gY2hhcnMyO1xuICByZXR1cm4gZGlmZnMubGVuZ3RoICE9PSB4ICYmIGRpZmZzW3hdWzBdID09PSBESUZGX0RFTEVURSA/IGxhc3RDaGFyczIgOiBsYXN0Q2hhcnMyICsgKGxvYyAtIGxhc3RDaGFyczEpO1xufVxuZnVuY3Rpb24gY291bnRVdGY4Qnl0ZXMoc3RyKSB7XG4gIGxldCBieXRlcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgIGlmICh0eXBlb2YgY29kZVBvaW50ID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGNvZGVwb2ludFwiKTtcbiAgICBieXRlcyArPSB1dGY4bGVuKGNvZGVQb2ludCk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gYWRqdXN0SW5kaWNpZXNUb1VjczIocGF0Y2hlcywgYmFzZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBieXRlT2Zmc2V0ID0gMCwgaWR4ID0gMDtcbiAgZnVuY3Rpb24gYWR2YW5jZVRvKHRhcmdldCkge1xuICAgIGZvciAoOyBieXRlT2Zmc2V0IDwgdGFyZ2V0OyApIHtcbiAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGJhc2UuY29kZVBvaW50QXQoaWR4KTtcbiAgICAgIGlmICh0eXBlb2YgY29kZVBvaW50ID4gXCJ1XCIpXG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgICBieXRlT2Zmc2V0ICs9IHV0ZjhsZW4oY29kZVBvaW50KSwgY29kZVBvaW50ID4gNjU1MzUgPyBpZHggKz0gMiA6IGlkeCArPSAxO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuYWxsb3dFeGNlZWRpbmdJbmRpY2VzICYmIGJ5dGVPZmZzZXQgIT09IHRhcmdldClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZXRlcm1pbmUgYnl0ZSBvZmZzZXRcIik7XG4gICAgcmV0dXJuIGlkeDtcbiAgfVxuICBjb25zdCBhZGp1c3RlZCA9IFtdO1xuICBmb3IgKGNvbnN0IHBhdGNoIG9mIHBhdGNoZXMpXG4gICAgYWRqdXN0ZWQucHVzaCh7XG4gICAgICBkaWZmczogcGF0Y2guZGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSksXG4gICAgICBzdGFydDE6IGFkdmFuY2VUbyhwYXRjaC5zdGFydDEpLFxuICAgICAgc3RhcnQyOiBhZHZhbmNlVG8ocGF0Y2guc3RhcnQyKSxcbiAgICAgIHV0ZjhTdGFydDE6IHBhdGNoLnV0ZjhTdGFydDEsXG4gICAgICB1dGY4U3RhcnQyOiBwYXRjaC51dGY4U3RhcnQyLFxuICAgICAgbGVuZ3RoMTogcGF0Y2gubGVuZ3RoMSxcbiAgICAgIGxlbmd0aDI6IHBhdGNoLmxlbmd0aDIsXG4gICAgICB1dGY4TGVuZ3RoMTogcGF0Y2gudXRmOExlbmd0aDEsXG4gICAgICB1dGY4TGVuZ3RoMjogcGF0Y2gudXRmOExlbmd0aDJcbiAgICB9KTtcbiAgcmV0dXJuIGFkanVzdGVkO1xufVxuZnVuY3Rpb24gdXRmOGxlbihjb2RlUG9pbnQpIHtcbiAgcmV0dXJuIGNvZGVQb2ludCA8PSAxMjcgPyAxIDogY29kZVBvaW50IDw9IDIwNDcgPyAyIDogY29kZVBvaW50IDw9IDY1NTM1ID8gMyA6IDQ7XG59XG5jb25zdCBNQVhfQklUUyA9IDMyLCBERUZBVUxUX01BUkdJTiA9IDQ7XG5mdW5jdGlvbiBhZGRQYWRkaW5nKHBhdGNoZXMsIG1hcmdpbiA9IERFRkFVTFRfTUFSR0lOKSB7XG4gIGNvbnN0IHBhZGRpbmdMZW5ndGggPSBtYXJnaW47XG4gIGxldCBudWxsUGFkZGluZyA9IFwiXCI7XG4gIGZvciAobGV0IHggPSAxOyB4IDw9IHBhZGRpbmdMZW5ndGg7IHgrKylcbiAgICBudWxsUGFkZGluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xuICBmb3IgKGNvbnN0IHAgb2YgcGF0Y2hlcylcbiAgICBwLnN0YXJ0MSArPSBwYWRkaW5nTGVuZ3RoLCBwLnN0YXJ0MiArPSBwYWRkaW5nTGVuZ3RoLCBwLnV0ZjhTdGFydDEgKz0gcGFkZGluZ0xlbmd0aCwgcC51dGY4U3RhcnQyICs9IHBhZGRpbmdMZW5ndGg7XG4gIGxldCBwYXRjaCA9IHBhdGNoZXNbMF0sIGRpZmZzID0gcGF0Y2guZGlmZnM7XG4gIGlmIChkaWZmcy5sZW5ndGggPT09IDAgfHwgZGlmZnNbMF1bMF0gIT09IERJRkZfRVFVQUwpXG4gICAgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKSwgcGF0Y2guc3RhcnQxIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQxIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhTdGFydDIgLT0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1swXVsxXS5sZW5ndGgpIHtcbiAgICBjb25zdCBmaXJzdERpZmZMZW5ndGggPSBkaWZmc1swXVsxXS5sZW5ndGgsIGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGZpcnN0RGlmZkxlbmd0aDtcbiAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhmaXJzdERpZmZMZW5ndGgpICsgZGlmZnNbMF1bMV0sIHBhdGNoLnN0YXJ0MSAtPSBleHRyYUxlbmd0aCwgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQxIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQyIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cbiAgaWYgKHBhdGNoID0gcGF0Y2hlc1twYXRjaGVzLmxlbmd0aCAtIDFdLCBkaWZmcyA9IHBhdGNoLmRpZmZzLCBkaWZmcy5sZW5ndGggPT09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT09IERJRkZfRVFVQUwpXG4gICAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKSwgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGgpIHtcbiAgICBjb25zdCBleHRyYUxlbmd0aCA9IHBhZGRpbmdMZW5ndGggLSBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGg7XG4gICAgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKDAsIGV4dHJhTGVuZ3RoKSwgcGF0Y2gubGVuZ3RoMSArPSBleHRyYUxlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IGV4dHJhTGVuZ3RoO1xuICB9XG4gIHJldHVybiBudWxsUGFkZGluZztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoT2JqZWN0KHN0YXJ0MSwgc3RhcnQyKSB7XG4gIHJldHVybiB7XG4gICAgZGlmZnM6IFtdLFxuICAgIHN0YXJ0MSxcbiAgICBzdGFydDIsXG4gICAgdXRmOFN0YXJ0MTogc3RhcnQxLFxuICAgIHV0ZjhTdGFydDI6IHN0YXJ0MixcbiAgICBsZW5ndGgxOiAwLFxuICAgIGxlbmd0aDI6IDAsXG4gICAgdXRmOExlbmd0aDE6IDAsXG4gICAgdXRmOExlbmd0aDI6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0TWF4KHBhdGNoZXMsIG1hcmdpbiA9IERFRkFVTFRfTUFSR0lOKSB7XG4gIGNvbnN0IHBhdGNoU2l6ZSA9IE1BWF9CSVRTO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICBpZiAocGF0Y2hlc1t4XS5sZW5ndGgxIDw9IHBhdGNoU2l6ZSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGJpZ3BhdGNoID0gcGF0Y2hlc1t4XTtcbiAgICBwYXRjaGVzLnNwbGljZSh4LS0sIDEpO1xuICAgIGxldCBzdGFydDEgPSBiaWdwYXRjaC5zdGFydDEsIHN0YXJ0MiA9IGJpZ3BhdGNoLnN0YXJ0MiwgcHJlQ29udGV4dCA9IFwiXCI7XG4gICAgZm9yICg7IGJpZ3BhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMDsgKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IGNyZWF0ZVBhdGNoT2JqZWN0KHN0YXJ0MSAtIHByZUNvbnRleHQubGVuZ3RoLCBzdGFydDIgLSBwcmVDb250ZXh0Lmxlbmd0aCk7XG4gICAgICBsZXQgZW1wdHkgPSAhMDtcbiAgICAgIGlmIChwcmVDb250ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IHByZWNvbnRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhwcmVDb250ZXh0KTtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSA9IHByZUNvbnRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSA9IHByZWNvbnRleHRCeXRlQ291bnQsIHBhdGNoLmxlbmd0aDIgPSBwcmVDb250ZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgPSBwcmVjb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwcmVDb250ZXh0XSk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmxlbmd0aDEgPCBwYXRjaFNpemUgLSBtYXJnaW47ICkge1xuICAgICAgICBjb25zdCBkaWZmVHlwZSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzBdO1xuICAgICAgICBsZXQgZGlmZlRleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXSwgZGlmZlRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhkaWZmVGV4dCk7XG4gICAgICAgIGlmIChkaWZmVHlwZSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MiArPSBkaWZmVGV4dC5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgZGlmZjIgPSBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgIGRpZmYyICYmIHBhdGNoLmRpZmZzLnB1c2goZGlmZjIpLCBlbXB0eSA9ICExO1xuICAgICAgICB9IGVsc2UgZGlmZlR5cGUgPT09IERJRkZfREVMRVRFICYmIHBhdGNoLmRpZmZzLmxlbmd0aCA9PT0gMSAmJiBwYXRjaC5kaWZmc1swXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmVGV4dC5sZW5ndGggPiAyICogcGF0Y2hTaXplID8gKHBhdGNoLmxlbmd0aDEgKz0gZGlmZlRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBkaWZmVGV4dEJ5dGVDb3VudCwgc3RhcnQxICs9IGRpZmZUZXh0Lmxlbmd0aCwgZW1wdHkgPSAhMSwgcGF0Y2guZGlmZnMucHVzaChbZGlmZlR5cGUsIGRpZmZUZXh0XSksIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkpIDogKGRpZmZUZXh0ID0gZGlmZlRleHQuc3Vic3RyaW5nKDAsIHBhdGNoU2l6ZSAtIHBhdGNoLmxlbmd0aDEgLSBtYXJnaW4pLCBkaWZmVGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKGRpZmZUZXh0KSwgcGF0Y2gubGVuZ3RoMSArPSBkaWZmVGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGRpZmZUZXh0Qnl0ZUNvdW50LCBzdGFydDEgKz0gZGlmZlRleHQubGVuZ3RoLCBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCA/IChwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MiArPSBkaWZmVGV4dC5sZW5ndGgpIDogZW1wdHkgPSAhMSwgcGF0Y2guZGlmZnMucHVzaChbZGlmZlR5cGUsIGRpZmZUZXh0XSksIGRpZmZUZXh0ID09PSBiaWdwYXRjaC5kaWZmc1swXVsxXSA/IGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkgOiBiaWdwYXRjaC5kaWZmc1swXVsxXSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdLnN1YnN0cmluZyhkaWZmVGV4dC5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHByZUNvbnRleHQgPSBkaWZmVGV4dDIocGF0Y2guZGlmZnMpLCBwcmVDb250ZXh0ID0gcHJlQ29udGV4dC5zdWJzdHJpbmcocHJlQ29udGV4dC5sZW5ndGggLSBtYXJnaW4pO1xuICAgICAgY29uc3QgcG9zdENvbnRleHQgPSBkaWZmVGV4dDEoYmlncGF0Y2guZGlmZnMpLnN1YnN0cmluZygwLCBtYXJnaW4pLCBwb3N0Q29udGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKHBvc3RDb250ZXh0KTtcbiAgICAgIHBvc3RDb250ZXh0ICE9PSBcIlwiICYmIChwYXRjaC5sZW5ndGgxICs9IHBvc3RDb250ZXh0Lmxlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwb3N0Q29udGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBvc3RDb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwb3N0Q29udGV4dEJ5dGVDb3VudCwgcGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzBdID09PSBESUZGX0VRVUFMID8gcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gcG9zdENvbnRleHQgOiBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwb3N0Q29udGV4dF0pKSwgZW1wdHkgfHwgcGF0Y2hlcy5zcGxpY2UoKyt4LCAwLCBwYXRjaCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBseShwYXRjaGVzLCBvcmlnaW5hbFRleHQsIG9wdHMgPSB7fSkge1xuICBpZiAodHlwZW9mIHBhdGNoZXMgPT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRjaGVzIG11c3QgYmUgYW4gYXJyYXkgLSBwYXNzIHRoZSBwYXRjaCB0byBgcGFyc2VQYXRjaCgpYCBmaXJzdFwiKTtcbiAgbGV0IHRleHQgPSBvcmlnaW5hbFRleHQ7XG4gIGlmIChwYXRjaGVzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gW3RleHQsIFtdXTtcbiAgY29uc3QgcGFyc2VkID0gYWRqdXN0SW5kaWNpZXNUb1VjczIocGF0Y2hlcywgdGV4dCwge1xuICAgIGFsbG93RXhjZWVkaW5nSW5kaWNlczogb3B0cy5hbGxvd0V4Y2VlZGluZ0luZGljZXNcbiAgfSksIG1hcmdpbiA9IG9wdHMubWFyZ2luIHx8IERFRkFVTFRfTUFSR0lOLCBkZWxldGVUaHJlc2hvbGQgPSBvcHRzLmRlbGV0ZVRocmVzaG9sZCB8fCAwLjQsIG51bGxQYWRkaW5nID0gYWRkUGFkZGluZyhwYXJzZWQsIG1hcmdpbik7XG4gIHRleHQgPSBudWxsUGFkZGluZyArIHRleHQgKyBudWxsUGFkZGluZywgc3BsaXRNYXgocGFyc2VkLCBtYXJnaW4pO1xuICBsZXQgZGVsdGEgPSAwO1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgcGFyc2VkLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3QgZXhwZWN0ZWRMb2MgPSBwYXJzZWRbeF0uc3RhcnQyICsgZGVsdGEsIHRleHQxID0gZGlmZlRleHQxKHBhcnNlZFt4XS5kaWZmcyk7XG4gICAgbGV0IHN0YXJ0TG9jLCBlbmRMb2MgPSAtMTtcbiAgICBpZiAodGV4dDEubGVuZ3RoID4gTUFYX0JJVFMgPyAoc3RhcnRMb2MgPSBtYXRjaCh0ZXh0LCB0ZXh0MS5zdWJzdHJpbmcoMCwgTUFYX0JJVFMpLCBleHBlY3RlZExvYyksIHN0YXJ0TG9jICE9PSAtMSAmJiAoZW5kTG9jID0gbWF0Y2goXG4gICAgICB0ZXh0LFxuICAgICAgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIE1BWF9CSVRTKSxcbiAgICAgIGV4cGVjdGVkTG9jICsgdGV4dDEubGVuZ3RoIC0gTUFYX0JJVFNcbiAgICApLCAoZW5kTG9jID09PSAtMSB8fCBzdGFydExvYyA+PSBlbmRMb2MpICYmIChzdGFydExvYyA9IC0xKSkpIDogc3RhcnRMb2MgPSBtYXRjaCh0ZXh0LCB0ZXh0MSwgZXhwZWN0ZWRMb2MpLCBzdGFydExvYyA9PT0gLTEpXG4gICAgICByZXN1bHRzW3hdID0gITEsIGRlbHRhIC09IHBhcnNlZFt4XS5sZW5ndGgyIC0gcGFyc2VkW3hdLmxlbmd0aDE7XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHRzW3hdID0gITAsIGRlbHRhID0gc3RhcnRMb2MgLSBleHBlY3RlZExvYztcbiAgICAgIGxldCB0ZXh0MjtcbiAgICAgIGlmIChlbmRMb2MgPT09IC0xID8gdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydExvYywgc3RhcnRMb2MgKyB0ZXh0MS5sZW5ndGgpIDogdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydExvYywgZW5kTG9jICsgTUFYX0JJVFMpLCB0ZXh0MSA9PT0gdGV4dDIpXG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydExvYykgKyBkaWZmVGV4dDIocGFyc2VkW3hdLmRpZmZzKSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgdGV4dDEubGVuZ3RoKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgZGlmZnMgPSBkaWZmKHRleHQxLCB0ZXh0MiwgeyBjaGVja0xpbmVzOiAhMSB9KTtcbiAgICAgICAgaWYgKHRleHQxLmxlbmd0aCA+IE1BWF9CSVRTICYmIGxldmVuc2h0ZWluKGRpZmZzKSAvIHRleHQxLmxlbmd0aCA+IGRlbGV0ZVRocmVzaG9sZClcbiAgICAgICAgICByZXN1bHRzW3hdID0gITE7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRpZmZzID0gY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xuICAgICAgICAgIGxldCBpbmRleDEgPSAwLCBpbmRleDIgPSAwO1xuICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgcGFyc2VkW3hdLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICBjb25zdCBtb2QgPSBwYXJzZWRbeF0uZGlmZnNbeV07XG4gICAgICAgICAgICBtb2RbMF0gIT09IERJRkZfRVFVQUwgJiYgKGluZGV4MiA9IHhJbmRleChkaWZmcywgaW5kZXgxKSksIG1vZFswXSA9PT0gRElGRl9JTlNFUlQgPyB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRMb2MgKyBpbmRleDIpICsgbW9kWzFdICsgdGV4dC5zdWJzdHJpbmcoc3RhcnRMb2MgKyBpbmRleDIpIDogbW9kWzBdID09PSBESUZGX0RFTEVURSAmJiAodGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0TG9jICsgaW5kZXgyKSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgeEluZGV4KGRpZmZzLCBpbmRleDEgKyBtb2RbMV0ubGVuZ3RoKSkpLCBtb2RbMF0gIT09IERJRkZfREVMRVRFICYmIChpbmRleDEgKz0gbW9kWzFdLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcobnVsbFBhZGRpbmcubGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIG51bGxQYWRkaW5nLmxlbmd0aCksIFt0ZXh0LCByZXN1bHRzXTtcbn1cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpXG4gICAgICBfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IERFRkFVTFRfT1BUUyA9IHtcbiAgbWFyZ2luOiA0XG59O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdE9wdHMob3B0cyA9IHt9KSB7XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgREVGQVVMVF9PUFRTKSwgb3B0cyk7XG59XG5mdW5jdGlvbiBtYWtlKGEsIGIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGIgPT0gXCJzdHJpbmdcIikge1xuICAgIGxldCBkaWZmcyA9IGRpZmYoYSwgYiwgeyBjaGVja0xpbmVzOiAhMCB9KTtcbiAgICByZXR1cm4gZGlmZnMubGVuZ3RoID4gMiAmJiAoZGlmZnMgPSBjbGVhbnVwU2VtYW50aWMoZGlmZnMpLCBkaWZmcyA9IGNsZWFudXBFZmZpY2llbmN5KGRpZmZzKSksIF9tYWtlKGEsIGRpZmZzLCBnZXREZWZhdWx0T3B0cyhvcHRpb25zKSk7XG4gIH1cbiAgaWYgKGEgJiYgQXJyYXkuaXNBcnJheShhKSAmJiB0eXBlb2YgYiA+IFwidVwiKVxuICAgIHJldHVybiBfbWFrZShkaWZmVGV4dDEoYSksIGEsIGdldERlZmF1bHRPcHRzKG9wdGlvbnMpKTtcbiAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIgJiYgYiAmJiBBcnJheS5pc0FycmF5KGIpKVxuICAgIHJldHVybiBfbWFrZShhLCBiLCBnZXREZWZhdWx0T3B0cyhvcHRpb25zKSk7XG4gIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY2FsbCBmb3JtYXQgdG8gbWFrZSgpXCIpO1xufVxuZnVuY3Rpb24gX21ha2UodGV4dEEsIGRpZmZzLCBvcHRpb25zKSB7XG4gIGlmIChkaWZmcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBwYXRjaGVzID0gW107XG4gIGxldCBwYXRjaCA9IGNyZWF0ZVBhdGNoT2JqZWN0KDAsIDApLCBwYXRjaERpZmZMZW5ndGggPSAwLCBjaGFyQ291bnQxID0gMCwgY2hhckNvdW50MiA9IDAsIHV0ZjhDb3VudDEgPSAwLCB1dGY4Q291bnQyID0gMCwgcHJlcGF0Y2hUZXh0ID0gdGV4dEEsIHBvc3RwYXRjaFRleHQgPSB0ZXh0QTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGNvbnN0IGN1cnJlbnREaWZmID0gZGlmZnNbeF0sIFtkaWZmVHlwZSwgZGlmZlRleHRdID0gY3VycmVudERpZmYsIGRpZmZUZXh0TGVuZ3RoID0gZGlmZlRleHQubGVuZ3RoLCBkaWZmQnl0ZUxlbmd0aCA9IGNvdW50VXRmOEJ5dGVzKGRpZmZUZXh0KTtcbiAgICBzd2l0Y2ggKCFwYXRjaERpZmZMZW5ndGggJiYgZGlmZlR5cGUgIT09IERJRkZfRVFVQUwgJiYgKHBhdGNoLnN0YXJ0MSA9IGNoYXJDb3VudDEsIHBhdGNoLnN0YXJ0MiA9IGNoYXJDb3VudDIsIHBhdGNoLnV0ZjhTdGFydDEgPSB1dGY4Q291bnQxLCBwYXRjaC51dGY4U3RhcnQyID0gdXRmOENvdW50MiksIGRpZmZUeXBlKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBjdXJyZW50RGlmZiwgcGF0Y2gubGVuZ3RoMiArPSBkaWZmVGV4dExlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZkJ5dGVMZW5ndGgsIHBvc3RwYXRjaFRleHQgPSBwb3N0cGF0Y2hUZXh0LnN1YnN0cmluZygwLCBjaGFyQ291bnQyKSArIGRpZmZUZXh0ICsgcG9zdHBhdGNoVGV4dC5zdWJzdHJpbmcoY2hhckNvdW50Mik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmVGV4dExlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gZGlmZkJ5dGVMZW5ndGgsIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGN1cnJlbnREaWZmLCBwb3N0cGF0Y2hUZXh0ID0gcG9zdHBhdGNoVGV4dC5zdWJzdHJpbmcoMCwgY2hhckNvdW50MikgKyBwb3N0cGF0Y2hUZXh0LnN1YnN0cmluZyhjaGFyQ291bnQyICsgZGlmZlRleHRMZW5ndGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgZGlmZlRleHRMZW5ndGggPD0gMiAqIG9wdGlvbnMubWFyZ2luICYmIHBhdGNoRGlmZkxlbmd0aCAmJiBkaWZmcy5sZW5ndGggIT09IHggKyAxID8gKHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGN1cnJlbnREaWZmLCBwYXRjaC5sZW5ndGgxICs9IGRpZmZUZXh0TGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0TGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBkaWZmQnl0ZUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZkJ5dGVMZW5ndGgpIDogZGlmZlRleHRMZW5ndGggPj0gMiAqIG9wdGlvbnMubWFyZ2luICYmIHBhdGNoRGlmZkxlbmd0aCAmJiAoYWRkQ29udGV4dChwYXRjaCwgcHJlcGF0Y2hUZXh0LCBvcHRpb25zKSwgcGF0Y2hlcy5wdXNoKHBhdGNoKSwgcGF0Y2ggPSBjcmVhdGVQYXRjaE9iamVjdCgtMSwgLTEpLCBwYXRjaERpZmZMZW5ndGggPSAwLCBwcmVwYXRjaFRleHQgPSBwb3N0cGF0Y2hUZXh0LCBjaGFyQ291bnQxID0gY2hhckNvdW50MiwgdXRmOENvdW50MSA9IHV0ZjhDb3VudDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGlmZiB0eXBlXCIpO1xuICAgIH1cbiAgICBkaWZmVHlwZSAhPT0gRElGRl9JTlNFUlQgJiYgKGNoYXJDb3VudDEgKz0gZGlmZlRleHRMZW5ndGgsIHV0ZjhDb3VudDEgKz0gZGlmZkJ5dGVMZW5ndGgpLCBkaWZmVHlwZSAhPT0gRElGRl9ERUxFVEUgJiYgKGNoYXJDb3VudDIgKz0gZGlmZlRleHRMZW5ndGgsIHV0ZjhDb3VudDIgKz0gZGlmZkJ5dGVMZW5ndGgpO1xuICB9XG4gIHJldHVybiBwYXRjaERpZmZMZW5ndGggJiYgKGFkZENvbnRleHQocGF0Y2gsIHByZXBhdGNoVGV4dCwgb3B0aW9ucyksIHBhdGNoZXMucHVzaChwYXRjaCkpLCBwYXRjaGVzO1xufVxuZnVuY3Rpb24gYWRkQ29udGV4dChwYXRjaCwgdGV4dCwgb3B0cykge1xuICBpZiAodGV4dC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuO1xuICBsZXQgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiwgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSksIHBhZGRpbmcgPSAwO1xuICBmb3IgKDsgdGV4dC5pbmRleE9mKHBhdHRlcm4pICE9PSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4pICYmIHBhdHRlcm4ubGVuZ3RoIDwgTUFYX0JJVFMgLSBvcHRzLm1hcmdpbiAtIG9wdHMubWFyZ2luOyApXG4gICAgcGFkZGluZyArPSBvcHRzLm1hcmdpbiwgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiAtIHBhZGRpbmcsIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEgKyBwYWRkaW5nKTtcbiAgcGFkZGluZyArPSBvcHRzLm1hcmdpbjtcbiAgbGV0IHByZWZpeFN0YXJ0ID0gcGF0Y2guc3RhcnQyIC0gcGFkZGluZztcbiAgcHJlZml4U3RhcnQgPj0gMSAmJiBpc0xvd1N1cnJvZ2F0ZSh0ZXh0W3ByZWZpeFN0YXJ0XSkgJiYgcHJlZml4U3RhcnQtLTtcbiAgY29uc3QgcHJlZml4ID0gdGV4dC5zdWJzdHJpbmcocHJlZml4U3RhcnQsIHBhdGNoLnN0YXJ0Mik7XG4gIHByZWZpeCAmJiBwYXRjaC5kaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBwcmVmaXhdKTtcbiAgY29uc3QgcHJlZml4TGVuZ3RoID0gcHJlZml4Lmxlbmd0aCwgcHJlZml4VXRmOExlbmd0aCA9IGNvdW50VXRmOEJ5dGVzKHByZWZpeCk7XG4gIGxldCBzdWZmaXhFbmQgPSBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZztcbiAgc3VmZml4RW5kIDwgdGV4dC5sZW5ndGggJiYgaXNMb3dTdXJyb2dhdGUodGV4dFtzdWZmaXhFbmRdKSAmJiBzdWZmaXhFbmQrKztcbiAgY29uc3Qgc3VmZml4ID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSwgc3VmZml4RW5kKTtcbiAgc3VmZml4ICYmIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIHN1ZmZpeF0pO1xuICBjb25zdCBzdWZmaXhMZW5ndGggPSBzdWZmaXgubGVuZ3RoLCBzdWZmaXhVdGY4TGVuZ3RoID0gY291bnRVdGY4Qnl0ZXMoc3VmZml4KTtcbiAgcGF0Y2guc3RhcnQxIC09IHByZWZpeExlbmd0aCwgcGF0Y2guc3RhcnQyIC09IHByZWZpeExlbmd0aCwgcGF0Y2gudXRmOFN0YXJ0MSAtPSBwcmVmaXhVdGY4TGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQyIC09IHByZWZpeFV0ZjhMZW5ndGgsIHBhdGNoLmxlbmd0aDEgKz0gcHJlZml4TGVuZ3RoICsgc3VmZml4TGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IHByZWZpeExlbmd0aCArIHN1ZmZpeExlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gcHJlZml4VXRmOExlbmd0aCArIHN1ZmZpeFV0ZjhMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IHByZWZpeFV0ZjhMZW5ndGggKyBzdWZmaXhVdGY4TGVuZ3RoO1xufVxuY29uc3QgcGF0Y2hIZWFkZXIgPSAvXkBAIC0oXFxkKyksPyhcXGQqKSBcXCsoXFxkKyksPyhcXGQqKSBAQCQvO1xuZnVuY3Rpb24gcGFyc2UodGV4dGxpbmUpIHtcbiAgaWYgKCF0ZXh0bGluZSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHBhdGNoZXMgPSBbXSwgbGluZXMgPSB0ZXh0bGluZS5zcGxpdChgXG5gKTtcbiAgbGV0IHRleHRQb2ludGVyID0gMDtcbiAgZm9yICg7IHRleHRQb2ludGVyIDwgbGluZXMubGVuZ3RoOyApIHtcbiAgICBjb25zdCBtID0gbGluZXNbdGV4dFBvaW50ZXJdLm1hdGNoKHBhdGNoSGVhZGVyKTtcbiAgICBpZiAoIW0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGF0Y2ggc3RyaW5nOiAke2xpbmVzW3RleHRQb2ludGVyXX1gKTtcbiAgICBjb25zdCBwYXRjaCA9IGNyZWF0ZVBhdGNoT2JqZWN0KHRvSW50KG1bMV0pLCB0b0ludChtWzNdKSk7XG4gICAgZm9yIChwYXRjaGVzLnB1c2gocGF0Y2gpLCBtWzJdID09PSBcIlwiID8gKHBhdGNoLnN0YXJ0MS0tLCBwYXRjaC51dGY4U3RhcnQxLS0sIHBhdGNoLmxlbmd0aDEgPSAxLCBwYXRjaC51dGY4TGVuZ3RoMSA9IDEpIDogbVsyXSA9PT0gXCIwXCIgPyAocGF0Y2gubGVuZ3RoMSA9IDAsIHBhdGNoLnV0ZjhMZW5ndGgxID0gMCkgOiAocGF0Y2guc3RhcnQxLS0sIHBhdGNoLnV0ZjhTdGFydDEtLSwgcGF0Y2gudXRmOExlbmd0aDEgPSB0b0ludChtWzJdKSwgcGF0Y2gubGVuZ3RoMSA9IHBhdGNoLnV0ZjhMZW5ndGgxKSwgbVs0XSA9PT0gXCJcIiA/IChwYXRjaC5zdGFydDItLSwgcGF0Y2gudXRmOFN0YXJ0Mi0tLCBwYXRjaC5sZW5ndGgyID0gMSwgcGF0Y2gudXRmOExlbmd0aDIgPSAxKSA6IG1bNF0gPT09IFwiMFwiID8gKHBhdGNoLmxlbmd0aDIgPSAwLCBwYXRjaC51dGY4TGVuZ3RoMiA9IDApIDogKHBhdGNoLnN0YXJ0Mi0tLCBwYXRjaC51dGY4U3RhcnQyLS0sIHBhdGNoLnV0ZjhMZW5ndGgyID0gdG9JbnQobVs0XSksIHBhdGNoLmxlbmd0aDIgPSBwYXRjaC51dGY4TGVuZ3RoMiksIHRleHRQb2ludGVyKys7IHRleHRQb2ludGVyIDwgbGluZXMubGVuZ3RoOyApIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRMaW5lID0gbGluZXNbdGV4dFBvaW50ZXJdLCBzaWduID0gY3VycmVudExpbmUuY2hhckF0KDApO1xuICAgICAgaWYgKHNpZ24gPT09IFwiQFwiKVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChzaWduID09PSBcIlwiKSB7XG4gICAgICAgIHRleHRQb2ludGVyKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGxpbmU7XG4gICAgICB0cnkge1xuICAgICAgICBsaW5lID0gZGVjb2RlVVJJKGN1cnJlbnRMaW5lLnNsaWNlKDEpKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCBlc2NhcGUgaW4gcGFyc2U6ICR7Y3VycmVudExpbmV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCB1dGY4RGlmZiA9IGNvdW50VXRmOEJ5dGVzKGxpbmUpIC0gbGluZS5sZW5ndGg7XG4gICAgICBpZiAoc2lnbiA9PT0gXCItXCIpXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfREVMRVRFLCBsaW5lXSksIHBhdGNoLmxlbmd0aDEgLT0gdXRmOERpZmY7XG4gICAgICBlbHNlIGlmIChzaWduID09PSBcIitcIilcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9JTlNFUlQsIGxpbmVdKSwgcGF0Y2gubGVuZ3RoMiAtPSB1dGY4RGlmZjtcbiAgICAgIGVsc2UgaWYgKHNpZ24gPT09IFwiIFwiKVxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBsaW5lXSksIHBhdGNoLmxlbmd0aDEgLT0gdXRmOERpZmYsIHBhdGNoLmxlbmd0aDIgLT0gdXRmOERpZmY7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXRjaCBtb2RlIFwiJHtzaWdufVwiIGluOiAke2xpbmV9YCk7XG4gICAgICB0ZXh0UG9pbnRlcisrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn1cbmZ1bmN0aW9uIHRvSW50KG51bSkge1xuICByZXR1cm4gcGFyc2VJbnQobnVtLCAxMCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkocGF0Y2hlcykge1xuICByZXR1cm4gcGF0Y2hlcy5tYXAoc3RyaW5naWZ5UGF0Y2gpLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlQYXRjaChwYXRjaCkge1xuICBjb25zdCB7IHV0ZjhMZW5ndGgxLCB1dGY4TGVuZ3RoMiwgdXRmOFN0YXJ0MSwgdXRmOFN0YXJ0MiwgZGlmZnMgfSA9IHBhdGNoO1xuICBsZXQgY29vcmRzMTtcbiAgdXRmOExlbmd0aDEgPT09IDAgPyBjb29yZHMxID0gYCR7dXRmOFN0YXJ0MX0sMGAgOiB1dGY4TGVuZ3RoMSA9PT0gMSA/IGNvb3JkczEgPSBgJHt1dGY4U3RhcnQxICsgMX1gIDogY29vcmRzMSA9IGAke3V0ZjhTdGFydDEgKyAxfSwke3V0ZjhMZW5ndGgxfWA7XG4gIGxldCBjb29yZHMyO1xuICB1dGY4TGVuZ3RoMiA9PT0gMCA/IGNvb3JkczIgPSBgJHt1dGY4U3RhcnQyfSwwYCA6IHV0ZjhMZW5ndGgyID09PSAxID8gY29vcmRzMiA9IGAke3V0ZjhTdGFydDIgKyAxfWAgOiBjb29yZHMyID0gYCR7dXRmOFN0YXJ0MiArIDF9LCR7dXRmOExlbmd0aDJ9YDtcbiAgY29uc3QgdGV4dCA9IFtgQEAgLSR7Y29vcmRzMX0gKyR7Y29vcmRzMn0gQEBcbmBdO1xuICBsZXQgb3A7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3hdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBvcCA9IFwiK1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIG9wID0gXCItXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBvcCA9IFwiIFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcGF0Y2ggb3BlcmF0aW9uLlwiKTtcbiAgICB9XG4gICAgdGV4dFt4ICsgMV0gPSBgJHtvcCArIGVuY29kZVVSSShkaWZmc1t4XVsxXSl9XG5gO1xuICB9XG4gIHJldHVybiB0ZXh0LmpvaW4oXCJcIikucmVwbGFjZSgvJTIwL2csIFwiIFwiKTtcbn1cbmV4cG9ydCB7XG4gIERJRkZfREVMRVRFLFxuICBESUZGX0VRVUFMLFxuICBESUZGX0lOU0VSVCxcbiAgYWRqdXN0SW5kaWNpZXNUb1VjczIsXG4gIGFwcGx5IGFzIGFwcGx5UGF0Y2hlcyxcbiAgY2xlYW51cEVmZmljaWVuY3ksXG4gIGNsZWFudXBTZW1hbnRpYyxcbiAgZGlmZiBhcyBtYWtlRGlmZixcbiAgbWFrZSBhcyBtYWtlUGF0Y2hlcyxcbiAgbWF0Y2gsXG4gIHBhcnNlIGFzIHBhcnNlUGF0Y2gsXG4gIHN0cmluZ2lmeVBhdGNoLFxuICBzdHJpbmdpZnkgYXMgc3RyaW5naWZ5UGF0Y2hlc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/PresentationComlink.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/_chunks-es/PresentationComlink.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PresentationComlink)\n/* harmony export */ });\n/* harmony import */ var _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sanity/comlink */ \"(ssr)/./node_modules/@sanity/comlink/dist/index.js\");\n/* harmony import */ var _sanity_next_loader_server_actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sanity/next-loader/server-actions */ \"(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-server-reference-proxy-loader.js?id=e7d447ba6bcd4a7db5fb0574fdcc1286073bbbc9&name=setPerspectiveCookie!\");\n/* harmony import */ var next_navigation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/navigation.js */ \"(ssr)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_effect_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! use-effect-event */ \"(ssr)/./node_modules/use-effect-event/dist/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/context.js\");\n\n\n\n\n\n\nconst channelsToComlinkMap = {\n  \"handshake/syn\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_SYN,\n  \"handshake/syn-ack\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_SYN_ACK,\n  \"handshake/ack\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_ACK,\n  \"channel/response\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_RESPONSE,\n  \"channel/heartbeat\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HEARTBEAT,\n  \"channel/disconnect\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_DISCONNECT,\n  \"overlay/focus\": \"visual-editing/focus\",\n  \"overlay/navigate\": \"visual-editing/navigate\",\n  \"overlay/toggle\": \"visual-editing/toggle\",\n  \"presentation/toggleOverlay\": \"presentation/toggle-overlay\"\n}, comlinkToChannelsMap = {\n  [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_SYN]: \"handshake/syn\",\n  [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_SYN_ACK]: \"handshake/syn-ack\",\n  [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_ACK]: \"handshake/ack\",\n  [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_RESPONSE]: \"channel/response\",\n  [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HEARTBEAT]: \"channel/heartbeat\",\n  [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_DISCONNECT]: \"channel/disconnect\",\n  \"visual-editing/focus\": \"overlay/focus\",\n  \"visual-editing/navigate\": \"overlay/navigate\",\n  \"visual-editing/toggle\": \"overlay/toggle\",\n  \"presentation/toggle-overlay\": \"presentation/toggleOverlay\"\n}, convertToComlinkEvent = (event) => {\n  const { data } = event;\n  return data && typeof data == \"object\" && \"domain\" in data && \"type\" in data && \"from\" in data && \"to\" in data && (data.domain === \"sanity/channels\" && (data.domain = _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.DOMAIN), data.to === \"overlays\" && (data.to = \"visual-editing\"), data.from === \"overlays\" && (data.from = \"visual-editing\"), data.channelId = data.connectionId, delete data.connectionId, data.type = channelsToComlinkMap[data.type] ?? data.type), event;\n}, convertToChannelsMessage = (comlinkMessage) => {\n  const { channelId, ...rest } = comlinkMessage, message = { ...rest, connectionId: channelId };\n  return message.domain === _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.DOMAIN && (message.domain = \"sanity/channels\"), message.to === \"visual-editing\" && (message.to = \"overlays\"), message.from === \"visual-editing\" && (message.from = \"overlays\"), message.type = comlinkToChannelsMap[message.type] ?? message.type, message.type === \"channel/response\" && message.responseTo && !message.data && (message.data = { responseTo: message.responseTo }), (message.type === \"handshake/syn\" || message.type === \"handshake/syn-ack\" || message.type === \"handshake/ack\") && (message.data = { id: message.connectionId }), message;\n}, sendAsChannelsMessage = ({ context }, params) => {\n  const { sources, targetOrigin } = context, message = convertToChannelsMessage(params.message);\n  sources.forEach((source) => {\n    source.postMessage(message, { targetOrigin });\n  });\n}, createCompatibilityActors = () => ({\n  listen: (0,_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.createListenLogic)(convertToComlinkEvent),\n  requestMachine: (0,_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.createRequestMachine)().provide({\n    actions: {\n      \"send message\": sendAsChannelsMessage\n    }\n  })\n});\nfunction PresentationComlink(props) {\n  const { draftModeEnabled, draftModePerspective } = props, router = (0,next_navigation_js__WEBPACK_IMPORTED_MODULE_0__.useRouter)(), handlePerspectiveChange = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_3__.useEffectEvent)(\n    (perspective, signal) => {\n      draftModeEnabled && perspective !== draftModePerspective && (0,_sanity_next_loader_server_actions__WEBPACK_IMPORTED_MODULE_4__.setPerspectiveCookie)(perspective).then(() => {\n        signal.aborted || router.refresh();\n      }).catch((reason) => console.error(\"Failed to set the preview perspective cookie\", reason));\n    }\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const comlink = (0,_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.createNode)(\n      {\n        name: \"loaders\",\n        connectTo: \"presentation\"\n      },\n      (0,_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.createNodeMachine)().provide({\n        actors: createCompatibilityActors()\n      })\n    );\n    let controller;\n    comlink.on(\"loader/perspective\", (data) => {\n      controller?.abort(), controller = new AbortController(), handlePerspectiveChange(data.perspective, controller.signal);\n    });\n    const stop = comlink.start();\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_5__.setComlink)(comlink), () => {\n      stop();\n    };\n  }, [handlePerspectiveChange]), null;\n}\nPresentationComlink.displayName = \"PresentationComlink\";\n\n//# sourceMappingURL=PresentationComlink.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L19jaHVua3MtZXMvUHJlc2VudGF0aW9uQ29tbGluay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTJOO0FBQ2pKO0FBQzNCO0FBQ2I7QUFDZ0I7QUFDUjtBQUMxQztBQUNBLG1CQUFtQiw4REFBaUI7QUFDcEMsdUJBQXVCLGtFQUFxQjtBQUM1QyxtQkFBbUIsOERBQWlCO0FBQ3BDLHNCQUFzQix5REFBWTtBQUNsQyx1QkFBdUIsMERBQWE7QUFDcEMsd0JBQXdCLDJEQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELEdBQUcsOERBQWlCO0FBQ3BCLEdBQUcsa0VBQXFCO0FBQ3hCLEdBQUcsOERBQWlCO0FBQ3BCLEdBQUcseURBQVk7QUFDZixHQUFHLDBEQUFhO0FBQ2hCLEdBQUcsMkRBQWM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsVUFBVSxPQUFPO0FBQ2pCLHlLQUF5SyxtREFBTTtBQUMvSyxDQUFDO0FBQ0QsVUFBVSxxQkFBcUIsOEJBQThCO0FBQzdELDRCQUE0QixtREFBTSw2VUFBNlUsZ0NBQWdDLHVJQUF1SSwwQkFBMEI7QUFDaGpCLENBQUMsNkJBQTZCLFNBQVM7QUFDdkMsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRCxHQUFHO0FBQ0gsQ0FBQztBQUNELFVBQVUsa0VBQWlCO0FBQzNCLGtCQUFrQixxRUFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLFVBQVUseUNBQXlDLGtCQUFrQiw2REFBUyw4QkFBOEIsZ0VBQWM7QUFDMUg7QUFDQSxrRUFBa0Usd0ZBQW9CO0FBQ3RGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTLGdEQUFTO0FBQ2xCLG9CQUFvQiwyREFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSxrRUFBaUI7QUFDdkI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXLHVEQUFVO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95Y19kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L19jaHVua3MtZXMvUHJlc2VudGF0aW9uQ29tbGluay5qcz8yNDE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUxpc3RlbkxvZ2ljLCBjcmVhdGVSZXF1ZXN0TWFjaGluZSwgRE9NQUlOLCBNU0dfSEFORFNIQUtFX1NZTiwgTVNHX0hBTkRTSEFLRV9TWU5fQUNLLCBNU0dfSEFORFNIQUtFX0FDSywgTVNHX1JFU1BPTlNFLCBNU0dfSEVBUlRCRUFULCBNU0dfRElTQ09OTkVDVCwgY3JlYXRlTm9kZSwgY3JlYXRlTm9kZU1hY2hpbmUgfSBmcm9tIFwiQHNhbml0eS9jb21saW5rXCI7XG5pbXBvcnQgeyBzZXRQZXJzcGVjdGl2ZUNvb2tpZSB9IGZyb20gXCJAc2FuaXR5L25leHQtbG9hZGVyL3NlcnZlci1hY3Rpb25zXCI7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tIFwibmV4dC9uYXZpZ2F0aW9uLmpzXCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUVmZmVjdEV2ZW50IH0gZnJvbSBcInVzZS1lZmZlY3QtZXZlbnRcIjtcbmltcG9ydCB7IHNldENvbWxpbmsgfSBmcm9tIFwiLi9jb250ZXh0LmpzXCI7XG5jb25zdCBjaGFubmVsc1RvQ29tbGlua01hcCA9IHtcbiAgXCJoYW5kc2hha2Uvc3luXCI6IE1TR19IQU5EU0hBS0VfU1lOLFxuICBcImhhbmRzaGFrZS9zeW4tYWNrXCI6IE1TR19IQU5EU0hBS0VfU1lOX0FDSyxcbiAgXCJoYW5kc2hha2UvYWNrXCI6IE1TR19IQU5EU0hBS0VfQUNLLFxuICBcImNoYW5uZWwvcmVzcG9uc2VcIjogTVNHX1JFU1BPTlNFLFxuICBcImNoYW5uZWwvaGVhcnRiZWF0XCI6IE1TR19IRUFSVEJFQVQsXG4gIFwiY2hhbm5lbC9kaXNjb25uZWN0XCI6IE1TR19ESVNDT05ORUNULFxuICBcIm92ZXJsYXkvZm9jdXNcIjogXCJ2aXN1YWwtZWRpdGluZy9mb2N1c1wiLFxuICBcIm92ZXJsYXkvbmF2aWdhdGVcIjogXCJ2aXN1YWwtZWRpdGluZy9uYXZpZ2F0ZVwiLFxuICBcIm92ZXJsYXkvdG9nZ2xlXCI6IFwidmlzdWFsLWVkaXRpbmcvdG9nZ2xlXCIsXG4gIFwicHJlc2VudGF0aW9uL3RvZ2dsZU92ZXJsYXlcIjogXCJwcmVzZW50YXRpb24vdG9nZ2xlLW92ZXJsYXlcIlxufSwgY29tbGlua1RvQ2hhbm5lbHNNYXAgPSB7XG4gIFtNU0dfSEFORFNIQUtFX1NZTl06IFwiaGFuZHNoYWtlL3N5blwiLFxuICBbTVNHX0hBTkRTSEFLRV9TWU5fQUNLXTogXCJoYW5kc2hha2Uvc3luLWFja1wiLFxuICBbTVNHX0hBTkRTSEFLRV9BQ0tdOiBcImhhbmRzaGFrZS9hY2tcIixcbiAgW01TR19SRVNQT05TRV06IFwiY2hhbm5lbC9yZXNwb25zZVwiLFxuICBbTVNHX0hFQVJUQkVBVF06IFwiY2hhbm5lbC9oZWFydGJlYXRcIixcbiAgW01TR19ESVNDT05ORUNUXTogXCJjaGFubmVsL2Rpc2Nvbm5lY3RcIixcbiAgXCJ2aXN1YWwtZWRpdGluZy9mb2N1c1wiOiBcIm92ZXJsYXkvZm9jdXNcIixcbiAgXCJ2aXN1YWwtZWRpdGluZy9uYXZpZ2F0ZVwiOiBcIm92ZXJsYXkvbmF2aWdhdGVcIixcbiAgXCJ2aXN1YWwtZWRpdGluZy90b2dnbGVcIjogXCJvdmVybGF5L3RvZ2dsZVwiLFxuICBcInByZXNlbnRhdGlvbi90b2dnbGUtb3ZlcmxheVwiOiBcInByZXNlbnRhdGlvbi90b2dnbGVPdmVybGF5XCJcbn0sIGNvbnZlcnRUb0NvbWxpbmtFdmVudCA9IChldmVudCkgPT4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGV2ZW50O1xuICByZXR1cm4gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PSBcIm9iamVjdFwiICYmIFwiZG9tYWluXCIgaW4gZGF0YSAmJiBcInR5cGVcIiBpbiBkYXRhICYmIFwiZnJvbVwiIGluIGRhdGEgJiYgXCJ0b1wiIGluIGRhdGEgJiYgKGRhdGEuZG9tYWluID09PSBcInNhbml0eS9jaGFubmVsc1wiICYmIChkYXRhLmRvbWFpbiA9IERPTUFJTiksIGRhdGEudG8gPT09IFwib3ZlcmxheXNcIiAmJiAoZGF0YS50byA9IFwidmlzdWFsLWVkaXRpbmdcIiksIGRhdGEuZnJvbSA9PT0gXCJvdmVybGF5c1wiICYmIChkYXRhLmZyb20gPSBcInZpc3VhbC1lZGl0aW5nXCIpLCBkYXRhLmNoYW5uZWxJZCA9IGRhdGEuY29ubmVjdGlvbklkLCBkZWxldGUgZGF0YS5jb25uZWN0aW9uSWQsIGRhdGEudHlwZSA9IGNoYW5uZWxzVG9Db21saW5rTWFwW2RhdGEudHlwZV0gPz8gZGF0YS50eXBlKSwgZXZlbnQ7XG59LCBjb252ZXJ0VG9DaGFubmVsc01lc3NhZ2UgPSAoY29tbGlua01lc3NhZ2UpID0+IHtcbiAgY29uc3QgeyBjaGFubmVsSWQsIC4uLnJlc3QgfSA9IGNvbWxpbmtNZXNzYWdlLCBtZXNzYWdlID0geyAuLi5yZXN0LCBjb25uZWN0aW9uSWQ6IGNoYW5uZWxJZCB9O1xuICByZXR1cm4gbWVzc2FnZS5kb21haW4gPT09IERPTUFJTiAmJiAobWVzc2FnZS5kb21haW4gPSBcInNhbml0eS9jaGFubmVsc1wiKSwgbWVzc2FnZS50byA9PT0gXCJ2aXN1YWwtZWRpdGluZ1wiICYmIChtZXNzYWdlLnRvID0gXCJvdmVybGF5c1wiKSwgbWVzc2FnZS5mcm9tID09PSBcInZpc3VhbC1lZGl0aW5nXCIgJiYgKG1lc3NhZ2UuZnJvbSA9IFwib3ZlcmxheXNcIiksIG1lc3NhZ2UudHlwZSA9IGNvbWxpbmtUb0NoYW5uZWxzTWFwW21lc3NhZ2UudHlwZV0gPz8gbWVzc2FnZS50eXBlLCBtZXNzYWdlLnR5cGUgPT09IFwiY2hhbm5lbC9yZXNwb25zZVwiICYmIG1lc3NhZ2UucmVzcG9uc2VUbyAmJiAhbWVzc2FnZS5kYXRhICYmIChtZXNzYWdlLmRhdGEgPSB7IHJlc3BvbnNlVG86IG1lc3NhZ2UucmVzcG9uc2VUbyB9KSwgKG1lc3NhZ2UudHlwZSA9PT0gXCJoYW5kc2hha2Uvc3luXCIgfHwgbWVzc2FnZS50eXBlID09PSBcImhhbmRzaGFrZS9zeW4tYWNrXCIgfHwgbWVzc2FnZS50eXBlID09PSBcImhhbmRzaGFrZS9hY2tcIikgJiYgKG1lc3NhZ2UuZGF0YSA9IHsgaWQ6IG1lc3NhZ2UuY29ubmVjdGlvbklkIH0pLCBtZXNzYWdlO1xufSwgc2VuZEFzQ2hhbm5lbHNNZXNzYWdlID0gKHsgY29udGV4dCB9LCBwYXJhbXMpID0+IHtcbiAgY29uc3QgeyBzb3VyY2VzLCB0YXJnZXRPcmlnaW4gfSA9IGNvbnRleHQsIG1lc3NhZ2UgPSBjb252ZXJ0VG9DaGFubmVsc01lc3NhZ2UocGFyYW1zLm1lc3NhZ2UpO1xuICBzb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgIHNvdXJjZS5wb3N0TWVzc2FnZShtZXNzYWdlLCB7IHRhcmdldE9yaWdpbiB9KTtcbiAgfSk7XG59LCBjcmVhdGVDb21wYXRpYmlsaXR5QWN0b3JzID0gKCkgPT4gKHtcbiAgbGlzdGVuOiBjcmVhdGVMaXN0ZW5Mb2dpYyhjb252ZXJ0VG9Db21saW5rRXZlbnQpLFxuICByZXF1ZXN0TWFjaGluZTogY3JlYXRlUmVxdWVzdE1hY2hpbmUoKS5wcm92aWRlKHtcbiAgICBhY3Rpb25zOiB7XG4gICAgICBcInNlbmQgbWVzc2FnZVwiOiBzZW5kQXNDaGFubmVsc01lc3NhZ2VcbiAgICB9XG4gIH0pXG59KTtcbmZ1bmN0aW9uIFByZXNlbnRhdGlvbkNvbWxpbmsocHJvcHMpIHtcbiAgY29uc3QgeyBkcmFmdE1vZGVFbmFibGVkLCBkcmFmdE1vZGVQZXJzcGVjdGl2ZSB9ID0gcHJvcHMsIHJvdXRlciA9IHVzZVJvdXRlcigpLCBoYW5kbGVQZXJzcGVjdGl2ZUNoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KFxuICAgIChwZXJzcGVjdGl2ZSwgc2lnbmFsKSA9PiB7XG4gICAgICBkcmFmdE1vZGVFbmFibGVkICYmIHBlcnNwZWN0aXZlICE9PSBkcmFmdE1vZGVQZXJzcGVjdGl2ZSAmJiBzZXRQZXJzcGVjdGl2ZUNvb2tpZShwZXJzcGVjdGl2ZSkudGhlbigoKSA9PiB7XG4gICAgICAgIHNpZ25hbC5hYm9ydGVkIHx8IHJvdXRlci5yZWZyZXNoKCk7XG4gICAgICB9KS5jYXRjaCgocmVhc29uKSA9PiBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNldCB0aGUgcHJldmlldyBwZXJzcGVjdGl2ZSBjb29raWVcIiwgcmVhc29uKSk7XG4gICAgfVxuICApO1xuICByZXR1cm4gdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb21saW5rID0gY3JlYXRlTm9kZShcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJsb2FkZXJzXCIsXG4gICAgICAgIGNvbm5lY3RUbzogXCJwcmVzZW50YXRpb25cIlxuICAgICAgfSxcbiAgICAgIGNyZWF0ZU5vZGVNYWNoaW5lKCkucHJvdmlkZSh7XG4gICAgICAgIGFjdG9yczogY3JlYXRlQ29tcGF0aWJpbGl0eUFjdG9ycygpXG4gICAgICB9KVxuICAgICk7XG4gICAgbGV0IGNvbnRyb2xsZXI7XG4gICAgY29tbGluay5vbihcImxvYWRlci9wZXJzcGVjdGl2ZVwiLCAoZGF0YSkgPT4ge1xuICAgICAgY29udHJvbGxlcj8uYWJvcnQoKSwgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKSwgaGFuZGxlUGVyc3BlY3RpdmVDaGFuZ2UoZGF0YS5wZXJzcGVjdGl2ZSwgY29udHJvbGxlci5zaWduYWwpO1xuICAgIH0pO1xuICAgIGNvbnN0IHN0b3AgPSBjb21saW5rLnN0YXJ0KCk7XG4gICAgcmV0dXJuIHNldENvbWxpbmsoY29tbGluayksICgpID0+IHtcbiAgICAgIHN0b3AoKTtcbiAgICB9O1xuICB9LCBbaGFuZGxlUGVyc3BlY3RpdmVDaGFuZ2VdKSwgbnVsbDtcbn1cblByZXNlbnRhdGlvbkNvbWxpbmsuZGlzcGxheU5hbWUgPSBcIlByZXNlbnRhdGlvbkNvbWxpbmtcIjtcbmV4cG9ydCB7XG4gIFByZXNlbnRhdGlvbkNvbWxpbmsgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByZXNlbnRhdGlvbkNvbWxpbmsuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/PresentationComlink.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/RefreshOnFocus.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/_chunks-es/RefreshOnFocus.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RefreshOnFocus)\n/* harmony export */ });\n/* harmony import */ var next_navigation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/navigation.js */ \"(ssr)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\n\nconst focusThrottleInterval = 5e3;\nfunction RefreshOnFocus() {\n  const router = (0,next_navigation_js__WEBPACK_IMPORTED_MODULE_0__.useRouter)();\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const controller = new AbortController();\n    let nextFocusRevalidatedAt = 0;\n    const callback = () => {\n      const now = Date.now();\n      now > nextFocusRevalidatedAt && document.visibilityState !== \"hidden\" && (router.refresh(), nextFocusRevalidatedAt = now + focusThrottleInterval);\n    }, { signal } = controller;\n    return document.addEventListener(\"visibilitychange\", callback, { passive: !0, signal }), window.addEventListener(\"focus\", callback, { passive: !0, signal }), () => controller.abort();\n  }, [router]), null;\n}\nRefreshOnFocus.displayName = \"RefreshOnFocus\";\n\n//# sourceMappingURL=RefreshOnFocus.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L19jaHVua3MtZXMvUmVmcmVzaE9uRm9jdXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStDO0FBQ2I7QUFDbEM7QUFDQTtBQUNBLGlCQUFpQiw2REFBUztBQUMxQixTQUFTLGdEQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUksU0FBUztBQUNsQixxRUFBcUUscUJBQXFCLGdEQUFnRCxxQkFBcUI7QUFDL0osR0FBRztBQUNIO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWNfZGlyZWN0b3J5Ly4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvbmV4dC1sb2FkZXIvZGlzdC9fY2h1bmtzLWVzL1JlZnJlc2hPbkZvY3VzLmpzPzY0YjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvbi5qc1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5jb25zdCBmb2N1c1Rocm90dGxlSW50ZXJ2YWwgPSA1ZTM7XG5mdW5jdGlvbiBSZWZyZXNoT25Gb2N1cygpIHtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG4gIHJldHVybiB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IG5leHRGb2N1c1JldmFsaWRhdGVkQXQgPSAwO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIG5vdyA+IG5leHRGb2N1c1JldmFsaWRhdGVkQXQgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiICYmIChyb3V0ZXIucmVmcmVzaCgpLCBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ID0gbm93ICsgZm9jdXNUaHJvdHRsZUludGVydmFsKTtcbiAgICB9LCB7IHNpZ25hbCB9ID0gY29udHJvbGxlcjtcbiAgICByZXR1cm4gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogITAsIHNpZ25hbCB9KSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBjYWxsYmFjaywgeyBwYXNzaXZlOiAhMCwgc2lnbmFsIH0pLCAoKSA9PiBjb250cm9sbGVyLmFib3J0KCk7XG4gIH0sIFtyb3V0ZXJdKSwgbnVsbDtcbn1cblJlZnJlc2hPbkZvY3VzLmRpc3BsYXlOYW1lID0gXCJSZWZyZXNoT25Gb2N1c1wiO1xuZXhwb3J0IHtcbiAgUmVmcmVzaE9uRm9jdXMgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZnJlc2hPbkZvY3VzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/RefreshOnFocus.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/RefreshOnMount.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/_chunks-es/RefreshOnMount.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RefreshOnMount)\n/* harmony export */ });\n/* harmony import */ var next_navigation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/navigation.js */ \"(ssr)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\n\nfunction RefreshOnMount() {\n  const router = (0,next_navigation_js__WEBPACK_IMPORTED_MODULE_0__.useRouter)(), [mounted, mount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useReducer)(() => !0, !1);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    mounted || (mount(), router.refresh());\n  }, [mounted, router]), null;\n}\nRefreshOnMount.displayName = \"RefreshOnMount\";\n\n//# sourceMappingURL=RefreshOnMount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L19jaHVua3MtZXMvUmVmcmVzaE9uTW91bnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStDO0FBQ0Q7QUFDOUM7QUFDQSxpQkFBaUIsNkRBQVMsdUJBQXVCLGlEQUFVO0FBQzNELFNBQVMsZ0RBQVM7QUFDbEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95Y19kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L19jaHVua3MtZXMvUmVmcmVzaE9uTW91bnQuanM/MjJhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tIFwibmV4dC9uYXZpZ2F0aW9uLmpzXCI7XG5pbXBvcnQgeyB1c2VSZWR1Y2VyLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIFJlZnJlc2hPbk1vdW50KCkge1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKSwgW21vdW50ZWQsIG1vdW50XSA9IHVzZVJlZHVjZXIoKCkgPT4gITAsICExKTtcbiAgcmV0dXJuIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbW91bnRlZCB8fCAobW91bnQoKSwgcm91dGVyLnJlZnJlc2goKSk7XG4gIH0sIFttb3VudGVkLCByb3V0ZXJdKSwgbnVsbDtcbn1cblJlZnJlc2hPbk1vdW50LmRpc3BsYXlOYW1lID0gXCJSZWZyZXNoT25Nb3VudFwiO1xuZXhwb3J0IHtcbiAgUmVmcmVzaE9uTW91bnQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZnJlc2hPbk1vdW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/RefreshOnMount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/RefreshOnReconnect.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/_chunks-es/RefreshOnReconnect.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RefreshOnReconnect)\n/* harmony export */ });\n/* harmony import */ var next_navigation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/navigation.js */ \"(ssr)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\n\nfunction RefreshOnReconnect() {\n  const router = (0,next_navigation_js__WEBPACK_IMPORTED_MODULE_0__.useRouter)();\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const controller = new AbortController(), { signal } = controller;\n    return window.addEventListener(\"online\", () => router.refresh(), { passive: !0, signal }), () => controller.abort();\n  }, [router]), null;\n}\nRefreshOnReconnect.displayName = \"RefreshOnReconnect\";\n\n//# sourceMappingURL=RefreshOnReconnect.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L19jaHVua3MtZXMvUmVmcmVzaE9uUmVjb25uZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQztBQUNiO0FBQ2xDO0FBQ0EsaUJBQWlCLDZEQUFTO0FBQzFCLFNBQVMsZ0RBQVM7QUFDbEIsZ0RBQWdELFNBQVM7QUFDekQsdUVBQXVFLHFCQUFxQjtBQUM1RixHQUFHO0FBQ0g7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95Y19kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L19jaHVua3MtZXMvUmVmcmVzaE9uUmVjb25uZWN0LmpzP2VhYzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvbi5qc1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBSZWZyZXNoT25SZWNvbm5lY3QoKSB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICByZXR1cm4gdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpLCB7IHNpZ25hbCB9ID0gY29udHJvbGxlcjtcbiAgICByZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgKCkgPT4gcm91dGVyLnJlZnJlc2goKSwgeyBwYXNzaXZlOiAhMCwgc2lnbmFsIH0pLCAoKSA9PiBjb250cm9sbGVyLmFib3J0KCk7XG4gIH0sIFtyb3V0ZXJdKSwgbnVsbDtcbn1cblJlZnJlc2hPblJlY29ubmVjdC5kaXNwbGF5TmFtZSA9IFwiUmVmcmVzaE9uUmVjb25uZWN0XCI7XG5leHBvcnQge1xuICBSZWZyZXNoT25SZWNvbm5lY3QgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZnJlc2hPblJlY29ubmVjdC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/RefreshOnReconnect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/SanityLiveStream.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/_chunks-es/SanityLiveStream.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("var react__WEBPACK_IMPORTED_MODULE_1___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SanityLiveStream)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _sanity_client_stega__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sanity/client/stega */ \"(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_effect_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! use-effect-event */ \"(ssr)/./node_modules/use-effect-event/dist/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/context.js\");\n\n\n\n\n\n\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x.default : x;\n}\nvar fastDeepEqual, hasRequiredFastDeepEqual;\nfunction requireFastDeepEqual() {\n  return hasRequiredFastDeepEqual || (hasRequiredFastDeepEqual = 1, fastDeepEqual = function equal(a, b) {\n    if (a === b) return !0;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n      if (a.constructor !== b.constructor) return !1;\n      var length, i, keys;\n      if (Array.isArray(a)) {\n        if (length = a.length, length != b.length) return !1;\n        for (i = length; i-- !== 0; )\n          if (!equal(a[i], b[i])) return !1;\n        return !0;\n      }\n      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n      if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n      if (keys = Object.keys(a), length = keys.length, length !== Object.keys(b).length) return !1;\n      for (i = length; i-- !== 0; )\n        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return !1;\n      for (i = length; i-- !== 0; ) {\n        var key = keys[i];\n        if (!equal(a[key], b[key])) return !1;\n      }\n      return !0;\n    }\n    return a !== a && b !== b;\n  }), fastDeepEqual;\n}\nvar fastDeepEqualExports = requireFastDeepEqual(), isEqual = /* @__PURE__ */ getDefaultExportFromCjs(fastDeepEqualExports);\nconst use = \"use\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_1__, 2))) ? (\n  // @ts-expect-error this is fine\n  react__WEBPACK_IMPORTED_MODULE_1__.use\n) : () => {\n  throw new TypeError(\"SanityLiveStream requires a React version with React.use()\");\n}, LISTEN_HEARTBEAT_INTERVAL = 1e3;\nfunction SanityLiveStream(props) {\n  const { query, dataset, params = {}, perspective, projectId, stega } = props, subscribe = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((listener) => (_context_js__WEBPACK_IMPORTED_MODULE_2__.comlinkListeners.add(listener), () => _context_js__WEBPACK_IMPORTED_MODULE_2__.comlinkListeners.delete(listener)), []), comlink$1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(\n    subscribe,\n    () => _context_js__WEBPACK_IMPORTED_MODULE_2__.comlink,\n    () => null\n  ), [children, setChildren] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(void 0), handleQueryHeartbeat = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_3__.useEffectEvent)((comlink2) => {\n    comlink2.post(\"loader/query-listen\", {\n      projectId,\n      dataset,\n      perspective,\n      query,\n      params,\n      heartbeat: LISTEN_HEARTBEAT_INTERVAL\n    });\n  }), handleQueryChange = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_3__.useEffectEvent)(\n    (event) => {\n      if (isEqual(\n        {\n          projectId,\n          dataset,\n          query,\n          params\n        },\n        {\n          projectId: event.projectId,\n          dataset: event.dataset,\n          query: event.query,\n          params: event.params\n        }\n      )) {\n        const { result, resultSourceMap, tags } = event, data = stega ? (0,_sanity_client_stega__WEBPACK_IMPORTED_MODULE_4__.stegaEncodeSourceMap)(result, resultSourceMap, { enabled: !0, studioUrl: \"/\" }) : result;\n        console.groupCollapsed(\"rendering with server action\"), props.children({\n          data,\n          sourceMap: resultSourceMap,\n          tags: tags || []\n        }).then(\n          (children2) => {\n            console.log(\"setChildren(children)\"), setChildren(children2);\n          },\n          (reason) => {\n            console.error(\"rendering with server action: render children error\", reason);\n          }\n        ).finally(() => console.groupEnd());\n      }\n    }\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!comlink$1) return;\n    const unsubscribe = comlink$1.on(\"loader/query-change\", handleQueryChange), interval = setInterval(() => handleQueryHeartbeat(comlink$1), LISTEN_HEARTBEAT_INTERVAL);\n    return () => {\n      clearInterval(interval), unsubscribe();\n    };\n  }, [comlink$1, handleQueryChange, handleQueryHeartbeat]), !comlink$1 || children === void 0 ? use(props.initial) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children });\n}\nSanityLiveStream.displayName = \"SanityLiveStream\";\n\n//# sourceMappingURL=SanityLiveStream.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L19jaHVua3MtZXMvU2FuaXR5TGl2ZVN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWtEO0FBQ1U7QUFDN0I7QUFDZ0Q7QUFDN0I7QUFDTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZLGtNQUFjO0FBQzFCO0FBQ0EsRUFBRSxzQ0FBUztBQUNYO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxVQUFVLDJCQUEyQixrQ0FBa0MscUJBQXFCLGtEQUFXLGdCQUFnQix5REFBZ0Isc0JBQXNCLHlEQUFnQixxQ0FBcUMsMkRBQW9CO0FBQ3RPO0FBQ0EsVUFBVSxnREFBTztBQUNqQjtBQUNBLCtCQUErQiwrQ0FBUSxpQ0FBaUMsZ0VBQWM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyx1QkFBdUIsZ0VBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDLHdCQUF3QiwwRUFBb0IsNEJBQTRCLDZCQUE2QjtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnREFBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxrSUFBa0ksc0RBQUcsQ0FBQyx1REFBUSxJQUFJLFVBQVU7QUFDL0o7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95Y19kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L19jaHVua3MtZXMvU2FuaXR5TGl2ZVN0cmVhbS5qcz9hMDM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCwgRnJhZ21lbnQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IHN0ZWdhRW5jb2RlU291cmNlTWFwIH0gZnJvbSBcIkBzYW5pdHkvY2xpZW50L3N0ZWdhXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTeW5jRXh0ZXJuYWxTdG9yZSwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0RXZlbnQgfSBmcm9tIFwidXNlLWVmZmVjdC1ldmVudFwiO1xuaW1wb3J0IHsgY29tbGlua0xpc3RlbmVycywgY29tbGluayB9IGZyb20gXCIuL2NvbnRleHQuanNcIjtcbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHgpIHtcbiAgcmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCBcImRlZmF1bHRcIikgPyB4LmRlZmF1bHQgOiB4O1xufVxudmFyIGZhc3REZWVwRXF1YWwsIGhhc1JlcXVpcmVkRmFzdERlZXBFcXVhbDtcbmZ1bmN0aW9uIHJlcXVpcmVGYXN0RGVlcEVxdWFsKCkge1xuICByZXR1cm4gaGFzUmVxdWlyZWRGYXN0RGVlcEVxdWFsIHx8IChoYXNSZXF1aXJlZEZhc3REZWVwRXF1YWwgPSAxLCBmYXN0RGVlcEVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gITA7XG4gICAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBiID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gITE7XG4gICAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9IGEubGVuZ3RoLCBsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7IClcbiAgICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gITE7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoa2V5cyA9IE9iamVjdC5rZXlzKGEpLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwgbGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOyApXG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gITE7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDsgKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xuICB9KSwgZmFzdERlZXBFcXVhbDtcbn1cbnZhciBmYXN0RGVlcEVxdWFsRXhwb3J0cyA9IHJlcXVpcmVGYXN0RGVlcEVxdWFsKCksIGlzRXF1YWwgPSAvKiBAX19QVVJFX18gKi8gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZmFzdERlZXBFcXVhbEV4cG9ydHMpO1xuY29uc3QgdXNlID0gXCJ1c2VcIiBpbiBSZWFjdCA/IChcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIGZpbmVcbiAgUmVhY3QudXNlXG4pIDogKCkgPT4ge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU2FuaXR5TGl2ZVN0cmVhbSByZXF1aXJlcyBhIFJlYWN0IHZlcnNpb24gd2l0aCBSZWFjdC51c2UoKVwiKTtcbn0sIExJU1RFTl9IRUFSVEJFQVRfSU5URVJWQUwgPSAxZTM7XG5mdW5jdGlvbiBTYW5pdHlMaXZlU3RyZWFtKHByb3BzKSB7XG4gIGNvbnN0IHsgcXVlcnksIGRhdGFzZXQsIHBhcmFtcyA9IHt9LCBwZXJzcGVjdGl2ZSwgcHJvamVjdElkLCBzdGVnYSB9ID0gcHJvcHMsIHN1YnNjcmliZSA9IHVzZUNhbGxiYWNrKChsaXN0ZW5lcikgPT4gKGNvbWxpbmtMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKSwgKCkgPT4gY29tbGlua0xpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpKSwgW10pLCBjb21saW5rJDEgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICBzdWJzY3JpYmUsXG4gICAgKCkgPT4gY29tbGluayxcbiAgICAoKSA9PiBudWxsXG4gICksIFtjaGlsZHJlbiwgc2V0Q2hpbGRyZW5dID0gdXNlU3RhdGUodm9pZCAwKSwgaGFuZGxlUXVlcnlIZWFydGJlYXQgPSB1c2VFZmZlY3RFdmVudCgoY29tbGluazIpID0+IHtcbiAgICBjb21saW5rMi5wb3N0KFwibG9hZGVyL3F1ZXJ5LWxpc3RlblwiLCB7XG4gICAgICBwcm9qZWN0SWQsXG4gICAgICBkYXRhc2V0LFxuICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICBxdWVyeSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIGhlYXJ0YmVhdDogTElTVEVOX0hFQVJUQkVBVF9JTlRFUlZBTFxuICAgIH0pO1xuICB9KSwgaGFuZGxlUXVlcnlDaGFuZ2UgPSB1c2VFZmZlY3RFdmVudChcbiAgICAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChpc0VxdWFsKFxuICAgICAgICB7XG4gICAgICAgICAgcHJvamVjdElkLFxuICAgICAgICAgIGRhdGFzZXQsXG4gICAgICAgICAgcXVlcnksXG4gICAgICAgICAgcGFyYW1zXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwcm9qZWN0SWQ6IGV2ZW50LnByb2plY3RJZCxcbiAgICAgICAgICBkYXRhc2V0OiBldmVudC5kYXRhc2V0LFxuICAgICAgICAgIHF1ZXJ5OiBldmVudC5xdWVyeSxcbiAgICAgICAgICBwYXJhbXM6IGV2ZW50LnBhcmFtc1xuICAgICAgICB9XG4gICAgICApKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIHRhZ3MgfSA9IGV2ZW50LCBkYXRhID0gc3RlZ2EgPyBzdGVnYUVuY29kZVNvdXJjZU1hcChyZXN1bHQsIHJlc3VsdFNvdXJjZU1hcCwgeyBlbmFibGVkOiAhMCwgc3R1ZGlvVXJsOiBcIi9cIiB9KSA6IHJlc3VsdDtcbiAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcInJlbmRlcmluZyB3aXRoIHNlcnZlciBhY3Rpb25cIiksIHByb3BzLmNoaWxkcmVuKHtcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHNvdXJjZU1hcDogcmVzdWx0U291cmNlTWFwLFxuICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW11cbiAgICAgICAgfSkudGhlbihcbiAgICAgICAgICAoY2hpbGRyZW4yKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInNldENoaWxkcmVuKGNoaWxkcmVuKVwiKSwgc2V0Q2hpbGRyZW4oY2hpbGRyZW4yKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChyZWFzb24pID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJyZW5kZXJpbmcgd2l0aCBzZXJ2ZXIgYWN0aW9uOiByZW5kZXIgY2hpbGRyZW4gZXJyb3JcIiwgcmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgICkuZmluYWxseSgoKSA9PiBjb25zb2xlLmdyb3VwRW5kKCkpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjb21saW5rJDEpIHJldHVybjtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IGNvbWxpbmskMS5vbihcImxvYWRlci9xdWVyeS1jaGFuZ2VcIiwgaGFuZGxlUXVlcnlDaGFuZ2UpLCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IGhhbmRsZVF1ZXJ5SGVhcnRiZWF0KGNvbWxpbmskMSksIExJU1RFTl9IRUFSVEJFQVRfSU5URVJWQUwpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKSwgdW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCBbY29tbGluayQxLCBoYW5kbGVRdWVyeUNoYW5nZSwgaGFuZGxlUXVlcnlIZWFydGJlYXRdKSwgIWNvbWxpbmskMSB8fCBjaGlsZHJlbiA9PT0gdm9pZCAwID8gdXNlKHByb3BzLmluaXRpYWwpIDogLyogQF9fUFVSRV9fICovIGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbiB9KTtcbn1cblNhbml0eUxpdmVTdHJlYW0uZGlzcGxheU5hbWUgPSBcIlNhbml0eUxpdmVTdHJlYW1cIjtcbmV4cG9ydCB7XG4gIFNhbml0eUxpdmVTdHJlYW0gYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNhbml0eUxpdmVTdHJlYW0uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/SanityLiveStream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/context.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/_chunks-es/context.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   comlink: () => (/* binding */ comlink),\n/* harmony export */   comlinkListeners: () => (/* binding */ comlinkListeners),\n/* harmony export */   environment: () => (/* binding */ environment),\n/* harmony export */   environmentListeners: () => (/* binding */ environmentListeners),\n/* harmony export */   perspective: () => (/* binding */ perspective),\n/* harmony export */   perspectiveListeners: () => (/* binding */ perspectiveListeners),\n/* harmony export */   setComlink: () => (/* binding */ setComlink),\n/* harmony export */   setEnvironment: () => (/* binding */ setEnvironment),\n/* harmony export */   setPerspective: () => (/* binding */ setPerspective)\n/* harmony export */ });\nconst perspectiveListeners = /* @__PURE__ */ new Set();\nlet perspective = \"checking\";\nfunction setPerspective(nextPerspective) {\n  if (perspective !== nextPerspective) {\n    perspective = nextPerspective;\n    for (const onPerspectiveChange of perspectiveListeners)\n      onPerspectiveChange();\n  }\n}\nconst environmentListeners = /* @__PURE__ */ new Set();\nlet environment = \"checking\";\nfunction setEnvironment(nextEnvironment) {\n  environment = nextEnvironment;\n  for (const onEnvironmentChange of environmentListeners)\n    onEnvironmentChange();\n}\nconst comlinkListeners = /* @__PURE__ */ new Set();\nlet comlink = null;\nfunction setComlink(nextComlink) {\n  comlink = nextComlink;\n  for (const onComlinkChange of comlinkListeners)\n    onComlinkChange();\n}\n\n//# sourceMappingURL=context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L19jaHVua3MtZXMvY29udGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3ljX2RpcmVjdG9yeS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL2Rpc3QvX2NodW5rcy1lcy9jb250ZXh0LmpzP2RhZjkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGVyc3BlY3RpdmVMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xubGV0IHBlcnNwZWN0aXZlID0gXCJjaGVja2luZ1wiO1xuZnVuY3Rpb24gc2V0UGVyc3BlY3RpdmUobmV4dFBlcnNwZWN0aXZlKSB7XG4gIGlmIChwZXJzcGVjdGl2ZSAhPT0gbmV4dFBlcnNwZWN0aXZlKSB7XG4gICAgcGVyc3BlY3RpdmUgPSBuZXh0UGVyc3BlY3RpdmU7XG4gICAgZm9yIChjb25zdCBvblBlcnNwZWN0aXZlQ2hhbmdlIG9mIHBlcnNwZWN0aXZlTGlzdGVuZXJzKVxuICAgICAgb25QZXJzcGVjdGl2ZUNoYW5nZSgpO1xuICB9XG59XG5jb25zdCBlbnZpcm9ubWVudExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5sZXQgZW52aXJvbm1lbnQgPSBcImNoZWNraW5nXCI7XG5mdW5jdGlvbiBzZXRFbnZpcm9ubWVudChuZXh0RW52aXJvbm1lbnQpIHtcbiAgZW52aXJvbm1lbnQgPSBuZXh0RW52aXJvbm1lbnQ7XG4gIGZvciAoY29uc3Qgb25FbnZpcm9ubWVudENoYW5nZSBvZiBlbnZpcm9ubWVudExpc3RlbmVycylcbiAgICBvbkVudmlyb25tZW50Q2hhbmdlKCk7XG59XG5jb25zdCBjb21saW5rTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmxldCBjb21saW5rID0gbnVsbDtcbmZ1bmN0aW9uIHNldENvbWxpbmsobmV4dENvbWxpbmspIHtcbiAgY29tbGluayA9IG5leHRDb21saW5rO1xuICBmb3IgKGNvbnN0IG9uQ29tbGlua0NoYW5nZSBvZiBjb21saW5rTGlzdGVuZXJzKVxuICAgIG9uQ29tbGlua0NoYW5nZSgpO1xufVxuZXhwb3J0IHtcbiAgY29tbGluayxcbiAgY29tbGlua0xpc3RlbmVycyxcbiAgZW52aXJvbm1lbnQsXG4gIGVudmlyb25tZW50TGlzdGVuZXJzLFxuICBwZXJzcGVjdGl2ZSxcbiAgcGVyc3BlY3RpdmVMaXN0ZW5lcnMsXG4gIHNldENvbWxpbmssXG4gIHNldEVudmlyb25tZW50LFxuICBzZXRQZXJzcGVjdGl2ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRleHQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/context.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/isCorsOriginError.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/_chunks-es/isCorsOriginError.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isCorsOriginError: () => (/* binding */ isCorsOriginError)\n/* harmony export */ });\n/* harmony import */ var _sanity_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/client */ \"(ssr)/./node_modules/@sanity/client/dist/index.js\");\n\nfunction isCorsOriginError(error) {\n  return error instanceof _sanity_client__WEBPACK_IMPORTED_MODULE_0__.CorsOriginError;\n}\n\n//# sourceMappingURL=isCorsOriginError.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L19jaHVua3MtZXMvaXNDb3JzT3JpZ2luRXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUQ7QUFDakQ7QUFDQSwwQkFBMEIsMkRBQWU7QUFDekM7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWNfZGlyZWN0b3J5Ly4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvbmV4dC1sb2FkZXIvZGlzdC9fY2h1bmtzLWVzL2lzQ29yc09yaWdpbkVycm9yLmpzP2JjMjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29yc09yaWdpbkVycm9yIH0gZnJvbSBcIkBzYW5pdHkvY2xpZW50XCI7XG5mdW5jdGlvbiBpc0NvcnNPcmlnaW5FcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBDb3JzT3JpZ2luRXJyb3I7XG59XG5leHBvcnQge1xuICBpc0NvcnNPcmlnaW5FcnJvclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQ29yc09yaWdpbkVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/isCorsOriginError.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/next-loader/dist/client-components/live-stream.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/client-components/live-stream.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SanityLiveStreamLazyClientComponent)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dynamic */ \"(ssr)/./node_modules/next/dist/api/app-dynamic.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nconst SanityLiveStreamClientComponent = (0,next_dynamic__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(()=>__webpack_require__.e(/*! import() */ \"vendor-chunks/@sanity\").then(__webpack_require__.bind(__webpack_require__, /*! ../_chunks-es/SanityLiveStream.js */ \"(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/SanityLiveStream.js\")), {\n    loadableGenerated: {\n        modules: [\n            \"node_modules/@sanity/next-loader/dist/client-components/live-stream.js -> \" + \"../_chunks-es/SanityLiveStream.js\"\n        ]\n    },\n    ssr: !1\n});\nfunction SanityLiveStreamLazyClientComponent(props) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SanityLiveStreamClientComponent, {\n        ...props\n    });\n}\n //# sourceMappingURL=live-stream.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L2NsaWVudC1jb21wb25lbnRzL2xpdmUtc3RyZWFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBU0EsTUFBTSxrQ0FBa0Msd0RBQU8sQ0FBQyxJQUFNLDJPQUE0QixFQUFFOzs7Ozs7SUFBQyxLQUFLOztBQUVuRixTQUFTLG9DQUFvQyxPQUErQztJQUMxRiw4RUFBQyxpQ0FBaUM7UUFBQSxHQUFHO0lBQU87QUFDckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95Y19kaXJlY3RvcnkvLi4vLi4vc3JjL2NsaWVudC1jb21wb25lbnRzL2xpdmUtc3RyZWFtL1Nhbml0eUxpdmVTdHJlYW1MYXp5LnRzeD81YmVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBmaWxlIHdvcmtzIGFyb3VuZCBhIG5ldyByZXN0cmljdGlvbiBpbiBOZXh0IHYxNSB3aGVyZSBzZXJ2ZXIgY29tcG9uZW50cyBhcmUgbm90IGFsbG93ZWRcbiAqIHRvIHVzZSBkeW5hbWljKCgpID0+IGltcG9ydCgnLi4uKSwge3NzcjogZmFsc2V9KVxuICogb25seSBDbGllbnQgQ29tcG9uZW50cyBjYW4gc2V0IHNzcjogZmFsc2UuXG4gKi9cblxuaW1wb3J0IGR5bmFtaWMgZnJvbSAnbmV4dC9keW5hbWljJ1xuaW1wb3J0IHR5cGUge1Nhbml0eUxpdmVTdHJlYW1Qcm9wc30gZnJvbSAnLi9TYW5pdHlMaXZlU3RyZWFtJ1xuXG5jb25zdCBTYW5pdHlMaXZlU3RyZWFtQ2xpZW50Q29tcG9uZW50ID0gZHluYW1pYygoKSA9PiBpbXBvcnQoJy4vU2FuaXR5TGl2ZVN0cmVhbScpLCB7c3NyOiBmYWxzZX0pXG5cbmV4cG9ydCBmdW5jdGlvbiBTYW5pdHlMaXZlU3RyZWFtTGF6eUNsaWVudENvbXBvbmVudChwcm9wczogU2FuaXR5TGl2ZVN0cmVhbVByb3BzKTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgcmV0dXJuIDxTYW5pdHlMaXZlU3RyZWFtQ2xpZW50Q29tcG9uZW50IHsuLi5wcm9wc30gLz5cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/next-loader/dist/client-components/live-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/next-loader/dist/client-components/live.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/client-components/live.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SanityLive)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _sanity_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sanity/client */ \"(ssr)/./node_modules/@sanity/client/dist/index.js\");\n/* harmony import */ var _sanity_next_loader_server_actions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sanity/next-loader/server-actions */ \"(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-server-reference-proxy-loader.js?id=d0e679eb3bed5f47eac9728adb520d88c20f2294&name=revalidateSyncTags!\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dynamic */ \"(ssr)/./node_modules/next/dist/api/app-dynamic.js\");\n/* harmony import */ var next_navigation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation.js */ \"(ssr)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_effect_event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! use-effect-event */ \"(ssr)/./node_modules/use-effect-event/dist/index.js\");\n/* harmony import */ var _chunks_es_context_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../_chunks-es/context.js */ \"(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/context.js\");\n/* harmony import */ var _chunks_es_isCorsOriginError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../_chunks-es/isCorsOriginError.js */ \"(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/isCorsOriginError.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\n\n\n\n\n\nconst PresentationComlink = (0,next_dynamic__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(()=>Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@sanity\"), __webpack_require__.e(\"vendor-chunks/rxjs\"), __webpack_require__.e(\"vendor-chunks/xstate\"), __webpack_require__.e(\"_ssr_node_modules_next_dist_build_webpack_loaders_next-flight-server-reference-proxy-loader_j-f01896\")]).then(__webpack_require__.bind(__webpack_require__, /*! ../_chunks-es/PresentationComlink.js */ \"(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/PresentationComlink.js\")), {\n    loadableGenerated: {\n        modules: [\n            \"node_modules/@sanity/next-loader/dist/client-components/live.js -> \" + \"../_chunks-es/PresentationComlink.js\"\n        ]\n    },\n    ssr: !1\n}), RefreshOnMount = (0,next_dynamic__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(()=>__webpack_require__.e(/*! import() */ \"vendor-chunks/@sanity\").then(__webpack_require__.bind(__webpack_require__, /*! ../_chunks-es/RefreshOnMount.js */ \"(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/RefreshOnMount.js\")), {\n    loadableGenerated: {\n        modules: [\n            \"node_modules/@sanity/next-loader/dist/client-components/live.js -> \" + \"../_chunks-es/RefreshOnMount.js\"\n        ]\n    },\n    ssr: !1\n}), RefreshOnFocus = (0,next_dynamic__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(()=>__webpack_require__.e(/*! import() */ \"vendor-chunks/@sanity\").then(__webpack_require__.bind(__webpack_require__, /*! ../_chunks-es/RefreshOnFocus.js */ \"(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/RefreshOnFocus.js\")), {\n    loadableGenerated: {\n        modules: [\n            \"node_modules/@sanity/next-loader/dist/client-components/live.js -> \" + \"../_chunks-es/RefreshOnFocus.js\"\n        ]\n    },\n    ssr: !1\n}), RefreshOnReconnect = (0,next_dynamic__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(()=>__webpack_require__.e(/*! import() */ \"vendor-chunks/@sanity\").then(__webpack_require__.bind(__webpack_require__, /*! ../_chunks-es/RefreshOnReconnect.js */ \"(ssr)/./node_modules/@sanity/next-loader/dist/_chunks-es/RefreshOnReconnect.js\")), {\n    loadableGenerated: {\n        modules: [\n            \"node_modules/@sanity/next-loader/dist/client-components/live.js -> \" + \"../_chunks-es/RefreshOnReconnect.js\"\n        ]\n    },\n    ssr: !1\n}), isMaybePreviewIframe = ()=>window !== window.parent, isMaybePreviewWindow = ()=>!!window.opener, isMaybePresentation = ()=>isMaybePreviewIframe() || isMaybePreviewWindow(), handleError = (error)=>{\n    (0,_chunks_es_isCorsOriginError_js__WEBPACK_IMPORTED_MODULE_4__.isCorsOriginError)(error) ? console.warn(`Sanity Live is unable to connect to the Sanity API as the current origin - ${window.origin} - is not in the list of allowed CORS origins for this Sanity Project.`, error.addOriginUrl && \"Add it here:\", error.addOriginUrl?.toString()) : console.error(error);\n};\nfunction SanityLive(props) {\n    const { projectId, dataset, apiHost, apiVersion, useProjectHostname, token, requestTagPrefix, // handleDraftModeAction,\n    draftModeEnabled, draftModePerspective, refreshOnMount = !1, refreshOnFocus = draftModeEnabled ? !1 :  true ? !0 : 0, refreshOnReconnect = !0, tag, onError = handleError } = props, client = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>(0,_sanity_client__WEBPACK_IMPORTED_MODULE_5__.createClient)({\n            projectId,\n            dataset,\n            apiHost,\n            apiVersion,\n            useProjectHostname,\n            ignoreBrowserTokenWarning: !0,\n            token,\n            useCdn: !1,\n            requestTagPrefix\n        }), [\n        apiHost,\n        apiVersion,\n        dataset,\n        projectId,\n        requestTagPrefix,\n        token,\n        useProjectHostname\n    ]), router = (0,next_navigation_js__WEBPACK_IMPORTED_MODULE_2__.useRouter)(), handleLiveEvent = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)((event)=>{\n         true && event.type === \"welcome\" ? console.info(\"Sanity is live with\", token ? \"automatic revalidation for draft content changes as well as published content\" : draftModeEnabled ? \"automatic revalidation for only published content. Provide a `browserToken` to `defineLive` to support draft content outside of Presentation Tool.\" : \"automatic revalidation of published content\") : event.type === \"message\" ? (0,_sanity_next_loader_server_actions__WEBPACK_IMPORTED_MODULE_7__.revalidateSyncTags)(event.tags) : event.type === \"restart\" && router.refresh();\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        const subscription = client.live.events({\n            includeDrafts: !!token,\n            tag\n        }).subscribe({\n            next: (event)=>{\n                (event.type === \"message\" || event.type === \"restart\" || event.type === \"welcome\") && handleLiveEvent(event);\n            },\n            error: (err)=>{\n                onError(err);\n            }\n        });\n        return ()=>subscription.unsubscribe();\n    }, [\n        client.live,\n        handleLiveEvent,\n        onError,\n        tag,\n        token\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        draftModeEnabled && draftModePerspective ? (0,_chunks_es_context_js__WEBPACK_IMPORTED_MODULE_8__.setPerspective)(draftModePerspective) : (0,_chunks_es_context_js__WEBPACK_IMPORTED_MODULE_8__.setPerspective)(\"unknown\");\n    }, [\n        draftModeEnabled,\n        draftModePerspective\n    ]);\n    const [loadComlink, setLoadComlink] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (!isMaybePresentation()) {\n            if (draftModeEnabled && token) {\n                (0,_chunks_es_context_js__WEBPACK_IMPORTED_MODULE_8__.setEnvironment)(\"live\");\n                return;\n            }\n            if (draftModeEnabled) {\n                (0,_chunks_es_context_js__WEBPACK_IMPORTED_MODULE_8__.setEnvironment)(\"static\");\n                return;\n            }\n            (0,_chunks_es_context_js__WEBPACK_IMPORTED_MODULE_8__.setEnvironment)(\"unknown\");\n        }\n    }, [\n        draftModeEnabled,\n        token\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (!isMaybePresentation()) return;\n        const controller = new AbortController(), timeout = setTimeout(()=>(0,_chunks_es_context_js__WEBPACK_IMPORTED_MODULE_8__.setEnvironment)(\"live\"), 3e3);\n        return window.addEventListener(\"message\", ({ data })=>{\n            data && typeof data == \"object\" && \"domain\" in data && data.domain === \"sanity/channels\" && \"from\" in data && data.from === \"presentation\" && (clearTimeout(timeout), (0,_chunks_es_context_js__WEBPACK_IMPORTED_MODULE_8__.setEnvironment)(isMaybePreviewWindow() ? \"presentation-window\" : \"presentation-iframe\"), setLoadComlink(!0), controller.abort());\n        }, {\n            signal: controller.signal\n        }), ()=>{\n            clearTimeout(timeout), controller.abort();\n        };\n    }, []);\n    const draftModeEnabledWarnRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(void 0);\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (draftModeEnabled) return clearTimeout(draftModeEnabledWarnRef.current), ()=>{\n            draftModeEnabledWarnRef.current = setTimeout(()=>{\n                console.warn(\"Sanity Live: Draft mode was enabled, but is now being disabled\");\n            });\n        };\n    }, [\n        draftModeEnabled\n    ]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            draftModeEnabled && loadComlink && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PresentationComlink, {\n                draftModeEnabled,\n                draftModePerspective\n            }),\n            !draftModeEnabled && refreshOnMount && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RefreshOnMount, {}),\n            !draftModeEnabled && refreshOnFocus && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RefreshOnFocus, {}),\n            !draftModeEnabled && refreshOnReconnect && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RefreshOnReconnect, {})\n        ]\n    });\n}\nSanityLive.displayName = \"SanityLive\";\n //# sourceMappingURL=live.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L2NsaWVudC1jb21wb25lbnRzL2xpdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxNQUFNLHNCQUFzQix3REFBTyxDQUFDLElBQU0sMGRBQStCLEVBQUU7Ozs7OztJQUFDLEtBQUs7SUFDM0UsaUJBQWlCLHdEQUFPLENBQUMsSUFBTSx1T0FBMEIsRUFBRTs7Ozs7O0lBQUMsS0FBSztJQUNqRSxpQkFBaUIsd0RBQU8sQ0FBQyxJQUFNLHVPQUEwQixFQUFFOzs7Ozs7SUFBQyxLQUFLO0lBQ2pFLHFCQUFxQix3REFBTyxDQUFDLElBQU0sK09BQThCLEVBQUU7Ozs7OztJQUFDLEtBQUs7SUFnQ3pFLHVCQUF1QixJQUFNLFdBQVcsT0FBTyxRQUMvQyx1QkFBdUIsSUFBTSxDQUFDLENBQUMsT0FBTyxRQUN0QyxzQkFBc0IsSUFBTSwwQkFBMEIsd0JBRXRELGNBQWMsQ0FBQztJQUVmLGtGQUFpQixDQUFDLEtBQUssSUFDekIsUUFBUSxLQUNOLDhFQUE4RSxPQUFPLE1BQU0sMEVBQzNGLE1BQU0sZ0JBQWdCLGdCQUN0QixNQUFNLGNBQWMsU0FBUyxLQUcvQixRQUFRLE1BQU0sS0FBSztBQUd2QjtBQUtPLFNBQVMsV0FBVyxPQUFrRDtJQUNyRSxRQUNKLFdBQ0EsU0FDQSxTQUNBLFlBQ0Esb0JBQ0EsT0FDQTtJQUVBLGtCQUNBLHNCQUNBLGlCQUFpQixJQUNqQixpQkFBaUIsbUJBQ2IsS0FDQSxLQUFrQixHQUNoQixLQUNBLENBQXVCLEVBQzdCLHFCQUFxQixJQUNyQixLQUNBLFVBQVUsZ0JBQ1IsT0FFRSxTQUFTLDhDQUFPLENBQ3BCLElBQ0UsNERBQVksQ0FBQztZQUNYO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQSwyQkFBMkI7WUFDM0I7WUFDQSxRQUFRO1lBQ1I7UUFBQSxDQUNELEdBQ0g7UUFBQztRQUFTO1FBQVk7UUFBUztRQUFXO1FBQWtCO1FBQU8sa0JBQWtCO0tBQUEsR0FNakYsU0FBUyw2REFBUyxJQUNsQixrQkFBa0IsZ0VBQWMsQ0FDcEMsQ0FBQzthQUM4QixJQUFnQixNQUFNLFNBQVMsWUFFMUQsUUFBUSxLQUNOLHVCQUNBLFFBQ0ksa0ZBQ0EsbUJBQ0UsdUpBQ0EsaURBRUMsTUFBTSxTQUFTLFlBQ3hCLHNGQUFrQixDQUFDLE1BQU0sSUFBSSxJQUNwQixNQUFNLFNBQVMsYUFDeEIsT0FBTyxRQUFRO0lBQUE7SUFJckIsZ0RBQVMsQ0FBQztRQUNSLE1BQU0sZUFBZSxPQUFPLEtBQUssT0FBTztZQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQU87UUFBSSxHQUFFLFVBQVU7WUFDL0UsTUFBTSxDQUFDO2lCQUNELE1BQU0sU0FBUyxhQUFhLE1BQU0sU0FBUyxhQUFhLE1BQU0sU0FBUyxjQUN6RSxnQkFBZ0IsS0FBSztZQUV6QjtZQUNBLE9BQU8sQ0FBQztnQkFFTixRQUFRLEdBQUc7WUFBQTtRQUNiLENBQ0Q7UUFDTSxXQUFNLGFBQWEsWUFBWTtJQUFBLEdBQ3JDO1FBQUMsT0FBTztRQUFNO1FBQWlCO1FBQVM7UUFBSyxLQUFLO0tBQUMsR0FLdEQsZ0RBQVMsQ0FBQztRQUNKLG9CQUFvQix1QkFDdEIscUVBQWMsQ0FBQyxvQkFBb0IsSUFFbkMscUVBQWMsQ0FBQyxTQUFTO0lBQUEsR0FFekI7UUFBQztRQUFrQixvQkFBb0I7S0FBQztJQUUzQyxNQUFNLENBQUMsYUFBYSxjQUFjLElBQUksK0NBQVEsQ0FBQyxFQUFLO0lBSXBELGdEQUFTLENBQUM7UUFFUixJQUFJLHdCQUlKO1lBQUEsSUFBSSxvQkFBb0IsT0FBTztnQkFDN0IscUVBQWMsQ0FBQyxNQUFNO2dCQUNyQjtZQUFBO1lBSUYsSUFBSSxrQkFBa0I7Z0JBQ3BCLHFFQUFjLENBQUMsUUFBUTtnQkFDdkI7WUFBQTtZQUlGLHFFQUFjLENBQUMsU0FBUztRQUFBO0lBQUEsR0FFdkI7UUFBQztRQUFrQixLQUFLO0tBQUMsR0FLNUIsZ0RBQVMsQ0FBQztRQUNKLEtBQUMsc0JBQXVCO1FBQ3RCLG1CQUFhLElBQUksbUJBRWpCLFVBQVUsV0FBVyxJQUFNLHFFQUFjLENBQUMsTUFBTSxHQUFHLEdBQUs7UUFDdkQsK0JBQ0wsV0FDQSxDQUFDLEVBQUM7WUFFRSxRQUNBLE9BQU8sUUFBUyxZQUNoQixZQUFZLFFBQ1osS0FBSyxXQUFXLHFCQUNoQixVQUFVLFFBQ1YsS0FBSyxTQUFTLG1CQUVkLGFBQWEsT0FBTyxHQUNwQixxRUFBYyxDQUFDLHlCQUF5Qix3QkFBd0IscUJBQXFCLEdBQ3JGLGVBQWUsRUFBSSxHQUNuQixXQUFXLE9BQU07UUFFckIsR0FDQTtZQUFDLFFBQVEsV0FBVztRQUFNLElBRXJCO1lBQ1Esb0JBQU8sR0FDcEIsV0FBVyxNQUFNO1FBQ25CO0lBQ0YsR0FBRyxFQUFFO0lBTUMsZ0NBQTBCLDZDQUFNLENBQTRDLE1BQVM7SUFDM0YsdURBQVMsQ0FBQztRQUNILHNCQUNRLDRDQUF3QixPQUFPLEdBQ3JDO1lBQ21CLGtDQUFVLFdBQVc7Z0JBRTNDLFFBQVEsS0FBSyxnRUFBZ0U7WUFBQSxDQUM5RTtRQUNIO0lBQUEsR0FDQztRQUFDLGdCQUFnQjtLQUFDLEdBSWhCO1FBQUE7WUFBQSxvQkFBb0IsZUFDbkIsdUVBQUM7Z0JBSUM7Z0JBQ0E7WUFBQTtZQUdILENBQUMsb0JBQW9CLGtCQUFrQix1RUFBQyxnQkFBZTtZQUN2RCxDQUFDLG9CQUFvQixrQkFBa0IsdUVBQUMsZ0JBQWU7WUFDdkQsQ0FBQyxvQkFBb0Isc0JBQXNCLHVFQUFDLG9CQUFtQjtTQUFBO0lBQUEsQ0FDbEU7QUFFSjtBQUNBLFdBQVcsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3ljX2RpcmVjdG9yeS8uLi8uLi9zcmMvY2xpZW50LWNvbXBvbmVudHMvbGl2ZS9TYW5pdHlMaXZlLnRzeD9iZmEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGNyZWF0ZUNsaWVudCxcbiAgdHlwZSBDbGllbnRQZXJzcGVjdGl2ZSxcbiAgdHlwZSBJbml0aWFsaXplZENsaWVudENvbmZpZyxcbiAgdHlwZSBMaXZlRXZlbnRNZXNzYWdlLFxuICB0eXBlIExpdmVFdmVudFJlc3RhcnQsXG4gIHR5cGUgTGl2ZUV2ZW50V2VsY29tZSxcbn0gZnJvbSAnQHNhbml0eS9jbGllbnQnXG5pbXBvcnQge3JldmFsaWRhdGVTeW5jVGFnc30gZnJvbSAnQHNhbml0eS9uZXh0LWxvYWRlci9zZXJ2ZXItYWN0aW9ucydcbmltcG9ydCBkeW5hbWljIGZyb20gJ25leHQvZHluYW1pYydcbmltcG9ydCB7dXNlUm91dGVyfSBmcm9tICduZXh0L25hdmlnYXRpb24uanMnXG5pbXBvcnQge3VzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZX0gZnJvbSAncmVhY3QnXG5pbXBvcnQge3VzZUVmZmVjdEV2ZW50fSBmcm9tICd1c2UtZWZmZWN0LWV2ZW50J1xuaW1wb3J0IHtzZXRFbnZpcm9ubWVudCwgc2V0UGVyc3BlY3RpdmV9IGZyb20gJy4uLy4uL2hvb2tzL2NvbnRleHQnXG5pbXBvcnQge2lzQ29yc09yaWdpbkVycm9yfSBmcm9tICcuLi8uLi9pc0NvcnNPcmlnaW5FcnJvcidcblxuY29uc3QgUHJlc2VudGF0aW9uQ29tbGluayA9IGR5bmFtaWMoKCkgPT4gaW1wb3J0KCcuL1ByZXNlbnRhdGlvbkNvbWxpbmsnKSwge3NzcjogZmFsc2V9KVxuY29uc3QgUmVmcmVzaE9uTW91bnQgPSBkeW5hbWljKCgpID0+IGltcG9ydCgnLi9SZWZyZXNoT25Nb3VudCcpLCB7c3NyOiBmYWxzZX0pXG5jb25zdCBSZWZyZXNoT25Gb2N1cyA9IGR5bmFtaWMoKCkgPT4gaW1wb3J0KCcuL1JlZnJlc2hPbkZvY3VzJyksIHtzc3I6IGZhbHNlfSlcbmNvbnN0IFJlZnJlc2hPblJlY29ubmVjdCA9IGR5bmFtaWMoKCkgPT4gaW1wb3J0KCcuL1JlZnJlc2hPblJlY29ubmVjdCcpLCB7c3NyOiBmYWxzZX0pXG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFNhbml0eUxpdmVQcm9wc1xuICBleHRlbmRzIFBpY2s8XG4gICAgSW5pdGlhbGl6ZWRDbGllbnRDb25maWcsXG4gICAgfCAncHJvamVjdElkJ1xuICAgIHwgJ2RhdGFzZXQnXG4gICAgfCAnYXBpSG9zdCdcbiAgICB8ICdhcGlWZXJzaW9uJ1xuICAgIHwgJ3VzZVByb2plY3RIb3N0bmFtZSdcbiAgICB8ICd0b2tlbidcbiAgICB8ICdyZXF1ZXN0VGFnUHJlZml4J1xuICA+IHtcbiAgLy8gaGFuZGxlRHJhZnRNb2RlQWN0aW9uOiAoc2VjcmV0OiBzdHJpbmcpID0+IFByb21pc2U8dm9pZCB8IHN0cmluZz5cbiAgZHJhZnRNb2RlRW5hYmxlZDogYm9vbGVhblxuICBkcmFmdE1vZGVQZXJzcGVjdGl2ZT86IENsaWVudFBlcnNwZWN0aXZlXG4gIHJlZnJlc2hPbk1vdW50PzogYm9vbGVhblxuICByZWZyZXNoT25Gb2N1cz86IGJvb2xlYW5cbiAgcmVmcmVzaE9uUmVjb25uZWN0PzogYm9vbGVhblxuICB0YWc6IHN0cmluZ1xuICAvKipcbiAgICogSGFuZGxlIGVycm9ycyBmcm9tIHRoZSBMaXZlIEV2ZW50cyBzdWJzY3JpcHRpb24uXG4gICAqIEJ5IGRlZmF1bHQgaXQncyByZXBvcnRlZCB1c2luZyBgY29uc29sZS5lcnJvcmAsIHlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBwcm9wIHRvIGhhbmRsZSBpdCBpbiB5b3VyIG93biB3YXkuXG4gICAqL1xuICBvbkVycm9yPzogKGVycm9yOiB1bmtub3duKSA9PiB2b2lkXG59XG5cbi8vIEBUT0RPIHRoZXNlIHNob3VsZCBiZSByZXVzYWJsZSB1dGlscyBpbiB2aXN1YWwtZWRpdGluZy1oZWxwZXJzXG5cbmNvbnN0IGlzTWF5YmVQcmV2aWV3SWZyYW1lID0gKCkgPT4gd2luZG93ICE9PSB3aW5kb3cucGFyZW50XG5jb25zdCBpc01heWJlUHJldmlld1dpbmRvdyA9ICgpID0+ICEhd2luZG93Lm9wZW5lclxuY29uc3QgaXNNYXliZVByZXNlbnRhdGlvbiA9ICgpID0+IGlzTWF5YmVQcmV2aWV3SWZyYW1lKCkgfHwgaXNNYXliZVByZXZpZXdXaW5kb3coKVxuXG5jb25zdCBoYW5kbGVFcnJvciA9IChlcnJvcjogdW5rbm93bikgPT4ge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmIChpc0NvcnNPcmlnaW5FcnJvcihlcnJvcikpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgU2FuaXR5IExpdmUgaXMgdW5hYmxlIHRvIGNvbm5lY3QgdG8gdGhlIFNhbml0eSBBUEkgYXMgdGhlIGN1cnJlbnQgb3JpZ2luIC0gJHt3aW5kb3cub3JpZ2lufSAtIGlzIG5vdCBpbiB0aGUgbGlzdCBvZiBhbGxvd2VkIENPUlMgb3JpZ2lucyBmb3IgdGhpcyBTYW5pdHkgUHJvamVjdC5gLFxuICAgICAgZXJyb3IuYWRkT3JpZ2luVXJsICYmIGBBZGQgaXQgaGVyZTpgLFxuICAgICAgZXJyb3IuYWRkT3JpZ2luVXJsPy50b1N0cmluZygpLFxuICAgIClcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNhbml0eUxpdmUocHJvcHM6IFNhbml0eUxpdmVQcm9wcyk6IFJlYWN0LkpTWC5FbGVtZW50IHwgbnVsbCB7XG4gIGNvbnN0IHtcbiAgICBwcm9qZWN0SWQsXG4gICAgZGF0YXNldCxcbiAgICBhcGlIb3N0LFxuICAgIGFwaVZlcnNpb24sXG4gICAgdXNlUHJvamVjdEhvc3RuYW1lLFxuICAgIHRva2VuLFxuICAgIHJlcXVlc3RUYWdQcmVmaXgsXG4gICAgLy8gaGFuZGxlRHJhZnRNb2RlQWN0aW9uLFxuICAgIGRyYWZ0TW9kZUVuYWJsZWQsXG4gICAgZHJhZnRNb2RlUGVyc3BlY3RpdmUsXG4gICAgcmVmcmVzaE9uTW91bnQgPSBmYWxzZSxcbiAgICByZWZyZXNoT25Gb2N1cyA9IGRyYWZ0TW9kZUVuYWJsZWRcbiAgICAgID8gZmFsc2VcbiAgICAgIDogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB0cnVlXG4gICAgICAgIDogd2luZG93LnNlbGYgPT09IHdpbmRvdy50b3AsXG4gICAgcmVmcmVzaE9uUmVjb25uZWN0ID0gdHJ1ZSxcbiAgICB0YWcsXG4gICAgb25FcnJvciA9IGhhbmRsZUVycm9yLFxuICB9ID0gcHJvcHNcblxuICBjb25zdCBjbGllbnQgPSB1c2VNZW1vKFxuICAgICgpID0+XG4gICAgICBjcmVhdGVDbGllbnQoe1xuICAgICAgICBwcm9qZWN0SWQsXG4gICAgICAgIGRhdGFzZXQsXG4gICAgICAgIGFwaUhvc3QsXG4gICAgICAgIGFwaVZlcnNpb24sXG4gICAgICAgIHVzZVByb2plY3RIb3N0bmFtZSxcbiAgICAgICAgaWdub3JlQnJvd3NlclRva2VuV2FybmluZzogdHJ1ZSxcbiAgICAgICAgdG9rZW4sXG4gICAgICAgIHVzZUNkbjogZmFsc2UsXG4gICAgICAgIHJlcXVlc3RUYWdQcmVmaXgsXG4gICAgICB9KSxcbiAgICBbYXBpSG9zdCwgYXBpVmVyc2lvbiwgZGF0YXNldCwgcHJvamVjdElkLCByZXF1ZXN0VGFnUHJlZml4LCB0b2tlbiwgdXNlUHJvamVjdEhvc3RuYW1lXSxcbiAgKVxuXG4gIC8qKlxuICAgKiAxLiBIYW5kbGUgTGl2ZSBFdmVudHMgYW5kIGNhbGwgcmV2YWxpZGF0ZVRhZyBvciByb3V0ZXIucmVmcmVzaCB3aGVuIG5lZWRlZFxuICAgKi9cbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKClcbiAgY29uc3QgaGFuZGxlTGl2ZUV2ZW50ID0gdXNlRWZmZWN0RXZlbnQoXG4gICAgKGV2ZW50OiBMaXZlRXZlbnRNZXNzYWdlIHwgTGl2ZUV2ZW50UmVzdGFydCB8IExpdmVFdmVudFdlbGNvbWUpID0+IHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV2ZW50LnR5cGUgPT09ICd3ZWxjb21lJykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgICAgJ1Nhbml0eSBpcyBsaXZlIHdpdGgnLFxuICAgICAgICAgIHRva2VuXG4gICAgICAgICAgICA/ICdhdXRvbWF0aWMgcmV2YWxpZGF0aW9uIGZvciBkcmFmdCBjb250ZW50IGNoYW5nZXMgYXMgd2VsbCBhcyBwdWJsaXNoZWQgY29udGVudCdcbiAgICAgICAgICAgIDogZHJhZnRNb2RlRW5hYmxlZFxuICAgICAgICAgICAgICA/ICdhdXRvbWF0aWMgcmV2YWxpZGF0aW9uIGZvciBvbmx5IHB1Ymxpc2hlZCBjb250ZW50LiBQcm92aWRlIGEgYGJyb3dzZXJUb2tlbmAgdG8gYGRlZmluZUxpdmVgIHRvIHN1cHBvcnQgZHJhZnQgY29udGVudCBvdXRzaWRlIG9mIFByZXNlbnRhdGlvbiBUb29sLidcbiAgICAgICAgICAgICAgOiAnYXV0b21hdGljIHJldmFsaWRhdGlvbiBvZiBwdWJsaXNoZWQgY29udGVudCcsXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICAgIHJldmFsaWRhdGVTeW5jVGFncyhldmVudC50YWdzKVxuICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAncmVzdGFydCcpIHtcbiAgICAgICAgcm91dGVyLnJlZnJlc2goKVxuICAgICAgfVxuICAgIH0sXG4gIClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBjbGllbnQubGl2ZS5ldmVudHMoe2luY2x1ZGVEcmFmdHM6ICEhdG9rZW4sIHRhZ30pLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdtZXNzYWdlJyB8fCBldmVudC50eXBlID09PSAncmVzdGFydCcgfHwgZXZlbnQudHlwZSA9PT0gJ3dlbGNvbWUnKSB7XG4gICAgICAgICAgaGFuZGxlTGl2ZUV2ZW50KGV2ZW50KVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJyb3I6IChlcnI6IHVua25vd24pID0+IHtcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignV2hhdD8nLCBlcnIpXG4gICAgICAgIG9uRXJyb3IoZXJyKVxuICAgICAgfSxcbiAgICB9KVxuICAgIHJldHVybiAoKSA9PiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKVxuICB9LCBbY2xpZW50LmxpdmUsIGhhbmRsZUxpdmVFdmVudCwgb25FcnJvciwgdGFnLCB0b2tlbl0pXG5cbiAgLyoqXG4gICAqIDIuIE5vdGlmeSB3aGF0IHBlcnNwZWN0aXZlIHdlJ3JlIGluLCB3aGVuIGluIERyYWZ0IE1vZGVcbiAgICovXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRyYWZ0TW9kZUVuYWJsZWQgJiYgZHJhZnRNb2RlUGVyc3BlY3RpdmUpIHtcbiAgICAgIHNldFBlcnNwZWN0aXZlKGRyYWZ0TW9kZVBlcnNwZWN0aXZlKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRQZXJzcGVjdGl2ZSgndW5rbm93bicpXG4gICAgfVxuICB9LCBbZHJhZnRNb2RlRW5hYmxlZCwgZHJhZnRNb2RlUGVyc3BlY3RpdmVdKVxuXG4gIGNvbnN0IFtsb2FkQ29tbGluaywgc2V0TG9hZENvbWxpbmtdID0gdXNlU3RhdGUoZmFsc2UpXG4gIC8qKlxuICAgKiAzLiBOb3RpZnkgd2hhdCBlbnZpcm9ubWVudCB3ZSdyZSBpbiwgd2hlbiBpbiBEcmFmdCBNb2RlXG4gICAqL1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElmIHdlIG1pZ2h0IGJlIGluIFByZXNlbnRhdGlvbiBUb29sLCB0aGVuIHNraXAgZGV0ZWN0aW5nIGhlcmUgYXMgaXQncyBoYW5kbGVkIGxhdGVyXG4gICAgaWYgKGlzTWF5YmVQcmVzZW50YXRpb24oKSkgcmV0dXJuXG5cbiAgICAvLyBJZiB3ZSdyZSBkZWZpbml0ZWx5IG5vdCBpbiBQcmVzZW50YXRpb24gVG9vbCwgdGhlbiB3ZSBjYW4gc2V0IHRoZSBlbnZpcm9ubWVudCBhcyBzdGFuZC1hbG9uZSBsaXZlIHByZXZpZXdcbiAgICAvLyBpZiB3ZSBoYXZlIGJvdGggYSBicm93c2VyIHRva2VuLCBhbmQgZHJhZnQgbW9kZSBpcyBlbmFibGVkXG4gICAgaWYgKGRyYWZ0TW9kZUVuYWJsZWQgJiYgdG9rZW4pIHtcbiAgICAgIHNldEVudmlyb25tZW50KCdsaXZlJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBJZiB3ZSdyZSBpbiBkcmFmdCBtb2RlLCBidXQgZG9uJ3QgaGF2ZSBhIGJyb3dzZXIgdG9rZW4sIHRoZW4gd2UncmUgaW4gc3RhdGljIG1vZGVcbiAgICAvLyB3aGljaCBtZWFucyB0aGF0IHB1Ymxpc2hlZCBjb250ZW50IGlzIHN0aWxsIGxpdmUsIGJ1dCBkcmFmdCBjaGFuZ2VzIGxpa2VseSBuZWVkIG1hbnVhbCByZWZyZXNoXG4gICAgaWYgKGRyYWZ0TW9kZUVuYWJsZWQpIHtcbiAgICAgIHNldEVudmlyb25tZW50KCdzdGF0aWMnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgdG8gYHVua25vd25gIG90aGVyd2lzZSwgYXMgd2Ugc2ltcGx5IGRvbid0IGtub3cgaG93IGl0J3Mgc2V0dXBcbiAgICBzZXRFbnZpcm9ubWVudCgndW5rbm93bicpXG4gICAgcmV0dXJuXG4gIH0sIFtkcmFmdE1vZGVFbmFibGVkLCB0b2tlbl0pXG5cbiAgLyoqXG4gICAqIDQuIElmIFByZXNlbnRhdGlvbiBUb29sIGlzIGRldGVjdGVkLCBsb2FkIHVwIHRoZSBjb21saW5rIGFuZCBpbnRlZ3JhdGUgd2l0aCBpdFxuICAgKi9cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzTWF5YmVQcmVzZW50YXRpb24oKSkgcmV0dXJuXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIC8vIFdhaXQgZm9yIGEgd2hpbGUgdG8gc2VlIGlmIFByZXNlbnRhdGlvbiBUb29sIGlzIGRldGVjdGVkLCBiZWZvcmUgYXNzdW1pbmcgdGhlIGVudiB0byBiZSBzdGFuZC1hbG9uZSBsaXZlIHByZXZpZXdcbiAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzZXRFbnZpcm9ubWVudCgnbGl2ZScpLCAzXzAwMClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICdtZXNzYWdlJyxcbiAgICAgICh7ZGF0YX06IE1lc3NhZ2VFdmVudDx1bmtub3duPikgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZGF0YSAmJlxuICAgICAgICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICdkb21haW4nIGluIGRhdGEgJiZcbiAgICAgICAgICBkYXRhLmRvbWFpbiA9PT0gJ3Nhbml0eS9jaGFubmVscycgJiZcbiAgICAgICAgICAnZnJvbScgaW4gZGF0YSAmJlxuICAgICAgICAgIGRhdGEuZnJvbSA9PT0gJ3ByZXNlbnRhdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICAgICAgc2V0RW52aXJvbm1lbnQoaXNNYXliZVByZXZpZXdXaW5kb3coKSA/ICdwcmVzZW50YXRpb24td2luZG93JyA6ICdwcmVzZW50YXRpb24taWZyYW1lJylcbiAgICAgICAgICBzZXRMb2FkQ29tbGluayh0cnVlKVxuICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge3NpZ25hbDogY29udHJvbGxlci5zaWduYWx9LFxuICAgIClcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICBjb250cm9sbGVyLmFib3J0KClcbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8qKlxuICAgKiA1LiBXYXJuIGlmIGRyYWZ0IG1vZGUgaXMgYmVpbmcgZGlzYWJsZWRcbiAgICogQFRPRE8gbW92ZSBsb2dpYyBpbnRvIFByZXNlbnRhdGlvbkNvbWxpbmssIG9yIG1heWJlIFZpc3VhbEVkaXRpbmc/XG4gICAqL1xuICBjb25zdCBkcmFmdE1vZGVFbmFibGVkV2FyblJlZiA9IHVzZVJlZjxSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZHJhZnRNb2RlRW5hYmxlZCkgcmV0dXJuXG4gICAgY2xlYXJUaW1lb3V0KGRyYWZ0TW9kZUVuYWJsZWRXYXJuUmVmLmN1cnJlbnQpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRyYWZ0TW9kZUVuYWJsZWRXYXJuUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKCdTYW5pdHkgTGl2ZTogRHJhZnQgbW9kZSB3YXMgZW5hYmxlZCwgYnV0IGlzIG5vdyBiZWluZyBkaXNhYmxlZCcpXG4gICAgICB9KVxuICAgIH1cbiAgfSwgW2RyYWZ0TW9kZUVuYWJsZWRdKVxuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIHtkcmFmdE1vZGVFbmFibGVkICYmIGxvYWRDb21saW5rICYmIChcbiAgICAgICAgPFByZXNlbnRhdGlvbkNvbWxpbmtcbiAgICAgICAgICAvLyBwcm9qZWN0SWQ9e3Byb2plY3RJZCF9XG4gICAgICAgICAgLy8gZGF0YXNldD17ZGF0YXNldCF9XG4gICAgICAgICAgLy8gaGFuZGxlRHJhZnRNb2RlQWN0aW9uPXtoYW5kbGVEcmFmdE1vZGVBY3Rpb259XG4gICAgICAgICAgZHJhZnRNb2RlRW5hYmxlZD17ZHJhZnRNb2RlRW5hYmxlZH1cbiAgICAgICAgICBkcmFmdE1vZGVQZXJzcGVjdGl2ZT17ZHJhZnRNb2RlUGVyc3BlY3RpdmUhfVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIHshZHJhZnRNb2RlRW5hYmxlZCAmJiByZWZyZXNoT25Nb3VudCAmJiA8UmVmcmVzaE9uTW91bnQgLz59XG4gICAgICB7IWRyYWZ0TW9kZUVuYWJsZWQgJiYgcmVmcmVzaE9uRm9jdXMgJiYgPFJlZnJlc2hPbkZvY3VzIC8+fVxuICAgICAgeyFkcmFmdE1vZGVFbmFibGVkICYmIHJlZnJlc2hPblJlY29ubmVjdCAmJiA8UmVmcmVzaE9uUmVjb25uZWN0IC8+fVxuICAgIDwvPlxuICApXG59XG5TYW5pdHlMaXZlLmRpc3BsYXlOYW1lID0gJ1Nhbml0eUxpdmUnXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/next-loader/dist/client-components/live.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ C),\n/* harmony export */   stegaClean: () => (/* binding */ stegaClean),\n/* harmony export */   vercelStegaCleanAll: () => (/* binding */ vercelStegaCleanAll)\n/* harmony export */ });\nvar s = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, c = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 }, u = new Array(4).fill(String.fromCodePoint(c[0])).join(\"\");\nfunction E(t) {\n  let e = JSON.stringify(t);\n  return `${u}${Array.from(e).map((r) => {\n    let n = r.charCodeAt(0);\n    if (n > 255)\n      throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);\n    return Array.from(n.toString(4).padStart(4, \"0\")).map((o) => String.fromCodePoint(c[o])).join(\"\");\n  }).join(\"\")}`;\n}\nfunction I(t) {\n  return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t) ? !1 : !!Date.parse(t);\n}\nfunction T(t) {\n  try {\n    new URL(t, t.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nfunction C(t, e, r = \"auto\") {\n  return r === !0 || r === \"auto\" && (I(t) || T(t)) ? t : `${t}${E(e)}`;\n}\nObject.fromEntries(Object.entries(c).map((t) => t.reverse()));\nObject.fromEntries(Object.entries(s).map((t) => t.reverse()));\nvar S = `${Object.values(s).map((t) => `\\\\u{${t.toString(16)}}`).join(\"\")}`, f = new RegExp(`[${S}]{4,}`, \"gu\");\nfunction _(t) {\n  var e;\n  return { cleaned: t.replace(f, \"\"), encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || \"\" };\n}\nfunction O(t) {\n  return t && JSON.parse(_(JSON.stringify(t)).cleaned);\n}\nfunction stegaClean(result) {\n  return O(result);\n}\nconst vercelStegaCleanAll = stegaClean;\n\n//# sourceMappingURL=stegaClean.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L19jaHVua3MtZXMvc3RlZ2FDbGVhbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxVQUFVLGlLQUFpSyxRQUFRLHFDQUFxQztBQUN4TjtBQUNBO0FBQ0EsWUFBWSxFQUFFLEVBQUU7QUFDaEI7QUFDQTtBQUNBLHlGQUF5RixHQUFHLGVBQWUsR0FBRyxHQUFHLEVBQUU7QUFDbkg7QUFDQSxHQUFHLFdBQVc7QUFDZDtBQUNBO0FBQ0EsNEVBQTRFLEVBQUUscUJBQXFCLElBQUk7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxFQUFFLEVBQUUsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQyxFQUFFLGdCQUFnQixZQUFZLHNCQUFzQixFQUFFLEVBQUUsR0FBRztBQUN2RztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWNfZGlyZWN0b3J5Ly4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2Rpc3QvX2NodW5rcy1lcy9zdGVnYUNsZWFuLmpzP2E3OTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHMgPSB7IDA6IDgyMDMsIDE6IDgyMDQsIDI6IDgyMDUsIDM6IDgyOTAsIDQ6IDgyOTEsIDU6IDgyODgsIDY6IDY1Mjc5LCA3OiA4Mjg5LCA4OiAxMTkxNTUsIDk6IDExOTE1NiwgYTogMTE5MTU3LCBiOiAxMTkxNTgsIGM6IDExOTE1OSwgZDogMTE5MTYwLCBlOiAxMTkxNjEsIGY6IDExOTE2MiB9LCBjID0geyAwOiA4MjAzLCAxOiA4MjA0LCAyOiA4MjA1LCAzOiA2NTI3OSB9LCB1ID0gbmV3IEFycmF5KDQpLmZpbGwoU3RyaW5nLmZyb21Db2RlUG9pbnQoY1swXSkpLmpvaW4oXCJcIik7XG5mdW5jdGlvbiBFKHQpIHtcbiAgbGV0IGUgPSBKU09OLnN0cmluZ2lmeSh0KTtcbiAgcmV0dXJuIGAke3V9JHtBcnJheS5mcm9tKGUpLm1hcCgocikgPT4ge1xuICAgIGxldCBuID0gci5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChuID4gMjU1KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbmx5IEFTQ0lJIGVkaXQgaW5mbyBjYW4gYmUgZW5jb2RlZC4gRXJyb3IgYXR0ZW1wdGluZyB0byBlbmNvZGUgJHtlfSBvbiBjaGFyYWN0ZXIgJHtyfSAoJHtufSlgKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuLnRvU3RyaW5nKDQpLnBhZFN0YXJ0KDQsIFwiMFwiKSkubWFwKChvKSA9PiBTdHJpbmcuZnJvbUNvZGVQb2ludChjW29dKSkuam9pbihcIlwiKTtcbiAgfSkuam9pbihcIlwiKX1gO1xufVxuZnVuY3Rpb24gSSh0KSB7XG4gIHJldHVybiAhTnVtYmVyLmlzTmFOKE51bWJlcih0KSkgfHwgL1thLXpdL2kudGVzdCh0KSAmJiAhL1xcZCsoPzpbLTpcXC9dXFxkKyl7Mn0oPzpUXFxkKyg/OlstOlxcL11cXGQrKXsxLDJ9KFxcLlxcZCspP1o/KT8vLnRlc3QodCkgPyAhMSA6ICEhRGF0ZS5wYXJzZSh0KTtcbn1cbmZ1bmN0aW9uIFQodCkge1xuICB0cnkge1xuICAgIG5ldyBVUkwodCwgdC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiaHR0cHM6Ly9hY21lLmNvbVwiIDogdm9pZCAwKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIEModCwgZSwgciA9IFwiYXV0b1wiKSB7XG4gIHJldHVybiByID09PSAhMCB8fCByID09PSBcImF1dG9cIiAmJiAoSSh0KSB8fCBUKHQpKSA/IHQgOiBgJHt0fSR7RShlKX1gO1xufVxuT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGMpLm1hcCgodCkgPT4gdC5yZXZlcnNlKCkpKTtcbk9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhzKS5tYXAoKHQpID0+IHQucmV2ZXJzZSgpKSk7XG52YXIgUyA9IGAke09iamVjdC52YWx1ZXMocykubWFwKCh0KSA9PiBgXFxcXHV7JHt0LnRvU3RyaW5nKDE2KX19YCkuam9pbihcIlwiKX1gLCBmID0gbmV3IFJlZ0V4cChgWyR7U31dezQsfWAsIFwiZ3VcIik7XG5mdW5jdGlvbiBfKHQpIHtcbiAgdmFyIGU7XG4gIHJldHVybiB7IGNsZWFuZWQ6IHQucmVwbGFjZShmLCBcIlwiKSwgZW5jb2RlZDogKChlID0gdC5tYXRjaChmKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGVbMF0pIHx8IFwiXCIgfTtcbn1cbmZ1bmN0aW9uIE8odCkge1xuICByZXR1cm4gdCAmJiBKU09OLnBhcnNlKF8oSlNPTi5zdHJpbmdpZnkodCkpLmNsZWFuZWQpO1xufVxuZnVuY3Rpb24gc3RlZ2FDbGVhbihyZXN1bHQpIHtcbiAgcmV0dXJuIE8ocmVzdWx0KTtcbn1cbmNvbnN0IHZlcmNlbFN0ZWdhQ2xlYW5BbGwgPSBzdGVnYUNsZWFuO1xuZXhwb3J0IHtcbiAgQyxcbiAgc3RlZ2FDbGVhbixcbiAgdmVyY2VsU3RlZ2FDbGVhbkFsbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0ZWdhQ2xlYW4uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ C),\n/* harmony export */   stegaClean: () => (/* binding */ stegaClean),\n/* harmony export */   vercelStegaCleanAll: () => (/* binding */ vercelStegaCleanAll)\n/* harmony export */ });\nvar s = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, c = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 }, u = new Array(4).fill(String.fromCodePoint(c[0])).join(\"\");\nfunction E(t) {\n  let e = JSON.stringify(t);\n  return `${u}${Array.from(e).map((r) => {\n    let n = r.charCodeAt(0);\n    if (n > 255)\n      throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);\n    return Array.from(n.toString(4).padStart(4, \"0\")).map((o) => String.fromCodePoint(c[o])).join(\"\");\n  }).join(\"\")}`;\n}\nfunction I(t) {\n  return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t) ? !1 : !!Date.parse(t);\n}\nfunction T(t) {\n  try {\n    new URL(t, t.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nfunction C(t, e, r = \"auto\") {\n  return r === !0 || r === \"auto\" && (I(t) || T(t)) ? t : `${t}${E(e)}`;\n}\nObject.fromEntries(Object.entries(c).map((t) => t.reverse()));\nObject.fromEntries(Object.entries(s).map((t) => t.reverse()));\nvar S = `${Object.values(s).map((t) => `\\\\u{${t.toString(16)}}`).join(\"\")}`, f = new RegExp(`[${S}]{4,}`, \"gu\");\nfunction _(t) {\n  var e;\n  return { cleaned: t.replace(f, \"\"), encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || \"\" };\n}\nfunction O(t) {\n  return t && JSON.parse(_(JSON.stringify(t)).cleaned);\n}\nfunction stegaClean(result) {\n  return O(result);\n}\nconst vercelStegaCleanAll = stegaClean;\n\n//# sourceMappingURL=stegaClean.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzLWVzL3N0ZWdhQ2xlYW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsVUFBVSxpS0FBaUssUUFBUSxxQ0FBcUM7QUFDeE47QUFDQTtBQUNBLFlBQVksRUFBRSxFQUFFO0FBQ2hCO0FBQ0E7QUFDQSx5RkFBeUYsR0FBRyxlQUFlLEdBQUcsR0FBRyxFQUFFO0FBQ25IO0FBQ0EsR0FBRyxXQUFXO0FBQ2Q7QUFDQTtBQUNBLDRFQUE0RSxFQUFFLHFCQUFxQixJQUFJO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsRUFBRSxFQUFFLEtBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUMsRUFBRSxnQkFBZ0IsWUFBWSxzQkFBc0IsRUFBRSxFQUFFLEdBQUc7QUFDdkc7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3ljX2RpcmVjdG9yeS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L19jaHVua3MtZXMvc3RlZ2FDbGVhbi5qcz8zYmRkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzID0geyAwOiA4MjAzLCAxOiA4MjA0LCAyOiA4MjA1LCAzOiA4MjkwLCA0OiA4MjkxLCA1OiA4Mjg4LCA2OiA2NTI3OSwgNzogODI4OSwgODogMTE5MTU1LCA5OiAxMTkxNTYsIGE6IDExOTE1NywgYjogMTE5MTU4LCBjOiAxMTkxNTksIGQ6IDExOTE2MCwgZTogMTE5MTYxLCBmOiAxMTkxNjIgfSwgYyA9IHsgMDogODIwMywgMTogODIwNCwgMjogODIwNSwgMzogNjUyNzkgfSwgdSA9IG5ldyBBcnJheSg0KS5maWxsKFN0cmluZy5mcm9tQ29kZVBvaW50KGNbMF0pKS5qb2luKFwiXCIpO1xuZnVuY3Rpb24gRSh0KSB7XG4gIGxldCBlID0gSlNPTi5zdHJpbmdpZnkodCk7XG4gIHJldHVybiBgJHt1fSR7QXJyYXkuZnJvbShlKS5tYXAoKHIpID0+IHtcbiAgICBsZXQgbiA9IHIuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAobiA+IDI1NSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSBBU0NJSSBlZGl0IGluZm8gY2FuIGJlIGVuY29kZWQuIEVycm9yIGF0dGVtcHRpbmcgdG8gZW5jb2RlICR7ZX0gb24gY2hhcmFjdGVyICR7cn0gKCR7bn0pYCk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obi50b1N0cmluZyg0KS5wYWRTdGFydCg0LCBcIjBcIikpLm1hcCgobykgPT4gU3RyaW5nLmZyb21Db2RlUG9pbnQoY1tvXSkpLmpvaW4oXCJcIik7XG4gIH0pLmpvaW4oXCJcIil9YDtcbn1cbmZ1bmN0aW9uIEkodCkge1xuICByZXR1cm4gIU51bWJlci5pc05hTihOdW1iZXIodCkpIHx8IC9bYS16XS9pLnRlc3QodCkgJiYgIS9cXGQrKD86Wy06XFwvXVxcZCspezJ9KD86VFxcZCsoPzpbLTpcXC9dXFxkKyl7MSwyfShcXC5cXGQrKT9aPyk/Ly50ZXN0KHQpID8gITEgOiAhIURhdGUucGFyc2UodCk7XG59XG5mdW5jdGlvbiBUKHQpIHtcbiAgdHJ5IHtcbiAgICBuZXcgVVJMKHQsIHQuc3RhcnRzV2l0aChcIi9cIikgPyBcImh0dHBzOi8vYWNtZS5jb21cIiA6IHZvaWQgMCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBDKHQsIGUsIHIgPSBcImF1dG9cIikge1xuICByZXR1cm4gciA9PT0gITAgfHwgciA9PT0gXCJhdXRvXCIgJiYgKEkodCkgfHwgVCh0KSkgPyB0IDogYCR7dH0ke0UoZSl9YDtcbn1cbk9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhjKS5tYXAoKHQpID0+IHQucmV2ZXJzZSgpKSk7XG5PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocykubWFwKCh0KSA9PiB0LnJldmVyc2UoKSkpO1xudmFyIFMgPSBgJHtPYmplY3QudmFsdWVzKHMpLm1hcCgodCkgPT4gYFxcXFx1eyR7dC50b1N0cmluZygxNil9fWApLmpvaW4oXCJcIil9YCwgZiA9IG5ldyBSZWdFeHAoYFske1N9XXs0LH1gLCBcImd1XCIpO1xuZnVuY3Rpb24gXyh0KSB7XG4gIHZhciBlO1xuICByZXR1cm4geyBjbGVhbmVkOiB0LnJlcGxhY2UoZiwgXCJcIiksIGVuY29kZWQ6ICgoZSA9IHQubWF0Y2goZikpID09IG51bGwgPyB2b2lkIDAgOiBlWzBdKSB8fCBcIlwiIH07XG59XG5mdW5jdGlvbiBPKHQpIHtcbiAgcmV0dXJuIHQgJiYgSlNPTi5wYXJzZShfKEpTT04uc3RyaW5naWZ5KHQpKS5jbGVhbmVkKTtcbn1cbmZ1bmN0aW9uIHN0ZWdhQ2xlYW4ocmVzdWx0KSB7XG4gIHJldHVybiBPKHJlc3VsdCk7XG59XG5jb25zdCB2ZXJjZWxTdGVnYUNsZWFuQWxsID0gc3RlZ2FDbGVhbjtcbmV4cG9ydCB7XG4gIEMsXG4gIHN0ZWdhQ2xlYW4sXG4gIHZlcmNlbFN0ZWdhQ2xlYW5BbGxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGVnYUNsZWFuLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeIntoResult: () => (/* binding */ encodeIntoResult),\n/* harmony export */   stegaEncodeSourceMap: () => (/* binding */ stegaEncodeSourceMap),\n/* harmony export */   stegaEncodeSourceMap$1: () => (/* binding */ stegaEncodeSourceMap$1)\n/* harmony export */ });\n/* harmony import */ var _stegaClean_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stegaClean.js */ \"(action-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\");\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\")\n      return `${target}[${segment}]`;\n    if (segmentType === \"string\")\n      return `${target}${i === 0 ? \"\" : \".\"}${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nconst ESCAPE = {\n  \"\\f\": \"\\\\f\",\n  \"\\n\": \"\\\\n\",\n  \"\\r\": \"\\\\r\",\n  \"\t\": \"\\\\t\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n}, UNESCAPE = {\n  \"\\\\f\": \"\\f\",\n  \"\\\\n\": `\n`,\n  \"\\\\r\": \"\\r\",\n  \"\\\\t\": \"\t\",\n  \"\\\\'\": \"'\",\n  \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n  return `$${path.map((segment) => typeof segment == \"string\" ? `['${segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => ESCAPE[match])}']` : typeof segment == \"number\" ? `[${segment}]` : segment._key !== \"\" ? `[?(@._key=='${segment._key.replace(/['\\\\]/g, (match) => ESCAPE[match])}')]` : `[${segment._index}]`).join(\"\")}`;\n}\nfunction parseJsonPath(path) {\n  const parsed = [], parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  for (; (match = parseRe.exec(path)) !== null; ) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => UNESCAPE[m]);\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => UNESCAPE[m]);\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._key !== \"\")\n      return { _key: segment._key };\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction resolveMapping(resultPath, csm) {\n  if (!csm?.mappings)\n    return;\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0)\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: \"\"\n    };\n  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);\n  if (mappings.length == 0)\n    return;\n  const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return { mapping, matchedPath, pathSuffix };\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction isRecord(value) {\n  return typeof value == \"object\" && value !== null;\n}\nfunction walkMap(value, mappingFn, path = []) {\n  if (isArray(value))\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v._key;\n        if (typeof _key == \"string\")\n          return walkMap(v, mappingFn, path.concat({ _key, _index: idx }));\n      }\n      return walkMap(v, mappingFn, path.concat(idx));\n    });\n  if (isRecord(value)) {\n    if (value._type === \"block\" || value._type === \"span\") {\n      const result = { ...value };\n      return value._type === \"block\" ? result.children = walkMap(value.children, mappingFn, path.concat(\"children\")) : value._type === \"span\" && (result.text = walkMap(value.text, mappingFn, path.concat(\"text\"))), result;\n    }\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))])\n    );\n  }\n  return mappingFn(value, path);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n  return walkMap(result, (value, path) => {\n    if (typeof value != \"string\")\n      return value;\n    const resolveMappingResult = resolveMapping(path, csm);\n    if (!resolveMappingResult)\n      return value;\n    const { mapping, matchedPath } = resolveMappingResult;\n    if (mapping.type !== \"value\" || mapping.source.type !== \"documentValue\")\n      return value;\n    const sourceDocument = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path], matchPathSegments = parseJsonPath(matchedPath), fullSourceSegments = parseJsonPath(sourcePath).concat(path.slice(matchPathSegments.length));\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value\n    });\n  });\n}\nconst DRAFTS_PREFIX = \"drafts.\";\nfunction getPublishedId(id) {\n  return id.startsWith(DRAFTS_PREFIX) ? id.slice(DRAFTS_PREFIX.length) : id;\n}\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path,\n    projectId,\n    dataset\n  } = options;\n  if (!baseUrl)\n    throw new Error(\"baseUrl is required\");\n  if (!path)\n    throw new Error(\"path is required\");\n  if (!_id)\n    throw new Error(\"id is required\");\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\"))\n    throw new Error(\"baseUrl must not end with a slash\");\n  const workspace = _workspace === \"default\" ? void 0 : _workspace, tool = _tool === \"default\" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath\n  });\n  workspace && searchParams.set(\"workspace\", workspace), tool && searchParams.set(\"tool\", tool), projectId && searchParams.set(\"projectId\", projectId), dataset && searchParams.set(\"dataset\", dataset), _id.startsWith(DRAFTS_PREFIX) && searchParams.set(\"isDraft\", \"\");\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  workspace && segments.push(workspace);\n  const routerParams = [\n    \"mode=presentation\",\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`\n  ];\n  return tool && routerParams.push(`tool=${tool}`), segments.push(\"intent\", \"edit\", `${routerParams.join(\";\")}?${searchParams}`), segments.join(\"/\");\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl == \"string\" ? studioUrl : studioUrl.baseUrl;\n  return baseUrl !== \"/\" && (baseUrl = baseUrl.replace(/\\/$/, \"\")), typeof studioUrl == \"string\" ? { baseUrl } : { ...studioUrl, baseUrl };\n}\nconst filterDefault = ({ sourcePath, resultPath, value }) => {\n  if (isValidDate(value) || isValidURL(value))\n    return !1;\n  const endPath = sourcePath.at(-1);\n  return !(sourcePath.at(-2) === \"slug\" && endPath === \"current\" || typeof endPath == \"string\" && (endPath.startsWith(\"_\") || endPath.endsWith(\"Id\")) || sourcePath.some(\n    (path) => path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\"\n  ) || hasTypeLike(sourcePath) || hasTypeLike(resultPath) || typeof endPath == \"string\" && denylist.has(endPath));\n}, denylist = /* @__PURE__ */ new Set([\n  \"color\",\n  \"colour\",\n  \"currency\",\n  \"email\",\n  \"format\",\n  \"gid\",\n  \"hex\",\n  \"href\",\n  \"hsl\",\n  \"hsla\",\n  \"icon\",\n  \"id\",\n  \"index\",\n  \"key\",\n  \"language\",\n  \"layout\",\n  \"link\",\n  \"linkAction\",\n  \"locale\",\n  \"lqip\",\n  \"page\",\n  \"path\",\n  \"ref\",\n  \"rgb\",\n  \"rgba\",\n  \"route\",\n  \"secret\",\n  \"slug\",\n  \"status\",\n  \"tag\",\n  \"template\",\n  \"theme\",\n  \"type\",\n  \"textTheme\",\n  \"unit\",\n  \"url\",\n  \"username\",\n  \"variant\",\n  \"website\"\n]);\nfunction isValidDate(dateString) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? !!Date.parse(dateString) : !1;\n}\nfunction isValidURL(url) {\n  try {\n    new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nfunction hasTypeLike(path) {\n  return path.some((segment) => typeof segment == \"string\" && segment.match(/type/i) !== null);\n}\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n  const { filter, logger, enabled } = config;\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  if (!resultSourceMap)\n    return logger?.error?.(\"[@sanity/client]: Missing Content Source Map from response body\", {\n      result,\n      resultSourceMap,\n      config\n    }), result;\n  if (!config.studioUrl) {\n    const msg = \"config.studioUrl must be defined\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  const report = {\n    encoded: [],\n    skipped: []\n  }, resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({ sourcePath, sourceDocument, resultPath, value }) => {\n      if ((typeof filter == \"function\" ? filter({ sourcePath, resultPath, filterDefault, sourceDocument, value }) : filterDefault({ sourcePath, resultPath, filterDefault, sourceDocument, value })) === !1)\n        return logger && report.skipped.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n          length: value.length\n        }), value;\n      logger && report.encoded.push({\n        path: prettyPathForLogging(sourcePath),\n        value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n        length: value.length\n      });\n      const { baseUrl, workspace, tool } = resolveStudioBaseRoute(\n        typeof config.studioUrl == \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl\n      );\n      if (!baseUrl)\n        return value;\n      const { _id: id, _type: type, _projectId: projectId, _dataset: dataset } = sourceDocument;\n      return (0,_stegaClean_js__WEBPACK_IMPORTED_MODULE_0__.C)(\n        value,\n        {\n          origin: \"sanity.io\",\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n            ...!config.omitCrossDatasetReferenceData && { dataset, projectId }\n          })\n        },\n        // We use custom logic to determine if we should skip encoding\n        !1\n      );\n    }\n  );\n  if (logger) {\n    const isSkipping = report.skipped.length, isEncoding = report.encoded.length;\n    if ((isSkipping || isEncoding) && ((logger?.groupCollapsed || logger.log)?.(\"[@sanity/client]: Encoding source map into result\"), logger.log?.(\n      `[@sanity/client]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`\n    )), report.encoded.length > 0 && (logger?.log?.(\"[@sanity/client]: Table of encoded paths\"), (logger?.table || logger.log)?.(report.encoded)), report.skipped.length > 0) {\n      const skipped = /* @__PURE__ */ new Set();\n      for (const { path } of report.skipped)\n        skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n      logger?.log?.(\"[@sanity/client]: List of skipped paths\", [...skipped.values()]);\n    }\n    (isSkipping || isEncoding) && logger?.groupEnd?.();\n  }\n  return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n  return toString(jsonPathToStudioPath(path));\n}\nvar stegaEncodeSourceMap$1 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  stegaEncodeSourceMap\n});\n\n//# sourceMappingURL=stegaEncodeSourceMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L19jaHVua3MtZXMvc3RlZ2FFbmNvZGVTb3VyY2VNYXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPLEdBQUcsUUFBUTtBQUNsQztBQUNBLGdCQUFnQixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsUUFBUTtBQUN0RDtBQUNBLGdCQUFnQixPQUFPLFVBQVUsYUFBYTtBQUM5QztBQUNBO0FBQ0EsZ0JBQWdCLE9BQU8sR0FBRyxLQUFLLEdBQUcsR0FBRztBQUNyQztBQUNBLGtEQUFrRCx3QkFBd0I7QUFDMUUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBd0QsNERBQTRELHVDQUF1QyxRQUFRLDBDQUEwQyx5REFBeUQsV0FBVyxlQUFlLGFBQWE7QUFDMVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVDQUF1QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxtQkFBbUI7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxHQUFHO0FBQ2IsWUFBWSxLQUFLO0FBQ2pCLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0EsMkNBQTJDLEtBQUssdUNBQXVDLG9CQUFvQixHQUFHLEdBQUcsYUFBYTtBQUM5SDtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsVUFBVSxJQUFJO0FBQ25IO0FBQ0EseUJBQXlCLCtCQUErQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMEJBQTBCO0FBQ3BDO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSSxLQUFLLGlDQUFpQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtDQUErQyxJQUFJLEtBQUssaUNBQWlDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxPQUFPLCtDQUErQztBQUN0RCxrREFBa0QsOERBQThELG9CQUFvQiw4REFBOEQ7QUFDbE07QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0MsRUFBRSw0Q0FBNEM7QUFDbEc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQixnQ0FBZ0MsRUFBRSw0Q0FBNEM7QUFDaEc7QUFDQSxPQUFPO0FBQ1AsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlFQUFpRTtBQUMvRSxhQUFhLGlEQUFDO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQixhQUFhLHNCQUFzQjtBQUNuRztBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBS0M7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3ljX2RpcmVjdG9yeS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L19jaHVua3MtZXMvc3RlZ2FFbmNvZGVTb3VyY2VNYXAuanM/NjBlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDIH0gZnJvbSBcIi4vc3RlZ2FDbGVhbi5qc1wiO1xuY29uc3QgcmVLZXlTZWdtZW50ID0gL19rZXlcXHMqPT1cXHMqWydcIl0oLiopWydcIl0vO1xuZnVuY3Rpb24gaXNLZXlTZWdtZW50KHNlZ21lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgPyByZUtleVNlZ21lbnQudGVzdChzZWdtZW50LnRyaW0oKSkgOiB0eXBlb2Ygc2VnbWVudCA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHNlZ21lbnQ7XG59XG5mdW5jdGlvbiB0b1N0cmluZyhwYXRoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIGlzIG5vdCBhbiBhcnJheVwiKTtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKCh0YXJnZXQsIHNlZ21lbnQsIGkpID0+IHtcbiAgICBjb25zdCBzZWdtZW50VHlwZSA9IHR5cGVvZiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50VHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9WyR7c2VnbWVudH1dYDtcbiAgICBpZiAoc2VnbWVudFR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fSR7aSA9PT0gMCA/IFwiXCIgOiBcIi5cIn0ke3NlZ21lbnR9YDtcbiAgICBpZiAoaXNLZXlTZWdtZW50KHNlZ21lbnQpICYmIHNlZ21lbnQuX2tleSlcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9W19rZXk9PVwiJHtzZWdtZW50Ll9rZXl9XCJdYDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZWdtZW50KSkge1xuICAgICAgY29uc3QgW2Zyb20sIHRvXSA9IHNlZ21lbnQ7XG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVske2Zyb219OiR7dG99XWA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGF0aCBzZWdtZW50IFxcYCR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9XFxgYCk7XG4gIH0sIFwiXCIpO1xufVxuY29uc3QgRVNDQVBFID0ge1xuICBcIlxcZlwiOiBcIlxcXFxmXCIsXG4gIFwiXFxuXCI6IFwiXFxcXG5cIixcbiAgXCJcXHJcIjogXCJcXFxcclwiLFxuICBcIlx0XCI6IFwiXFxcXHRcIixcbiAgXCInXCI6IFwiXFxcXCdcIixcbiAgXCJcXFxcXCI6IFwiXFxcXFxcXFxcIlxufSwgVU5FU0NBUEUgPSB7XG4gIFwiXFxcXGZcIjogXCJcXGZcIixcbiAgXCJcXFxcblwiOiBgXG5gLFxuICBcIlxcXFxyXCI6IFwiXFxyXCIsXG4gIFwiXFxcXHRcIjogXCJcdFwiLFxuICBcIlxcXFwnXCI6IFwiJ1wiLFxuICBcIlxcXFxcXFxcXCI6IFwiXFxcXFwiXG59O1xuZnVuY3Rpb24ganNvblBhdGgocGF0aCkge1xuICByZXR1cm4gYCQke3BhdGgubWFwKChzZWdtZW50KSA9PiB0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiID8gYFsnJHtzZWdtZW50LnJlcGxhY2UoL1tcXGZcXG5cXHJcXHQnXFxcXF0vZywgKG1hdGNoKSA9PiBFU0NBUEVbbWF0Y2hdKX0nXWAgOiB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiID8gYFske3NlZ21lbnR9XWAgOiBzZWdtZW50Ll9rZXkgIT09IFwiXCIgPyBgWz8oQC5fa2V5PT0nJHtzZWdtZW50Ll9rZXkucmVwbGFjZSgvWydcXFxcXS9nLCAobWF0Y2gpID0+IEVTQ0FQRVttYXRjaF0pfScpXWAgOiBgWyR7c2VnbWVudC5faW5kZXh9XWApLmpvaW4oXCJcIil9YDtcbn1cbmZ1bmN0aW9uIHBhcnNlSnNvblBhdGgocGF0aCkge1xuICBjb25zdCBwYXJzZWQgPSBbXSwgcGFyc2VSZSA9IC9cXFsnKC4qPyknXFxdfFxcWyhcXGQrKVxcXXxcXFtcXD9cXChAXFwuX2tleT09JyguKj8pJ1xcKVxcXS9nO1xuICBsZXQgbWF0Y2g7XG4gIGZvciAoOyAobWF0Y2ggPSBwYXJzZVJlLmV4ZWMocGF0aCkpICE9PSBudWxsOyApIHtcbiAgICBpZiAobWF0Y2hbMV0gIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qga2V5ID0gbWF0Y2hbMV0ucmVwbGFjZSgvXFxcXChcXFxcfGZ8bnxyfHR8JykvZywgKG0pID0+IFVORVNDQVBFW21dKTtcbiAgICAgIHBhcnNlZC5wdXNoKGtleSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzJdICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcnNlZC5wdXNoKHBhcnNlSW50KG1hdGNoWzJdLCAxMCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtYXRjaFszXSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBfa2V5ID0gbWF0Y2hbM10ucmVwbGFjZSgvXFxcXChcXFxcJykvZywgKG0pID0+IFVORVNDQVBFW21dKTtcbiAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgX2tleSxcbiAgICAgICAgX2luZGV4OiAtMVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbmZ1bmN0aW9uIGpzb25QYXRoVG9TdHVkaW9QYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubWFwKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50Ll9rZXkgIT09IFwiXCIpXG4gICAgICByZXR1cm4geyBfa2V5OiBzZWdtZW50Ll9rZXkgfTtcbiAgICBpZiAoc2VnbWVudC5faW5kZXggIT09IC0xKVxuICAgICAgcmV0dXJuIHNlZ21lbnQuX2luZGV4O1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzZWdtZW50OiR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9YCk7XG4gIH0pO1xufVxuZnVuY3Rpb24ganNvblBhdGhUb01hcHBpbmdQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubWFwKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50Ll9pbmRleCAhPT0gLTEpXG4gICAgICByZXR1cm4gc2VnbWVudC5faW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNlZ21lbnQ6JHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1gKTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNvbHZlTWFwcGluZyhyZXN1bHRQYXRoLCBjc20pIHtcbiAgaWYgKCFjc20/Lm1hcHBpbmdzKVxuICAgIHJldHVybjtcbiAgY29uc3QgcmVzdWx0TWFwcGluZ1BhdGggPSBqc29uUGF0aChqc29uUGF0aFRvTWFwcGluZ1BhdGgocmVzdWx0UGF0aCkpO1xuICBpZiAoY3NtLm1hcHBpbmdzW3Jlc3VsdE1hcHBpbmdQYXRoXSAhPT0gdm9pZCAwKVxuICAgIHJldHVybiB7XG4gICAgICBtYXBwaW5nOiBjc20ubWFwcGluZ3NbcmVzdWx0TWFwcGluZ1BhdGhdLFxuICAgICAgbWF0Y2hlZFBhdGg6IHJlc3VsdE1hcHBpbmdQYXRoLFxuICAgICAgcGF0aFN1ZmZpeDogXCJcIlxuICAgIH07XG4gIGNvbnN0IG1hcHBpbmdzID0gT2JqZWN0LmVudHJpZXMoY3NtLm1hcHBpbmdzKS5maWx0ZXIoKFtrZXldKSA9PiByZXN1bHRNYXBwaW5nUGF0aC5zdGFydHNXaXRoKGtleSkpLnNvcnQoKFtrZXkxXSwgW2tleTJdKSA9PiBrZXkyLmxlbmd0aCAtIGtleTEubGVuZ3RoKTtcbiAgaWYgKG1hcHBpbmdzLmxlbmd0aCA9PSAwKVxuICAgIHJldHVybjtcbiAgY29uc3QgW21hdGNoZWRQYXRoLCBtYXBwaW5nXSA9IG1hcHBpbmdzWzBdLCBwYXRoU3VmZml4ID0gcmVzdWx0TWFwcGluZ1BhdGguc3Vic3RyaW5nKG1hdGNoZWRQYXRoLmxlbmd0aCk7XG4gIHJldHVybiB7IG1hcHBpbmcsIG1hdGNoZWRQYXRoLCBwYXRoU3VmZml4IH07XG59XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHdhbGtNYXAodmFsdWUsIG1hcHBpbmdGbiwgcGF0aCA9IFtdKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpZHgpID0+IHtcbiAgICAgIGlmIChpc1JlY29yZCh2KSkge1xuICAgICAgICBjb25zdCBfa2V5ID0gdi5fa2V5O1xuICAgICAgICBpZiAodHlwZW9mIF9rZXkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KHsgX2tleSwgX2luZGV4OiBpZHggfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhbGtNYXAodiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChpZHgpKTtcbiAgICB9KTtcbiAgaWYgKGlzUmVjb3JkKHZhbHVlKSkge1xuICAgIGlmICh2YWx1ZS5fdHlwZSA9PT0gXCJibG9ja1wiIHx8IHZhbHVlLl90eXBlID09PSBcInNwYW5cIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0geyAuLi52YWx1ZSB9O1xuICAgICAgcmV0dXJuIHZhbHVlLl90eXBlID09PSBcImJsb2NrXCIgPyByZXN1bHQuY2hpbGRyZW4gPSB3YWxrTWFwKHZhbHVlLmNoaWxkcmVuLCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KFwiY2hpbGRyZW5cIikpIDogdmFsdWUuX3R5cGUgPT09IFwic3BhblwiICYmIChyZXN1bHQudGV4dCA9IHdhbGtNYXAodmFsdWUudGV4dCwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChcInRleHRcIikpKSwgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW2ssIHZdKSA9PiBbaywgd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KGspKV0pXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbWFwcGluZ0ZuKHZhbHVlLCBwYXRoKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUludG9SZXN1bHQocmVzdWx0LCBjc20sIGVuY29kZXIpIHtcbiAgcmV0dXJuIHdhbGtNYXAocmVzdWx0LCAodmFsdWUsIHBhdGgpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgcmVzb2x2ZU1hcHBpbmdSZXN1bHQgPSByZXNvbHZlTWFwcGluZyhwYXRoLCBjc20pO1xuICAgIGlmICghcmVzb2x2ZU1hcHBpbmdSZXN1bHQpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgeyBtYXBwaW5nLCBtYXRjaGVkUGF0aCB9ID0gcmVzb2x2ZU1hcHBpbmdSZXN1bHQ7XG4gICAgaWYgKG1hcHBpbmcudHlwZSAhPT0gXCJ2YWx1ZVwiIHx8IG1hcHBpbmcuc291cmNlLnR5cGUgIT09IFwiZG9jdW1lbnRWYWx1ZVwiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHNvdXJjZURvY3VtZW50ID0gY3NtLmRvY3VtZW50c1ttYXBwaW5nLnNvdXJjZS5kb2N1bWVudF0sIHNvdXJjZVBhdGggPSBjc20ucGF0aHNbbWFwcGluZy5zb3VyY2UucGF0aF0sIG1hdGNoUGF0aFNlZ21lbnRzID0gcGFyc2VKc29uUGF0aChtYXRjaGVkUGF0aCksIGZ1bGxTb3VyY2VTZWdtZW50cyA9IHBhcnNlSnNvblBhdGgoc291cmNlUGF0aCkuY29uY2F0KHBhdGguc2xpY2UobWF0Y2hQYXRoU2VnbWVudHMubGVuZ3RoKSk7XG4gICAgcmV0dXJuIGVuY29kZXIoe1xuICAgICAgc291cmNlUGF0aDogZnVsbFNvdXJjZVNlZ21lbnRzLFxuICAgICAgc291cmNlRG9jdW1lbnQsXG4gICAgICByZXN1bHRQYXRoOiBwYXRoLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfSk7XG59XG5jb25zdCBEUkFGVFNfUFJFRklYID0gXCJkcmFmdHMuXCI7XG5mdW5jdGlvbiBnZXRQdWJsaXNoZWRJZChpZCkge1xuICByZXR1cm4gaWQuc3RhcnRzV2l0aChEUkFGVFNfUFJFRklYKSA/IGlkLnNsaWNlKERSQUZUU19QUkVGSVgubGVuZ3RoKSA6IGlkO1xufVxuZnVuY3Rpb24gY3JlYXRlRWRpdFVybChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBiYXNlVXJsLFxuICAgIHdvcmtzcGFjZTogX3dvcmtzcGFjZSA9IFwiZGVmYXVsdFwiLFxuICAgIHRvb2w6IF90b29sID0gXCJkZWZhdWx0XCIsXG4gICAgaWQ6IF9pZCxcbiAgICB0eXBlLFxuICAgIHBhdGgsXG4gICAgcHJvamVjdElkLFxuICAgIGRhdGFzZXRcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghYmFzZVVybClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYXNlVXJsIGlzIHJlcXVpcmVkXCIpO1xuICBpZiAoIXBhdGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicGF0aCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKCFfaWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaWQgaXMgcmVxdWlyZWRcIik7XG4gIGlmIChiYXNlVXJsICE9PSBcIi9cIiAmJiBiYXNlVXJsLmVuZHNXaXRoKFwiL1wiKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYXNlVXJsIG11c3Qgbm90IGVuZCB3aXRoIGEgc2xhc2hcIik7XG4gIGNvbnN0IHdvcmtzcGFjZSA9IF93b3Jrc3BhY2UgPT09IFwiZGVmYXVsdFwiID8gdm9pZCAwIDogX3dvcmtzcGFjZSwgdG9vbCA9IF90b29sID09PSBcImRlZmF1bHRcIiA/IHZvaWQgMCA6IF90b29sLCBpZCA9IGdldFB1Ymxpc2hlZElkKF9pZCksIHN0cmluZ2lmaWVkUGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyB0b1N0cmluZyhqc29uUGF0aFRvU3R1ZGlvUGF0aChwYXRoKSkgOiBwYXRoLCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICBiYXNlVXJsLFxuICAgIGlkLFxuICAgIHR5cGUsXG4gICAgcGF0aDogc3RyaW5naWZpZWRQYXRoXG4gIH0pO1xuICB3b3Jrc3BhY2UgJiYgc2VhcmNoUGFyYW1zLnNldChcIndvcmtzcGFjZVwiLCB3b3Jrc3BhY2UpLCB0b29sICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJ0b29sXCIsIHRvb2wpLCBwcm9qZWN0SWQgJiYgc2VhcmNoUGFyYW1zLnNldChcInByb2plY3RJZFwiLCBwcm9qZWN0SWQpLCBkYXRhc2V0ICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJkYXRhc2V0XCIsIGRhdGFzZXQpLCBfaWQuc3RhcnRzV2l0aChEUkFGVFNfUFJFRklYKSAmJiBzZWFyY2hQYXJhbXMuc2V0KFwiaXNEcmFmdFwiLCBcIlwiKTtcbiAgY29uc3Qgc2VnbWVudHMgPSBbYmFzZVVybCA9PT0gXCIvXCIgPyBcIlwiIDogYmFzZVVybF07XG4gIHdvcmtzcGFjZSAmJiBzZWdtZW50cy5wdXNoKHdvcmtzcGFjZSk7XG4gIGNvbnN0IHJvdXRlclBhcmFtcyA9IFtcbiAgICBcIm1vZGU9cHJlc2VudGF0aW9uXCIsXG4gICAgYGlkPSR7aWR9YCxcbiAgICBgdHlwZT0ke3R5cGV9YCxcbiAgICBgcGF0aD0ke2VuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZmllZFBhdGgpfWBcbiAgXTtcbiAgcmV0dXJuIHRvb2wgJiYgcm91dGVyUGFyYW1zLnB1c2goYHRvb2w9JHt0b29sfWApLCBzZWdtZW50cy5wdXNoKFwiaW50ZW50XCIsIFwiZWRpdFwiLCBgJHtyb3V0ZXJQYXJhbXMuam9pbihcIjtcIil9PyR7c2VhcmNoUGFyYW1zfWApLCBzZWdtZW50cy5qb2luKFwiL1wiKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTdHVkaW9CYXNlUm91dGUoc3R1ZGlvVXJsKSB7XG4gIGxldCBiYXNlVXJsID0gdHlwZW9mIHN0dWRpb1VybCA9PSBcInN0cmluZ1wiID8gc3R1ZGlvVXJsIDogc3R1ZGlvVXJsLmJhc2VVcmw7XG4gIHJldHVybiBiYXNlVXJsICE9PSBcIi9cIiAmJiAoYmFzZVVybCA9IGJhc2VVcmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpKSwgdHlwZW9mIHN0dWRpb1VybCA9PSBcInN0cmluZ1wiID8geyBiYXNlVXJsIH0gOiB7IC4uLnN0dWRpb1VybCwgYmFzZVVybCB9O1xufVxuY29uc3QgZmlsdGVyRGVmYXVsdCA9ICh7IHNvdXJjZVBhdGgsIHJlc3VsdFBhdGgsIHZhbHVlIH0pID0+IHtcbiAgaWYgKGlzVmFsaWREYXRlKHZhbHVlKSB8fCBpc1ZhbGlkVVJMKHZhbHVlKSlcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IGVuZFBhdGggPSBzb3VyY2VQYXRoLmF0KC0xKTtcbiAgcmV0dXJuICEoc291cmNlUGF0aC5hdCgtMikgPT09IFwic2x1Z1wiICYmIGVuZFBhdGggPT09IFwiY3VycmVudFwiIHx8IHR5cGVvZiBlbmRQYXRoID09IFwic3RyaW5nXCIgJiYgKGVuZFBhdGguc3RhcnRzV2l0aChcIl9cIikgfHwgZW5kUGF0aC5lbmRzV2l0aChcIklkXCIpKSB8fCBzb3VyY2VQYXRoLnNvbWUoXG4gICAgKHBhdGgpID0+IHBhdGggPT09IFwibWV0YVwiIHx8IHBhdGggPT09IFwibWV0YWRhdGFcIiB8fCBwYXRoID09PSBcIm9wZW5HcmFwaFwiIHx8IHBhdGggPT09IFwic2VvXCJcbiAgKSB8fCBoYXNUeXBlTGlrZShzb3VyY2VQYXRoKSB8fCBoYXNUeXBlTGlrZShyZXN1bHRQYXRoKSB8fCB0eXBlb2YgZW5kUGF0aCA9PSBcInN0cmluZ1wiICYmIGRlbnlsaXN0LmhhcyhlbmRQYXRoKSk7XG59LCBkZW55bGlzdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJjb2xvclwiLFxuICBcImNvbG91clwiLFxuICBcImN1cnJlbmN5XCIsXG4gIFwiZW1haWxcIixcbiAgXCJmb3JtYXRcIixcbiAgXCJnaWRcIixcbiAgXCJoZXhcIixcbiAgXCJocmVmXCIsXG4gIFwiaHNsXCIsXG4gIFwiaHNsYVwiLFxuICBcImljb25cIixcbiAgXCJpZFwiLFxuICBcImluZGV4XCIsXG4gIFwia2V5XCIsXG4gIFwibGFuZ3VhZ2VcIixcbiAgXCJsYXlvdXRcIixcbiAgXCJsaW5rXCIsXG4gIFwibGlua0FjdGlvblwiLFxuICBcImxvY2FsZVwiLFxuICBcImxxaXBcIixcbiAgXCJwYWdlXCIsXG4gIFwicGF0aFwiLFxuICBcInJlZlwiLFxuICBcInJnYlwiLFxuICBcInJnYmFcIixcbiAgXCJyb3V0ZVwiLFxuICBcInNlY3JldFwiLFxuICBcInNsdWdcIixcbiAgXCJzdGF0dXNcIixcbiAgXCJ0YWdcIixcbiAgXCJ0ZW1wbGF0ZVwiLFxuICBcInRoZW1lXCIsXG4gIFwidHlwZVwiLFxuICBcInRleHRUaGVtZVwiLFxuICBcInVuaXRcIixcbiAgXCJ1cmxcIixcbiAgXCJ1c2VybmFtZVwiLFxuICBcInZhcmlhbnRcIixcbiAgXCJ3ZWJzaXRlXCJcbl0pO1xuZnVuY3Rpb24gaXNWYWxpZERhdGUoZGF0ZVN0cmluZykge1xuICByZXR1cm4gL15cXGR7NH0tXFxkezJ9LVxcZHsyfS8udGVzdChkYXRlU3RyaW5nKSA/ICEhRGF0ZS5wYXJzZShkYXRlU3RyaW5nKSA6ICExO1xufVxuZnVuY3Rpb24gaXNWYWxpZFVSTCh1cmwpIHtcbiAgdHJ5IHtcbiAgICBuZXcgVVJMKHVybCwgdXJsLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCJodHRwczovL2FjbWUuY29tXCIgOiB2b2lkIDApO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gaGFzVHlwZUxpa2UocGF0aCkge1xuICByZXR1cm4gcGF0aC5zb21lKChzZWdtZW50KSA9PiB0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiICYmIHNlZ21lbnQubWF0Y2goL3R5cGUvaSkgIT09IG51bGwpO1xufVxuY29uc3QgVFJVTkNBVEVfTEVOR1RIID0gMjA7XG5mdW5jdGlvbiBzdGVnYUVuY29kZVNvdXJjZU1hcChyZXN1bHQsIHJlc3VsdFNvdXJjZU1hcCwgY29uZmlnKSB7XG4gIGNvbnN0IHsgZmlsdGVyLCBsb2dnZXIsIGVuYWJsZWQgfSA9IGNvbmZpZztcbiAgaWYgKCFlbmFibGVkKSB7XG4gICAgY29uc3QgbXNnID0gXCJjb25maWcuZW5hYmxlZCBtdXN0IGJlIHRydWUsIGRvbid0IGNhbGwgdGhpcyBmdW5jdGlvbiBvdGhlcndpc2VcIjtcbiAgICB0aHJvdyBsb2dnZXI/LmVycm9yPy4oYFtAc2FuaXR5L2NsaWVudF06ICR7bXNnfWAsIHsgcmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZyB9KSwgbmV3IFR5cGVFcnJvcihtc2cpO1xuICB9XG4gIGlmICghcmVzdWx0U291cmNlTWFwKVxuICAgIHJldHVybiBsb2dnZXI/LmVycm9yPy4oXCJbQHNhbml0eS9jbGllbnRdOiBNaXNzaW5nIENvbnRlbnQgU291cmNlIE1hcCBmcm9tIHJlc3BvbnNlIGJvZHlcIiwge1xuICAgICAgcmVzdWx0LFxuICAgICAgcmVzdWx0U291cmNlTWFwLFxuICAgICAgY29uZmlnXG4gICAgfSksIHJlc3VsdDtcbiAgaWYgKCFjb25maWcuc3R1ZGlvVXJsKSB7XG4gICAgY29uc3QgbXNnID0gXCJjb25maWcuc3R1ZGlvVXJsIG11c3QgYmUgZGVmaW5lZFwiO1xuICAgIHRocm93IGxvZ2dlcj8uZXJyb3I/LihgW0BzYW5pdHkvY2xpZW50XTogJHttc2d9YCwgeyByZXN1bHQsIHJlc3VsdFNvdXJjZU1hcCwgY29uZmlnIH0pLCBuZXcgVHlwZUVycm9yKG1zZyk7XG4gIH1cbiAgY29uc3QgcmVwb3J0ID0ge1xuICAgIGVuY29kZWQ6IFtdLFxuICAgIHNraXBwZWQ6IFtdXG4gIH0sIHJlc3VsdFdpdGhTdGVnYSA9IGVuY29kZUludG9SZXN1bHQoXG4gICAgcmVzdWx0LFxuICAgIHJlc3VsdFNvdXJjZU1hcCxcbiAgICAoeyBzb3VyY2VQYXRoLCBzb3VyY2VEb2N1bWVudCwgcmVzdWx0UGF0aCwgdmFsdWUgfSkgPT4ge1xuICAgICAgaWYgKCh0eXBlb2YgZmlsdGVyID09IFwiZnVuY3Rpb25cIiA/IGZpbHRlcih7IHNvdXJjZVBhdGgsIHJlc3VsdFBhdGgsIGZpbHRlckRlZmF1bHQsIHNvdXJjZURvY3VtZW50LCB2YWx1ZSB9KSA6IGZpbHRlckRlZmF1bHQoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCBmaWx0ZXJEZWZhdWx0LCBzb3VyY2VEb2N1bWVudCwgdmFsdWUgfSkpID09PSAhMSlcbiAgICAgICAgcmV0dXJuIGxvZ2dlciAmJiByZXBvcnQuc2tpcHBlZC5wdXNoKHtcbiAgICAgICAgICBwYXRoOiBwcmV0dHlQYXRoRm9yTG9nZ2luZyhzb3VyY2VQYXRoKSxcbiAgICAgICAgICB2YWx1ZTogYCR7dmFsdWUuc2xpY2UoMCwgVFJVTkNBVEVfTEVOR1RIKX0ke3ZhbHVlLmxlbmd0aCA+IFRSVU5DQVRFX0xFTkdUSCA/IFwiLi4uXCIgOiBcIlwifWAsXG4gICAgICAgICAgbGVuZ3RoOiB2YWx1ZS5sZW5ndGhcbiAgICAgICAgfSksIHZhbHVlO1xuICAgICAgbG9nZ2VyICYmIHJlcG9ydC5lbmNvZGVkLnB1c2goe1xuICAgICAgICBwYXRoOiBwcmV0dHlQYXRoRm9yTG9nZ2luZyhzb3VyY2VQYXRoKSxcbiAgICAgICAgdmFsdWU6IGAke3ZhbHVlLnNsaWNlKDAsIFRSVU5DQVRFX0xFTkdUSCl9JHt2YWx1ZS5sZW5ndGggPiBUUlVOQ0FURV9MRU5HVEggPyBcIi4uLlwiIDogXCJcIn1gLFxuICAgICAgICBsZW5ndGg6IHZhbHVlLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7IGJhc2VVcmwsIHdvcmtzcGFjZSwgdG9vbCB9ID0gcmVzb2x2ZVN0dWRpb0Jhc2VSb3V0ZShcbiAgICAgICAgdHlwZW9mIGNvbmZpZy5zdHVkaW9VcmwgPT0gXCJmdW5jdGlvblwiID8gY29uZmlnLnN0dWRpb1VybChzb3VyY2VEb2N1bWVudCkgOiBjb25maWcuc3R1ZGlvVXJsXG4gICAgICApO1xuICAgICAgaWYgKCFiYXNlVXJsKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICBjb25zdCB7IF9pZDogaWQsIF90eXBlOiB0eXBlLCBfcHJvamVjdElkOiBwcm9qZWN0SWQsIF9kYXRhc2V0OiBkYXRhc2V0IH0gPSBzb3VyY2VEb2N1bWVudDtcbiAgICAgIHJldHVybiBDKFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAge1xuICAgICAgICAgIG9yaWdpbjogXCJzYW5pdHkuaW9cIixcbiAgICAgICAgICBocmVmOiBjcmVhdGVFZGl0VXJsKHtcbiAgICAgICAgICAgIGJhc2VVcmwsXG4gICAgICAgICAgICB3b3Jrc3BhY2UsXG4gICAgICAgICAgICB0b29sLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGF0aDogc291cmNlUGF0aCxcbiAgICAgICAgICAgIC4uLiFjb25maWcub21pdENyb3NzRGF0YXNldFJlZmVyZW5jZURhdGEgJiYgeyBkYXRhc2V0LCBwcm9qZWN0SWQgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFdlIHVzZSBjdXN0b20gbG9naWMgdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBza2lwIGVuY29kaW5nXG4gICAgICAgICExXG4gICAgICApO1xuICAgIH1cbiAgKTtcbiAgaWYgKGxvZ2dlcikge1xuICAgIGNvbnN0IGlzU2tpcHBpbmcgPSByZXBvcnQuc2tpcHBlZC5sZW5ndGgsIGlzRW5jb2RpbmcgPSByZXBvcnQuZW5jb2RlZC5sZW5ndGg7XG4gICAgaWYgKChpc1NraXBwaW5nIHx8IGlzRW5jb2RpbmcpICYmICgobG9nZ2VyPy5ncm91cENvbGxhcHNlZCB8fCBsb2dnZXIubG9nKT8uKFwiW0BzYW5pdHkvY2xpZW50XTogRW5jb2Rpbmcgc291cmNlIG1hcCBpbnRvIHJlc3VsdFwiKSwgbG9nZ2VyLmxvZz8uKFxuICAgICAgYFtAc2FuaXR5L2NsaWVudF06IFBhdGhzIGVuY29kZWQ6ICR7cmVwb3J0LmVuY29kZWQubGVuZ3RofSwgc2tpcHBlZDogJHtyZXBvcnQuc2tpcHBlZC5sZW5ndGh9YFxuICAgICkpLCByZXBvcnQuZW5jb2RlZC5sZW5ndGggPiAwICYmIChsb2dnZXI/LmxvZz8uKFwiW0BzYW5pdHkvY2xpZW50XTogVGFibGUgb2YgZW5jb2RlZCBwYXRoc1wiKSwgKGxvZ2dlcj8udGFibGUgfHwgbG9nZ2VyLmxvZyk/LihyZXBvcnQuZW5jb2RlZCkpLCByZXBvcnQuc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBza2lwcGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3QgeyBwYXRoIH0gb2YgcmVwb3J0LnNraXBwZWQpXG4gICAgICAgIHNraXBwZWQuYWRkKHBhdGgucmVwbGFjZShyZUtleVNlZ21lbnQsIFwiMFwiKS5yZXBsYWNlKC9cXFtcXGQrXFxdL2csIFwiW11cIikpO1xuICAgICAgbG9nZ2VyPy5sb2c/LihcIltAc2FuaXR5L2NsaWVudF06IExpc3Qgb2Ygc2tpcHBlZCBwYXRoc1wiLCBbLi4uc2tpcHBlZC52YWx1ZXMoKV0pO1xuICAgIH1cbiAgICAoaXNTa2lwcGluZyB8fCBpc0VuY29kaW5nKSAmJiBsb2dnZXI/Lmdyb3VwRW5kPy4oKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0V2l0aFN0ZWdhO1xufVxuZnVuY3Rpb24gcHJldHR5UGF0aEZvckxvZ2dpbmcocGF0aCkge1xuICByZXR1cm4gdG9TdHJpbmcoanNvblBhdGhUb1N0dWRpb1BhdGgocGF0aCkpO1xufVxudmFyIHN0ZWdhRW5jb2RlU291cmNlTWFwJDEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgc3RlZ2FFbmNvZGVTb3VyY2VNYXBcbn0pO1xuZXhwb3J0IHtcbiAgZW5jb2RlSW50b1Jlc3VsdCxcbiAgc3RlZ2FFbmNvZGVTb3VyY2VNYXAsXG4gIHN0ZWdhRW5jb2RlU291cmNlTWFwJDFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGVnYUVuY29kZVNvdXJjZU1hcC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeIntoResult: () => (/* binding */ encodeIntoResult),\n/* harmony export */   stegaEncodeSourceMap: () => (/* binding */ stegaEncodeSourceMap),\n/* harmony export */   stegaEncodeSourceMap$1: () => (/* binding */ stegaEncodeSourceMap$1)\n/* harmony export */ });\n/* harmony import */ var _stegaClean_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stegaClean.js */ \"(rsc)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\");\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\")\n      return `${target}[${segment}]`;\n    if (segmentType === \"string\")\n      return `${target}${i === 0 ? \"\" : \".\"}${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nconst ESCAPE = {\n  \"\\f\": \"\\\\f\",\n  \"\\n\": \"\\\\n\",\n  \"\\r\": \"\\\\r\",\n  \"\t\": \"\\\\t\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n}, UNESCAPE = {\n  \"\\\\f\": \"\\f\",\n  \"\\\\n\": `\n`,\n  \"\\\\r\": \"\\r\",\n  \"\\\\t\": \"\t\",\n  \"\\\\'\": \"'\",\n  \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n  return `$${path.map((segment) => typeof segment == \"string\" ? `['${segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => ESCAPE[match])}']` : typeof segment == \"number\" ? `[${segment}]` : segment._key !== \"\" ? `[?(@._key=='${segment._key.replace(/['\\\\]/g, (match) => ESCAPE[match])}')]` : `[${segment._index}]`).join(\"\")}`;\n}\nfunction parseJsonPath(path) {\n  const parsed = [], parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  for (; (match = parseRe.exec(path)) !== null; ) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => UNESCAPE[m]);\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => UNESCAPE[m]);\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._key !== \"\")\n      return { _key: segment._key };\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction resolveMapping(resultPath, csm) {\n  if (!csm?.mappings)\n    return;\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0)\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: \"\"\n    };\n  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);\n  if (mappings.length == 0)\n    return;\n  const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return { mapping, matchedPath, pathSuffix };\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction isRecord(value) {\n  return typeof value == \"object\" && value !== null;\n}\nfunction walkMap(value, mappingFn, path = []) {\n  if (isArray(value))\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v._key;\n        if (typeof _key == \"string\")\n          return walkMap(v, mappingFn, path.concat({ _key, _index: idx }));\n      }\n      return walkMap(v, mappingFn, path.concat(idx));\n    });\n  if (isRecord(value)) {\n    if (value._type === \"block\" || value._type === \"span\") {\n      const result = { ...value };\n      return value._type === \"block\" ? result.children = walkMap(value.children, mappingFn, path.concat(\"children\")) : value._type === \"span\" && (result.text = walkMap(value.text, mappingFn, path.concat(\"text\"))), result;\n    }\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))])\n    );\n  }\n  return mappingFn(value, path);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n  return walkMap(result, (value, path) => {\n    if (typeof value != \"string\")\n      return value;\n    const resolveMappingResult = resolveMapping(path, csm);\n    if (!resolveMappingResult)\n      return value;\n    const { mapping, matchedPath } = resolveMappingResult;\n    if (mapping.type !== \"value\" || mapping.source.type !== \"documentValue\")\n      return value;\n    const sourceDocument = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path], matchPathSegments = parseJsonPath(matchedPath), fullSourceSegments = parseJsonPath(sourcePath).concat(path.slice(matchPathSegments.length));\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value\n    });\n  });\n}\nconst DRAFTS_PREFIX = \"drafts.\";\nfunction getPublishedId(id) {\n  return id.startsWith(DRAFTS_PREFIX) ? id.slice(DRAFTS_PREFIX.length) : id;\n}\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path,\n    projectId,\n    dataset\n  } = options;\n  if (!baseUrl)\n    throw new Error(\"baseUrl is required\");\n  if (!path)\n    throw new Error(\"path is required\");\n  if (!_id)\n    throw new Error(\"id is required\");\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\"))\n    throw new Error(\"baseUrl must not end with a slash\");\n  const workspace = _workspace === \"default\" ? void 0 : _workspace, tool = _tool === \"default\" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath\n  });\n  workspace && searchParams.set(\"workspace\", workspace), tool && searchParams.set(\"tool\", tool), projectId && searchParams.set(\"projectId\", projectId), dataset && searchParams.set(\"dataset\", dataset), _id.startsWith(DRAFTS_PREFIX) && searchParams.set(\"isDraft\", \"\");\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  workspace && segments.push(workspace);\n  const routerParams = [\n    \"mode=presentation\",\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`\n  ];\n  return tool && routerParams.push(`tool=${tool}`), segments.push(\"intent\", \"edit\", `${routerParams.join(\";\")}?${searchParams}`), segments.join(\"/\");\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl == \"string\" ? studioUrl : studioUrl.baseUrl;\n  return baseUrl !== \"/\" && (baseUrl = baseUrl.replace(/\\/$/, \"\")), typeof studioUrl == \"string\" ? { baseUrl } : { ...studioUrl, baseUrl };\n}\nconst filterDefault = ({ sourcePath, resultPath, value }) => {\n  if (isValidDate(value) || isValidURL(value))\n    return !1;\n  const endPath = sourcePath.at(-1);\n  return !(sourcePath.at(-2) === \"slug\" && endPath === \"current\" || typeof endPath == \"string\" && (endPath.startsWith(\"_\") || endPath.endsWith(\"Id\")) || sourcePath.some(\n    (path) => path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\"\n  ) || hasTypeLike(sourcePath) || hasTypeLike(resultPath) || typeof endPath == \"string\" && denylist.has(endPath));\n}, denylist = /* @__PURE__ */ new Set([\n  \"color\",\n  \"colour\",\n  \"currency\",\n  \"email\",\n  \"format\",\n  \"gid\",\n  \"hex\",\n  \"href\",\n  \"hsl\",\n  \"hsla\",\n  \"icon\",\n  \"id\",\n  \"index\",\n  \"key\",\n  \"language\",\n  \"layout\",\n  \"link\",\n  \"linkAction\",\n  \"locale\",\n  \"lqip\",\n  \"page\",\n  \"path\",\n  \"ref\",\n  \"rgb\",\n  \"rgba\",\n  \"route\",\n  \"secret\",\n  \"slug\",\n  \"status\",\n  \"tag\",\n  \"template\",\n  \"theme\",\n  \"type\",\n  \"textTheme\",\n  \"unit\",\n  \"url\",\n  \"username\",\n  \"variant\",\n  \"website\"\n]);\nfunction isValidDate(dateString) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? !!Date.parse(dateString) : !1;\n}\nfunction isValidURL(url) {\n  try {\n    new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nfunction hasTypeLike(path) {\n  return path.some((segment) => typeof segment == \"string\" && segment.match(/type/i) !== null);\n}\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n  const { filter, logger, enabled } = config;\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  if (!resultSourceMap)\n    return logger?.error?.(\"[@sanity/client]: Missing Content Source Map from response body\", {\n      result,\n      resultSourceMap,\n      config\n    }), result;\n  if (!config.studioUrl) {\n    const msg = \"config.studioUrl must be defined\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  const report = {\n    encoded: [],\n    skipped: []\n  }, resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({ sourcePath, sourceDocument, resultPath, value }) => {\n      if ((typeof filter == \"function\" ? filter({ sourcePath, resultPath, filterDefault, sourceDocument, value }) : filterDefault({ sourcePath, resultPath, filterDefault, sourceDocument, value })) === !1)\n        return logger && report.skipped.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n          length: value.length\n        }), value;\n      logger && report.encoded.push({\n        path: prettyPathForLogging(sourcePath),\n        value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n        length: value.length\n      });\n      const { baseUrl, workspace, tool } = resolveStudioBaseRoute(\n        typeof config.studioUrl == \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl\n      );\n      if (!baseUrl)\n        return value;\n      const { _id: id, _type: type, _projectId: projectId, _dataset: dataset } = sourceDocument;\n      return (0,_stegaClean_js__WEBPACK_IMPORTED_MODULE_0__.C)(\n        value,\n        {\n          origin: \"sanity.io\",\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n            ...!config.omitCrossDatasetReferenceData && { dataset, projectId }\n          })\n        },\n        // We use custom logic to determine if we should skip encoding\n        !1\n      );\n    }\n  );\n  if (logger) {\n    const isSkipping = report.skipped.length, isEncoding = report.encoded.length;\n    if ((isSkipping || isEncoding) && ((logger?.groupCollapsed || logger.log)?.(\"[@sanity/client]: Encoding source map into result\"), logger.log?.(\n      `[@sanity/client]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`\n    )), report.encoded.length > 0 && (logger?.log?.(\"[@sanity/client]: Table of encoded paths\"), (logger?.table || logger.log)?.(report.encoded)), report.skipped.length > 0) {\n      const skipped = /* @__PURE__ */ new Set();\n      for (const { path } of report.skipped)\n        skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n      logger?.log?.(\"[@sanity/client]: List of skipped paths\", [...skipped.values()]);\n    }\n    (isSkipping || isEncoding) && logger?.groupEnd?.();\n  }\n  return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n  return toString(jsonPathToStudioPath(path));\n}\nvar stegaEncodeSourceMap$1 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  stegaEncodeSourceMap\n});\n\n//# sourceMappingURL=stegaEncodeSourceMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzLWVzL3N0ZWdhRW5jb2RlU291cmNlTWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTyxHQUFHLFFBQVE7QUFDbEM7QUFDQSxnQkFBZ0IsT0FBTyxFQUFFLG1CQUFtQixFQUFFLFFBQVE7QUFDdEQ7QUFDQSxnQkFBZ0IsT0FBTyxVQUFVLGFBQWE7QUFDOUM7QUFDQTtBQUNBLGdCQUFnQixPQUFPLEdBQUcsS0FBSyxHQUFHLEdBQUc7QUFDckM7QUFDQSxrREFBa0Qsd0JBQXdCO0FBQzFFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0RBQXdELDREQUE0RCx1Q0FBdUMsUUFBUSwwQ0FBMEMseURBQXlELFdBQVcsZUFBZSxhQUFhO0FBQzFUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1Q0FBdUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsbUJBQW1CO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRztBQUNiLFlBQVksS0FBSztBQUNqQixZQUFZLG9DQUFvQztBQUNoRDtBQUNBLDJDQUEyQyxLQUFLLHVDQUF1QyxvQkFBb0IsR0FBRyxHQUFHLGFBQWE7QUFDOUg7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLFVBQVUsSUFBSTtBQUNuSDtBQUNBLHlCQUF5QiwrQkFBK0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQztBQUNBO0FBQ0EsK0NBQStDLElBQUksS0FBSyxpQ0FBaUM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSSxLQUFLLGlDQUFpQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsT0FBTywrQ0FBK0M7QUFDdEQsa0RBQWtELDhEQUE4RCxvQkFBb0IsOERBQThEO0FBQ2xNO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDLEVBQUUsNENBQTRDO0FBQ2xHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDLEVBQUUsNENBQTRDO0FBQ2hHO0FBQ0EsT0FBTztBQUNQLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUU7QUFDL0UsYUFBYSxpREFBQztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsYUFBYSxzQkFBc0I7QUFDbkc7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUtDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95Y19kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzLWVzL3N0ZWdhRW5jb2RlU291cmNlTWFwLmpzPzBlMzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQyB9IGZyb20gXCIuL3N0ZWdhQ2xlYW4uanNcIjtcbmNvbnN0IHJlS2V5U2VnbWVudCA9IC9fa2V5XFxzKj09XFxzKlsnXCJdKC4qKVsnXCJdLztcbmZ1bmN0aW9uIGlzS2V5U2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiB0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiID8gcmVLZXlTZWdtZW50LnRlc3Qoc2VnbWVudC50cmltKCkpIDogdHlwZW9mIHNlZ21lbnQgPT0gXCJvYmplY3RcIiAmJiBcIl9rZXlcIiBpbiBzZWdtZW50O1xufVxuZnVuY3Rpb24gdG9TdHJpbmcocGF0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0aCBpcyBub3QgYW4gYXJyYXlcIik7XG4gIHJldHVybiBwYXRoLnJlZHVjZSgodGFyZ2V0LCBzZWdtZW50LCBpKSA9PiB7XG4gICAgY29uc3Qgc2VnbWVudFR5cGUgPSB0eXBlb2Ygc2VnbWVudDtcbiAgICBpZiAoc2VnbWVudFR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVske3NlZ21lbnR9XWA7XG4gICAgaWYgKHNlZ21lbnRUeXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIGAke3RhcmdldH0ke2kgPT09IDAgPyBcIlwiIDogXCIuXCJ9JHtzZWdtZW50fWA7XG4gICAgaWYgKGlzS2V5U2VnbWVudChzZWdtZW50KSAmJiBzZWdtZW50Ll9rZXkpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVtfa2V5PT1cIiR7c2VnbWVudC5fa2V5fVwiXWA7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2VnbWVudCkpIHtcbiAgICAgIGNvbnN0IFtmcm9tLCB0b10gPSBzZWdtZW50O1xuICAgICAgcmV0dXJuIGAke3RhcmdldH1bJHtmcm9tfToke3RvfV1gO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhdGggc2VnbWVudCBcXGAke0pTT04uc3RyaW5naWZ5KHNlZ21lbnQpfVxcYGApO1xuICB9LCBcIlwiKTtcbn1cbmNvbnN0IEVTQ0FQRSA9IHtcbiAgXCJcXGZcIjogXCJcXFxcZlwiLFxuICBcIlxcblwiOiBcIlxcXFxuXCIsXG4gIFwiXFxyXCI6IFwiXFxcXHJcIixcbiAgXCJcdFwiOiBcIlxcXFx0XCIsXG4gIFwiJ1wiOiBcIlxcXFwnXCIsXG4gIFwiXFxcXFwiOiBcIlxcXFxcXFxcXCJcbn0sIFVORVNDQVBFID0ge1xuICBcIlxcXFxmXCI6IFwiXFxmXCIsXG4gIFwiXFxcXG5cIjogYFxuYCxcbiAgXCJcXFxcclwiOiBcIlxcclwiLFxuICBcIlxcXFx0XCI6IFwiXHRcIixcbiAgXCJcXFxcJ1wiOiBcIidcIixcbiAgXCJcXFxcXFxcXFwiOiBcIlxcXFxcIlxufTtcbmZ1bmN0aW9uIGpzb25QYXRoKHBhdGgpIHtcbiAgcmV0dXJuIGAkJHtwYXRoLm1hcCgoc2VnbWVudCkgPT4gdHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiA/IGBbJyR7c2VnbWVudC5yZXBsYWNlKC9bXFxmXFxuXFxyXFx0J1xcXFxdL2csIChtYXRjaCkgPT4gRVNDQVBFW21hdGNoXSl9J11gIDogdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIiA/IGBbJHtzZWdtZW50fV1gIDogc2VnbWVudC5fa2V5ICE9PSBcIlwiID8gYFs/KEAuX2tleT09JyR7c2VnbWVudC5fa2V5LnJlcGxhY2UoL1snXFxcXF0vZywgKG1hdGNoKSA9PiBFU0NBUEVbbWF0Y2hdKX0nKV1gIDogYFske3NlZ21lbnQuX2luZGV4fV1gKS5qb2luKFwiXCIpfWA7XG59XG5mdW5jdGlvbiBwYXJzZUpzb25QYXRoKHBhdGgpIHtcbiAgY29uc3QgcGFyc2VkID0gW10sIHBhcnNlUmUgPSAvXFxbJyguKj8pJ1xcXXxcXFsoXFxkKylcXF18XFxbXFw/XFwoQFxcLl9rZXk9PScoLio/KSdcXClcXF0vZztcbiAgbGV0IG1hdGNoO1xuICBmb3IgKDsgKG1hdGNoID0gcGFyc2VSZS5leGVjKHBhdGgpKSAhPT0gbnVsbDsgKSB7XG4gICAgaWYgKG1hdGNoWzFdICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGtleSA9IG1hdGNoWzFdLnJlcGxhY2UoL1xcXFwoXFxcXHxmfG58cnx0fCcpL2csIChtKSA9PiBVTkVTQ0FQRVttXSk7XG4gICAgICBwYXJzZWQucHVzaChrZXkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtYXRjaFsyXSAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXJzZWQucHVzaChwYXJzZUludChtYXRjaFsyXSwgMTApKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbM10gIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgX2tleSA9IG1hdGNoWzNdLnJlcGxhY2UoL1xcXFwoXFxcXCcpL2csIChtKSA9PiBVTkVTQ0FQRVttXSk7XG4gICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgIF9rZXksXG4gICAgICAgIF9pbmRleDogLTFcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5mdW5jdGlvbiBqc29uUGF0aFRvU3R1ZGlvUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBzZWdtZW50ID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gc2VnbWVudDtcbiAgICBpZiAoc2VnbWVudC5fa2V5ICE9PSBcIlwiKVxuICAgICAgcmV0dXJuIHsgX2tleTogc2VnbWVudC5fa2V5IH07XG4gICAgaWYgKHNlZ21lbnQuX2luZGV4ICE9PSAtMSlcbiAgICAgIHJldHVybiBzZWdtZW50Ll9pbmRleDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2VnbWVudDoke0pTT04uc3RyaW5naWZ5KHNlZ21lbnQpfWApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGpzb25QYXRoVG9NYXBwaW5nUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBzZWdtZW50ID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gc2VnbWVudDtcbiAgICBpZiAoc2VnbWVudC5faW5kZXggIT09IC0xKVxuICAgICAgcmV0dXJuIHNlZ21lbnQuX2luZGV4O1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzZWdtZW50OiR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9YCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU1hcHBpbmcocmVzdWx0UGF0aCwgY3NtKSB7XG4gIGlmICghY3NtPy5tYXBwaW5ncylcbiAgICByZXR1cm47XG4gIGNvbnN0IHJlc3VsdE1hcHBpbmdQYXRoID0ganNvblBhdGgoanNvblBhdGhUb01hcHBpbmdQYXRoKHJlc3VsdFBhdGgpKTtcbiAgaWYgKGNzbS5tYXBwaW5nc1tyZXN1bHRNYXBwaW5nUGF0aF0gIT09IHZvaWQgMClcbiAgICByZXR1cm4ge1xuICAgICAgbWFwcGluZzogY3NtLm1hcHBpbmdzW3Jlc3VsdE1hcHBpbmdQYXRoXSxcbiAgICAgIG1hdGNoZWRQYXRoOiByZXN1bHRNYXBwaW5nUGF0aCxcbiAgICAgIHBhdGhTdWZmaXg6IFwiXCJcbiAgICB9O1xuICBjb25zdCBtYXBwaW5ncyA9IE9iamVjdC5lbnRyaWVzKGNzbS5tYXBwaW5ncykuZmlsdGVyKChba2V5XSkgPT4gcmVzdWx0TWFwcGluZ1BhdGguc3RhcnRzV2l0aChrZXkpKS5zb3J0KChba2V5MV0sIFtrZXkyXSkgPT4ga2V5Mi5sZW5ndGggLSBrZXkxLmxlbmd0aCk7XG4gIGlmIChtYXBwaW5ncy5sZW5ndGggPT0gMClcbiAgICByZXR1cm47XG4gIGNvbnN0IFttYXRjaGVkUGF0aCwgbWFwcGluZ10gPSBtYXBwaW5nc1swXSwgcGF0aFN1ZmZpeCA9IHJlc3VsdE1hcHBpbmdQYXRoLnN1YnN0cmluZyhtYXRjaGVkUGF0aC5sZW5ndGgpO1xuICByZXR1cm4geyBtYXBwaW5nLCBtYXRjaGVkUGF0aCwgcGF0aFN1ZmZpeCB9O1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc1JlY29yZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiB3YWxrTWFwKHZhbHVlLCBtYXBwaW5nRm4sIHBhdGggPSBbXSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpXG4gICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaWR4KSA9PiB7XG4gICAgICBpZiAoaXNSZWNvcmQodikpIHtcbiAgICAgICAgY29uc3QgX2tleSA9IHYuX2tleTtcbiAgICAgICAgaWYgKHR5cGVvZiBfa2V5ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuIHdhbGtNYXAodiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdCh7IF9rZXksIF9pbmRleDogaWR4IH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YWxrTWFwKHYsIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoaWR4KSk7XG4gICAgfSk7XG4gIGlmIChpc1JlY29yZCh2YWx1ZSkpIHtcbiAgICBpZiAodmFsdWUuX3R5cGUgPT09IFwiYmxvY2tcIiB8fCB2YWx1ZS5fdHlwZSA9PT0gXCJzcGFuXCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHsgLi4udmFsdWUgfTtcbiAgICAgIHJldHVybiB2YWx1ZS5fdHlwZSA9PT0gXCJibG9ja1wiID8gcmVzdWx0LmNoaWxkcmVuID0gd2Fsa01hcCh2YWx1ZS5jaGlsZHJlbiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChcImNoaWxkcmVuXCIpKSA6IHZhbHVlLl90eXBlID09PSBcInNwYW5cIiAmJiAocmVzdWx0LnRleHQgPSB3YWxrTWFwKHZhbHVlLnRleHQsIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoXCJ0ZXh0XCIpKSksIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5tYXAoKFtrLCB2XSkgPT4gW2ssIHdhbGtNYXAodiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChrKSldKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG1hcHBpbmdGbih2YWx1ZSwgcGF0aCk7XG59XG5mdW5jdGlvbiBlbmNvZGVJbnRvUmVzdWx0KHJlc3VsdCwgY3NtLCBlbmNvZGVyKSB7XG4gIHJldHVybiB3YWxrTWFwKHJlc3VsdCwgKHZhbHVlLCBwYXRoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHJlc29sdmVNYXBwaW5nUmVzdWx0ID0gcmVzb2x2ZU1hcHBpbmcocGF0aCwgY3NtKTtcbiAgICBpZiAoIXJlc29sdmVNYXBwaW5nUmVzdWx0KVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHsgbWFwcGluZywgbWF0Y2hlZFBhdGggfSA9IHJlc29sdmVNYXBwaW5nUmVzdWx0O1xuICAgIGlmIChtYXBwaW5nLnR5cGUgIT09IFwidmFsdWVcIiB8fCBtYXBwaW5nLnNvdXJjZS50eXBlICE9PSBcImRvY3VtZW50VmFsdWVcIilcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCBzb3VyY2VEb2N1bWVudCA9IGNzbS5kb2N1bWVudHNbbWFwcGluZy5zb3VyY2UuZG9jdW1lbnRdLCBzb3VyY2VQYXRoID0gY3NtLnBhdGhzW21hcHBpbmcuc291cmNlLnBhdGhdLCBtYXRjaFBhdGhTZWdtZW50cyA9IHBhcnNlSnNvblBhdGgobWF0Y2hlZFBhdGgpLCBmdWxsU291cmNlU2VnbWVudHMgPSBwYXJzZUpzb25QYXRoKHNvdXJjZVBhdGgpLmNvbmNhdChwYXRoLnNsaWNlKG1hdGNoUGF0aFNlZ21lbnRzLmxlbmd0aCkpO1xuICAgIHJldHVybiBlbmNvZGVyKHtcbiAgICAgIHNvdXJjZVBhdGg6IGZ1bGxTb3VyY2VTZWdtZW50cyxcbiAgICAgIHNvdXJjZURvY3VtZW50LFxuICAgICAgcmVzdWx0UGF0aDogcGF0aCxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH0pO1xufVxuY29uc3QgRFJBRlRTX1BSRUZJWCA9IFwiZHJhZnRzLlwiO1xuZnVuY3Rpb24gZ2V0UHVibGlzaGVkSWQoaWQpIHtcbiAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoRFJBRlRTX1BSRUZJWCkgPyBpZC5zbGljZShEUkFGVFNfUFJFRklYLmxlbmd0aCkgOiBpZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVkaXRVcmwob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYmFzZVVybCxcbiAgICB3b3Jrc3BhY2U6IF93b3Jrc3BhY2UgPSBcImRlZmF1bHRcIixcbiAgICB0b29sOiBfdG9vbCA9IFwiZGVmYXVsdFwiLFxuICAgIGlkOiBfaWQsXG4gICAgdHlwZSxcbiAgICBwYXRoLFxuICAgIHByb2plY3RJZCxcbiAgICBkYXRhc2V0XG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIWJhc2VVcmwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZVVybCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKCFwYXRoKVxuICAgIHRocm93IG5ldyBFcnJvcihcInBhdGggaXMgcmVxdWlyZWRcIik7XG4gIGlmICghX2lkKVxuICAgIHRocm93IG5ldyBFcnJvcihcImlkIGlzIHJlcXVpcmVkXCIpO1xuICBpZiAoYmFzZVVybCAhPT0gXCIvXCIgJiYgYmFzZVVybC5lbmRzV2l0aChcIi9cIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZVVybCBtdXN0IG5vdCBlbmQgd2l0aCBhIHNsYXNoXCIpO1xuICBjb25zdCB3b3Jrc3BhY2UgPSBfd29ya3NwYWNlID09PSBcImRlZmF1bHRcIiA/IHZvaWQgMCA6IF93b3Jrc3BhY2UsIHRvb2wgPSBfdG9vbCA9PT0gXCJkZWZhdWx0XCIgPyB2b2lkIDAgOiBfdG9vbCwgaWQgPSBnZXRQdWJsaXNoZWRJZChfaWQpLCBzdHJpbmdpZmllZFBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gdG9TdHJpbmcoanNvblBhdGhUb1N0dWRpb1BhdGgocGF0aCkpIDogcGF0aCwgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgYmFzZVVybCxcbiAgICBpZCxcbiAgICB0eXBlLFxuICAgIHBhdGg6IHN0cmluZ2lmaWVkUGF0aFxuICB9KTtcbiAgd29ya3NwYWNlICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJ3b3Jrc3BhY2VcIiwgd29ya3NwYWNlKSwgdG9vbCAmJiBzZWFyY2hQYXJhbXMuc2V0KFwidG9vbFwiLCB0b29sKSwgcHJvamVjdElkICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJwcm9qZWN0SWRcIiwgcHJvamVjdElkKSwgZGF0YXNldCAmJiBzZWFyY2hQYXJhbXMuc2V0KFwiZGF0YXNldFwiLCBkYXRhc2V0KSwgX2lkLnN0YXJ0c1dpdGgoRFJBRlRTX1BSRUZJWCkgJiYgc2VhcmNoUGFyYW1zLnNldChcImlzRHJhZnRcIiwgXCJcIik7XG4gIGNvbnN0IHNlZ21lbnRzID0gW2Jhc2VVcmwgPT09IFwiL1wiID8gXCJcIiA6IGJhc2VVcmxdO1xuICB3b3Jrc3BhY2UgJiYgc2VnbWVudHMucHVzaCh3b3Jrc3BhY2UpO1xuICBjb25zdCByb3V0ZXJQYXJhbXMgPSBbXG4gICAgXCJtb2RlPXByZXNlbnRhdGlvblwiLFxuICAgIGBpZD0ke2lkfWAsXG4gICAgYHR5cGU9JHt0eXBlfWAsXG4gICAgYHBhdGg9JHtlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZpZWRQYXRoKX1gXG4gIF07XG4gIHJldHVybiB0b29sICYmIHJvdXRlclBhcmFtcy5wdXNoKGB0b29sPSR7dG9vbH1gKSwgc2VnbWVudHMucHVzaChcImludGVudFwiLCBcImVkaXRcIiwgYCR7cm91dGVyUGFyYW1zLmpvaW4oXCI7XCIpfT8ke3NlYXJjaFBhcmFtc31gKSwgc2VnbWVudHMuam9pbihcIi9cIik7XG59XG5mdW5jdGlvbiByZXNvbHZlU3R1ZGlvQmFzZVJvdXRlKHN0dWRpb1VybCkge1xuICBsZXQgYmFzZVVybCA9IHR5cGVvZiBzdHVkaW9VcmwgPT0gXCJzdHJpbmdcIiA/IHN0dWRpb1VybCA6IHN0dWRpb1VybC5iYXNlVXJsO1xuICByZXR1cm4gYmFzZVVybCAhPT0gXCIvXCIgJiYgKGJhc2VVcmwgPSBiYXNlVXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSksIHR5cGVvZiBzdHVkaW9VcmwgPT0gXCJzdHJpbmdcIiA/IHsgYmFzZVVybCB9IDogeyAuLi5zdHVkaW9VcmwsIGJhc2VVcmwgfTtcbn1cbmNvbnN0IGZpbHRlckRlZmF1bHQgPSAoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCB2YWx1ZSB9KSA9PiB7XG4gIGlmIChpc1ZhbGlkRGF0ZSh2YWx1ZSkgfHwgaXNWYWxpZFVSTCh2YWx1ZSkpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBlbmRQYXRoID0gc291cmNlUGF0aC5hdCgtMSk7XG4gIHJldHVybiAhKHNvdXJjZVBhdGguYXQoLTIpID09PSBcInNsdWdcIiAmJiBlbmRQYXRoID09PSBcImN1cnJlbnRcIiB8fCB0eXBlb2YgZW5kUGF0aCA9PSBcInN0cmluZ1wiICYmIChlbmRQYXRoLnN0YXJ0c1dpdGgoXCJfXCIpIHx8IGVuZFBhdGguZW5kc1dpdGgoXCJJZFwiKSkgfHwgc291cmNlUGF0aC5zb21lKFxuICAgIChwYXRoKSA9PiBwYXRoID09PSBcIm1ldGFcIiB8fCBwYXRoID09PSBcIm1ldGFkYXRhXCIgfHwgcGF0aCA9PT0gXCJvcGVuR3JhcGhcIiB8fCBwYXRoID09PSBcInNlb1wiXG4gICkgfHwgaGFzVHlwZUxpa2Uoc291cmNlUGF0aCkgfHwgaGFzVHlwZUxpa2UocmVzdWx0UGF0aCkgfHwgdHlwZW9mIGVuZFBhdGggPT0gXCJzdHJpbmdcIiAmJiBkZW55bGlzdC5oYXMoZW5kUGF0aCkpO1xufSwgZGVueWxpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiY29sb3JcIixcbiAgXCJjb2xvdXJcIixcbiAgXCJjdXJyZW5jeVwiLFxuICBcImVtYWlsXCIsXG4gIFwiZm9ybWF0XCIsXG4gIFwiZ2lkXCIsXG4gIFwiaGV4XCIsXG4gIFwiaHJlZlwiLFxuICBcImhzbFwiLFxuICBcImhzbGFcIixcbiAgXCJpY29uXCIsXG4gIFwiaWRcIixcbiAgXCJpbmRleFwiLFxuICBcImtleVwiLFxuICBcImxhbmd1YWdlXCIsXG4gIFwibGF5b3V0XCIsXG4gIFwibGlua1wiLFxuICBcImxpbmtBY3Rpb25cIixcbiAgXCJsb2NhbGVcIixcbiAgXCJscWlwXCIsXG4gIFwicGFnZVwiLFxuICBcInBhdGhcIixcbiAgXCJyZWZcIixcbiAgXCJyZ2JcIixcbiAgXCJyZ2JhXCIsXG4gIFwicm91dGVcIixcbiAgXCJzZWNyZXRcIixcbiAgXCJzbHVnXCIsXG4gIFwic3RhdHVzXCIsXG4gIFwidGFnXCIsXG4gIFwidGVtcGxhdGVcIixcbiAgXCJ0aGVtZVwiLFxuICBcInR5cGVcIixcbiAgXCJ0ZXh0VGhlbWVcIixcbiAgXCJ1bml0XCIsXG4gIFwidXJsXCIsXG4gIFwidXNlcm5hbWVcIixcbiAgXCJ2YXJpYW50XCIsXG4gIFwid2Vic2l0ZVwiXG5dKTtcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKGRhdGVTdHJpbmcpIHtcbiAgcmV0dXJuIC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0vLnRlc3QoZGF0ZVN0cmluZykgPyAhIURhdGUucGFyc2UoZGF0ZVN0cmluZykgOiAhMTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRVUkwodXJsKSB7XG4gIHRyeSB7XG4gICAgbmV3IFVSTCh1cmwsIHVybC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiaHR0cHM6Ly9hY21lLmNvbVwiIDogdm9pZCAwKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGhhc1R5cGVMaWtlKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc29tZSgoc2VnbWVudCkgPT4gdHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiAmJiBzZWdtZW50Lm1hdGNoKC90eXBlL2kpICE9PSBudWxsKTtcbn1cbmNvbnN0IFRSVU5DQVRFX0xFTkdUSCA9IDIwO1xuZnVuY3Rpb24gc3RlZ2FFbmNvZGVTb3VyY2VNYXAocmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZykge1xuICBjb25zdCB7IGZpbHRlciwgbG9nZ2VyLCBlbmFibGVkIH0gPSBjb25maWc7XG4gIGlmICghZW5hYmxlZCkge1xuICAgIGNvbnN0IG1zZyA9IFwiY29uZmlnLmVuYWJsZWQgbXVzdCBiZSB0cnVlLCBkb24ndCBjYWxsIHRoaXMgZnVuY3Rpb24gb3RoZXJ3aXNlXCI7XG4gICAgdGhyb3cgbG9nZ2VyPy5lcnJvcj8uKGBbQHNhbml0eS9jbGllbnRdOiAke21zZ31gLCB7IHJlc3VsdCwgcmVzdWx0U291cmNlTWFwLCBjb25maWcgfSksIG5ldyBUeXBlRXJyb3IobXNnKTtcbiAgfVxuICBpZiAoIXJlc3VsdFNvdXJjZU1hcClcbiAgICByZXR1cm4gbG9nZ2VyPy5lcnJvcj8uKFwiW0BzYW5pdHkvY2xpZW50XTogTWlzc2luZyBDb250ZW50IFNvdXJjZSBNYXAgZnJvbSByZXNwb25zZSBib2R5XCIsIHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHJlc3VsdFNvdXJjZU1hcCxcbiAgICAgIGNvbmZpZ1xuICAgIH0pLCByZXN1bHQ7XG4gIGlmICghY29uZmlnLnN0dWRpb1VybCkge1xuICAgIGNvbnN0IG1zZyA9IFwiY29uZmlnLnN0dWRpb1VybCBtdXN0IGJlIGRlZmluZWRcIjtcbiAgICB0aHJvdyBsb2dnZXI/LmVycm9yPy4oYFtAc2FuaXR5L2NsaWVudF06ICR7bXNnfWAsIHsgcmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZyB9KSwgbmV3IFR5cGVFcnJvcihtc2cpO1xuICB9XG4gIGNvbnN0IHJlcG9ydCA9IHtcbiAgICBlbmNvZGVkOiBbXSxcbiAgICBza2lwcGVkOiBbXVxuICB9LCByZXN1bHRXaXRoU3RlZ2EgPSBlbmNvZGVJbnRvUmVzdWx0KFxuICAgIHJlc3VsdCxcbiAgICByZXN1bHRTb3VyY2VNYXAsXG4gICAgKHsgc291cmNlUGF0aCwgc291cmNlRG9jdW1lbnQsIHJlc3VsdFBhdGgsIHZhbHVlIH0pID0+IHtcbiAgICAgIGlmICgodHlwZW9mIGZpbHRlciA9PSBcImZ1bmN0aW9uXCIgPyBmaWx0ZXIoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCBmaWx0ZXJEZWZhdWx0LCBzb3VyY2VEb2N1bWVudCwgdmFsdWUgfSkgOiBmaWx0ZXJEZWZhdWx0KHsgc291cmNlUGF0aCwgcmVzdWx0UGF0aCwgZmlsdGVyRGVmYXVsdCwgc291cmNlRG9jdW1lbnQsIHZhbHVlIH0pKSA9PT0gITEpXG4gICAgICAgIHJldHVybiBsb2dnZXIgJiYgcmVwb3J0LnNraXBwZWQucHVzaCh7XG4gICAgICAgICAgcGF0aDogcHJldHR5UGF0aEZvckxvZ2dpbmcoc291cmNlUGF0aCksXG4gICAgICAgICAgdmFsdWU6IGAke3ZhbHVlLnNsaWNlKDAsIFRSVU5DQVRFX0xFTkdUSCl9JHt2YWx1ZS5sZW5ndGggPiBUUlVOQ0FURV9MRU5HVEggPyBcIi4uLlwiIDogXCJcIn1gLFxuICAgICAgICAgIGxlbmd0aDogdmFsdWUubGVuZ3RoXG4gICAgICAgIH0pLCB2YWx1ZTtcbiAgICAgIGxvZ2dlciAmJiByZXBvcnQuZW5jb2RlZC5wdXNoKHtcbiAgICAgICAgcGF0aDogcHJldHR5UGF0aEZvckxvZ2dpbmcoc291cmNlUGF0aCksXG4gICAgICAgIHZhbHVlOiBgJHt2YWx1ZS5zbGljZSgwLCBUUlVOQ0FURV9MRU5HVEgpfSR7dmFsdWUubGVuZ3RoID4gVFJVTkNBVEVfTEVOR1RIID8gXCIuLi5cIiA6IFwiXCJ9YCxcbiAgICAgICAgbGVuZ3RoOiB2YWx1ZS5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyBiYXNlVXJsLCB3b3Jrc3BhY2UsIHRvb2wgfSA9IHJlc29sdmVTdHVkaW9CYXNlUm91dGUoXG4gICAgICAgIHR5cGVvZiBjb25maWcuc3R1ZGlvVXJsID09IFwiZnVuY3Rpb25cIiA/IGNvbmZpZy5zdHVkaW9Vcmwoc291cmNlRG9jdW1lbnQpIDogY29uZmlnLnN0dWRpb1VybFxuICAgICAgKTtcbiAgICAgIGlmICghYmFzZVVybClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgY29uc3QgeyBfaWQ6IGlkLCBfdHlwZTogdHlwZSwgX3Byb2plY3RJZDogcHJvamVjdElkLCBfZGF0YXNldDogZGF0YXNldCB9ID0gc291cmNlRG9jdW1lbnQ7XG4gICAgICByZXR1cm4gQyhcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW46IFwic2FuaXR5LmlvXCIsXG4gICAgICAgICAgaHJlZjogY3JlYXRlRWRpdFVybCh7XG4gICAgICAgICAgICBiYXNlVXJsLFxuICAgICAgICAgICAgd29ya3NwYWNlLFxuICAgICAgICAgICAgdG9vbCxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHBhdGg6IHNvdXJjZVBhdGgsXG4gICAgICAgICAgICAuLi4hY29uZmlnLm9taXRDcm9zc0RhdGFzZXRSZWZlcmVuY2VEYXRhICYmIHsgZGF0YXNldCwgcHJvamVjdElkIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvLyBXZSB1c2UgY3VzdG9tIGxvZ2ljIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGQgc2tpcCBlbmNvZGluZ1xuICAgICAgICAhMVxuICAgICAgKTtcbiAgICB9XG4gICk7XG4gIGlmIChsb2dnZXIpIHtcbiAgICBjb25zdCBpc1NraXBwaW5nID0gcmVwb3J0LnNraXBwZWQubGVuZ3RoLCBpc0VuY29kaW5nID0gcmVwb3J0LmVuY29kZWQubGVuZ3RoO1xuICAgIGlmICgoaXNTa2lwcGluZyB8fCBpc0VuY29kaW5nKSAmJiAoKGxvZ2dlcj8uZ3JvdXBDb2xsYXBzZWQgfHwgbG9nZ2VyLmxvZyk/LihcIltAc2FuaXR5L2NsaWVudF06IEVuY29kaW5nIHNvdXJjZSBtYXAgaW50byByZXN1bHRcIiksIGxvZ2dlci5sb2c/LihcbiAgICAgIGBbQHNhbml0eS9jbGllbnRdOiBQYXRocyBlbmNvZGVkOiAke3JlcG9ydC5lbmNvZGVkLmxlbmd0aH0sIHNraXBwZWQ6ICR7cmVwb3J0LnNraXBwZWQubGVuZ3RofWBcbiAgICApKSwgcmVwb3J0LmVuY29kZWQubGVuZ3RoID4gMCAmJiAobG9nZ2VyPy5sb2c/LihcIltAc2FuaXR5L2NsaWVudF06IFRhYmxlIG9mIGVuY29kZWQgcGF0aHNcIiksIChsb2dnZXI/LnRhYmxlIHx8IGxvZ2dlci5sb2cpPy4ocmVwb3J0LmVuY29kZWQpKSwgcmVwb3J0LnNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2tpcHBlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IHsgcGF0aCB9IG9mIHJlcG9ydC5za2lwcGVkKVxuICAgICAgICBza2lwcGVkLmFkZChwYXRoLnJlcGxhY2UocmVLZXlTZWdtZW50LCBcIjBcIikucmVwbGFjZSgvXFxbXFxkK1xcXS9nLCBcIltdXCIpKTtcbiAgICAgIGxvZ2dlcj8ubG9nPy4oXCJbQHNhbml0eS9jbGllbnRdOiBMaXN0IG9mIHNraXBwZWQgcGF0aHNcIiwgWy4uLnNraXBwZWQudmFsdWVzKCldKTtcbiAgICB9XG4gICAgKGlzU2tpcHBpbmcgfHwgaXNFbmNvZGluZykgJiYgbG9nZ2VyPy5ncm91cEVuZD8uKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFdpdGhTdGVnYTtcbn1cbmZ1bmN0aW9uIHByZXR0eVBhdGhGb3JMb2dnaW5nKHBhdGgpIHtcbiAgcmV0dXJuIHRvU3RyaW5nKGpzb25QYXRoVG9TdHVkaW9QYXRoKHBhdGgpKTtcbn1cbnZhciBzdGVnYUVuY29kZVNvdXJjZU1hcCQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHN0ZWdhRW5jb2RlU291cmNlTWFwXG59KTtcbmV4cG9ydCB7XG4gIGVuY29kZUludG9SZXN1bHQsXG4gIHN0ZWdhRW5jb2RlU291cmNlTWFwLFxuICBzdGVnYUVuY29kZVNvdXJjZU1hcCQxXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RlZ2FFbmNvZGVTb3VyY2VNYXAuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@sanity/client/dist/index.browser.js":
/*!***********************************************************!*\
  !*** ./node_modules/@sanity/client/dist/index.browser.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePatch: () => (/* binding */ BasePatch),\n/* harmony export */   BaseTransaction: () => (/* binding */ BaseTransaction),\n/* harmony export */   ClientError: () => (/* binding */ ClientError),\n/* harmony export */   CorsOriginError: () => (/* binding */ CorsOriginError),\n/* harmony export */   ObservablePatch: () => (/* binding */ ObservablePatch),\n/* harmony export */   ObservableSanityClient: () => (/* binding */ ObservableSanityClient),\n/* harmony export */   ObservableTransaction: () => (/* binding */ ObservableTransaction),\n/* harmony export */   Patch: () => (/* binding */ Patch),\n/* harmony export */   SanityClient: () => (/* binding */ SanityClient),\n/* harmony export */   ServerError: () => (/* binding */ ServerError),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   \"default\": () => (/* binding */ deprecatedCreateClient),\n/* harmony export */   requester: () => (/* binding */ requester),\n/* harmony export */   unstable__adapter: () => (/* reexport safe */ get_it__WEBPACK_IMPORTED_MODULE_0__.adapter),\n/* harmony export */   unstable__environment: () => (/* reexport safe */ get_it__WEBPACK_IMPORTED_MODULE_0__.environment),\n/* harmony export */   validateApiPerspective: () => (/* binding */ validateApiPerspective)\n/* harmony export */ });\n/* harmony import */ var get_it__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! get-it */ \"(action-browser)/./node_modules/get-it/dist/index.react-server.js\");\n/* harmony import */ var get_it_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! get-it/middleware */ \"(action-browser)/./node_modules/get-it/dist/middleware.browser.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \"(action-browser)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ \"(action-browser)/./node_modules/rxjs/dist/esm5/internal/observable/from.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ \"(action-browser)/./node_modules/rxjs/dist/esm5/internal/lastValueFrom.js\");\n/* harmony import */ var _chunks_es_stegaClean_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_chunks-es/stegaClean.js */ \"(action-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ \"(action-browser)/./node_modules/rxjs/dist/cjs/operators/index.js\");\n\n\n\n\n\n\nclass ClientError extends Error {\n  response;\n  statusCode = 400;\n  responseBody;\n  details;\n  constructor(res) {\n    const props = extractErrorProps(res);\n    super(props.message), Object.assign(this, props);\n  }\n}\nclass ServerError extends Error {\n  response;\n  statusCode = 500;\n  responseBody;\n  details;\n  constructor(res) {\n    const props = extractErrorProps(res);\n    super(props.message), Object.assign(this, props);\n  }\n}\nfunction extractErrorProps(res) {\n  const body = res.body, props = {\n    response: res,\n    statusCode: res.statusCode,\n    responseBody: stringifyBody(body, res),\n    message: \"\",\n    details: void 0\n  };\n  if (body.error && body.message)\n    return props.message = `${body.error} - ${body.message}`, props;\n  if (isMutationError(body) || isActionError(body)) {\n    const allItems = body.error.items || [], items = allItems.slice(0, 5).map((item) => item.error?.description).filter(Boolean);\n    let itemsStr = items.length ? `:\n- ${items.join(`\n- `)}` : \"\";\n    return allItems.length > 5 && (itemsStr += `\n...and ${allItems.length - 5} more`), props.message = `${body.error.description}${itemsStr}`, props.details = body.error, props;\n  }\n  return body.error && body.error.description ? (props.message = body.error.description, props.details = body.error, props) : (props.message = body.error || body.message || httpErrorMessage(res), props);\n}\nfunction isMutationError(body) {\n  return isPlainObject(body) && isPlainObject(body.error) && body.error.type === \"mutationError\" && typeof body.error.description == \"string\";\n}\nfunction isActionError(body) {\n  return isPlainObject(body) && isPlainObject(body.error) && body.error.type === \"actionError\" && typeof body.error.description == \"string\";\n}\nfunction isPlainObject(obj) {\n  return typeof obj == \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction httpErrorMessage(res) {\n  const statusMessage = res.statusMessage ? ` ${res.statusMessage}` : \"\";\n  return `${res.method}-request to ${res.url} resulted in HTTP ${res.statusCode}${statusMessage}`;\n}\nfunction stringifyBody(body, res) {\n  return (res.headers[\"content-type\"] || \"\").toLowerCase().indexOf(\"application/json\") !== -1 ? JSON.stringify(body, null, 2) : body;\n}\nclass CorsOriginError extends Error {\n  projectId;\n  addOriginUrl;\n  constructor({ projectId: projectId2 }) {\n    super(\"CorsOriginError\"), this.name = \"CorsOriginError\", this.projectId = projectId2;\n    const url = new URL(`https://sanity.io/manage/project/${projectId2}/api`);\n    if (typeof location < \"u\") {\n      const { origin } = location;\n      url.searchParams.set(\"cors\", \"add\"), url.searchParams.set(\"origin\", origin), this.addOriginUrl = url, this.message = `The current origin is not allowed to connect to the Live Content API. Add it here: ${url}`;\n    } else\n      this.message = `The current origin is not allowed to connect to the Live Content API. Change your configuration here: ${url}`;\n  }\n}\nconst httpError = {\n  onResponse: (res) => {\n    if (res.statusCode >= 500)\n      throw new ServerError(res);\n    if (res.statusCode >= 400)\n      throw new ClientError(res);\n    return res;\n  }\n}, printWarnings = {\n  onResponse: (res) => {\n    const warn = res.headers[\"x-sanity-warning\"];\n    return (Array.isArray(warn) ? warn : [warn]).filter(Boolean).forEach((msg) => console.warn(msg)), res;\n  }\n};\nfunction defineHttpRequest(envMiddleware2) {\n  return (0,get_it__WEBPACK_IMPORTED_MODULE_0__.getIt)([\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.retry)({ shouldRetry }),\n    ...envMiddleware2,\n    printWarnings,\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.jsonRequest)(),\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.jsonResponse)(),\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.progress)(),\n    httpError,\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.observable)({ implementation: rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable })\n  ]);\n}\nfunction shouldRetry(err, attempt, options) {\n  if (options.maxRetries === 0)\n    return !1;\n  const isSafe = options.method === \"GET\" || options.method === \"HEAD\", isQuery = (options.uri || options.url).startsWith(\"/data/query\"), isRetriableResponse = err.response && (err.response.statusCode === 429 || err.response.statusCode === 502 || err.response.statusCode === 503);\n  return (isSafe || isQuery) && isRetriableResponse ? !0 : get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.retry.shouldRetry(err, attempt, options);\n}\nconst BASE_URL = \"https://www.sanity.io/help/\";\nfunction generateHelpUrl(slug) {\n  return BASE_URL + slug;\n}\nconst VALID_ASSET_TYPES = [\"image\", \"file\"], VALID_INSERT_LOCATIONS = [\"before\", \"after\", \"replace\"], dataset = (name) => {\n  if (!/^(~[a-z0-9]{1}[-\\w]{0,63}|[a-z0-9]{1}[-\\w]{0,63})$/.test(name))\n    throw new Error(\n      \"Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters\"\n    );\n}, projectId = (id) => {\n  if (!/^[-a-z0-9]+$/i.test(id))\n    throw new Error(\"`projectId` can only contain only a-z, 0-9 and dashes\");\n}, validateAssetType = (type) => {\n  if (VALID_ASSET_TYPES.indexOf(type) === -1)\n    throw new Error(`Invalid asset type: ${type}. Must be one of ${VALID_ASSET_TYPES.join(\", \")}`);\n}, validateObject = (op, val) => {\n  if (val === null || typeof val != \"object\" || Array.isArray(val))\n    throw new Error(`${op}() takes an object of properties`);\n}, validateDocumentId = (op, id) => {\n  if (typeof id != \"string\" || !/^[a-z0-9_][a-z0-9_.-]{0,127}$/i.test(id) || id.includes(\"..\"))\n    throw new Error(`${op}(): \"${id}\" is not a valid document ID`);\n}, requireDocumentId = (op, doc) => {\n  if (!doc._id)\n    throw new Error(`${op}() requires that the document contains an ID (\"_id\" property)`);\n  validateDocumentId(op, doc._id);\n}, validateInsert = (at, selector, items) => {\n  const signature = \"insert(at, selector, items)\";\n  if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {\n    const valid = VALID_INSERT_LOCATIONS.map((loc) => `\"${loc}\"`).join(\", \");\n    throw new Error(`${signature} takes an \"at\"-argument which is one of: ${valid}`);\n  }\n  if (typeof selector != \"string\")\n    throw new Error(`${signature} takes a \"selector\"-argument which must be a string`);\n  if (!Array.isArray(items))\n    throw new Error(`${signature} takes an \"items\"-argument which must be an array`);\n}, hasDataset = (config) => {\n  if (!config.dataset)\n    throw new Error(\"`dataset` must be provided to perform queries\");\n  return config.dataset || \"\";\n}, requestTag = (tag) => {\n  if (typeof tag != \"string\" || !/^[a-z0-9._-]{1,75}$/i.test(tag))\n    throw new Error(\n      \"Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.\"\n    );\n  return tag;\n};\nfunction once(fn) {\n  let didCall = !1, returnValue;\n  return (...args) => (didCall || (returnValue = fn(...args), didCall = !0), returnValue);\n}\nconst createWarningPrinter = (message) => (\n  // eslint-disable-next-line no-console\n  once((...args) => console.warn(message.join(\" \"), ...args))\n), printCdnAndWithCredentialsWarning = createWarningPrinter([\n  \"Because you set `withCredentials` to true, we will override your `useCdn`\",\n  \"setting to be false since (cookie-based) credentials are never set on the CDN\"\n]), printCdnWarning = createWarningPrinter([\n  \"Since you haven't set a value for `useCdn`, we will deliver content using our\",\n  \"global, edge-cached API-CDN. If you wish to have content delivered faster, set\",\n  \"`useCdn: false` to use the Live API. Note: You may incur higher costs using the live API.\"\n]), printCdnPreviewDraftsWarning = createWarningPrinter([\n  \"The Sanity client is configured with the `perspective` set to `previewDrafts`, which doesn't support the API-CDN.\",\n  \"The Live API will be used instead. Set `useCdn: false` in your configuration to hide this warning.\"\n]), printBrowserTokenWarning = createWarningPrinter([\n  \"You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.\",\n  `See ${generateHelpUrl(\n    \"js-client-browser-token\"\n  )} for more information and how to hide this warning.`\n]), printNoApiVersionSpecifiedWarning = createWarningPrinter([\n  \"Using the Sanity client without specifying an API version is deprecated.\",\n  `See ${generateHelpUrl(\"js-client-api-version\")}`\n]), printNoDefaultExport = createWarningPrinter([\n  \"The default export of @sanity/client has been deprecated. Use the named export `createClient` instead.\"\n]), defaultCdnHost = \"apicdn.sanity.io\", defaultConfig = {\n  apiHost: \"https://api.sanity.io\",\n  apiVersion: \"1\",\n  useProjectHostname: !0,\n  stega: { enabled: !1 }\n}, LOCALHOSTS = [\"localhost\", \"127.0.0.1\", \"0.0.0.0\"], isLocal = (host) => LOCALHOSTS.indexOf(host) !== -1;\nfunction validateApiVersion(apiVersion) {\n  if (apiVersion === \"1\" || apiVersion === \"X\")\n    return;\n  const apiDate = new Date(apiVersion);\n  if (!(/^\\d{4}-\\d{2}-\\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0))\n    throw new Error(\"Invalid API version string, expected `1` or date in format `YYYY-MM-DD`\");\n}\nfunction validateApiPerspective(perspective) {\n  if (Array.isArray(perspective)) {\n    for (const perspectiveValue of perspective)\n      if (perspectiveValue !== \"published\" && perspectiveValue !== \"drafts\" && !(typeof perspectiveValue == \"string\" && perspectiveValue.startsWith(\"r\") && perspectiveValue !== \"raw\"))\n        throw new TypeError(\n          \"Invalid API perspective value, expected `published`, `drafts` or a valid release identifier string\"\n        );\n    return;\n  }\n  switch (perspective) {\n    case \"previewDrafts\":\n    case \"drafts\":\n    case \"published\":\n    case \"raw\":\n      return;\n    default:\n      throw new TypeError(\n        \"Invalid API perspective string, expected `published`, `previewDrafts` or `raw`\"\n      );\n  }\n}\nconst initConfig = (config, prevConfig) => {\n  const specifiedConfig = {\n    ...prevConfig,\n    ...config,\n    stega: {\n      ...typeof prevConfig.stega == \"boolean\" ? { enabled: prevConfig.stega } : prevConfig.stega || defaultConfig.stega,\n      ...typeof config.stega == \"boolean\" ? { enabled: config.stega } : config.stega || {}\n    }\n  };\n  specifiedConfig.apiVersion || printNoApiVersionSpecifiedWarning();\n  const newConfig = {\n    ...defaultConfig,\n    ...specifiedConfig\n  }, projectBased = newConfig.useProjectHostname;\n  if (typeof Promise > \"u\") {\n    const helpUrl = generateHelpUrl(\"js-client-promise-polyfill\");\n    throw new Error(`No native Promise-implementation found, polyfill needed - see ${helpUrl}`);\n  }\n  if (projectBased && !newConfig.projectId)\n    throw new Error(\"Configuration must contain `projectId`\");\n  if (typeof newConfig.perspective < \"u\" && validateApiPerspective(newConfig.perspective), \"encodeSourceMap\" in newConfig)\n    throw new Error(\n      \"It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMap' is not supported in '@sanity/client'. Did you mean 'stega.enabled'?\"\n    );\n  if (\"encodeSourceMapAtPath\" in newConfig)\n    throw new Error(\n      \"It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMapAtPath' is not supported in '@sanity/client'. Did you mean 'stega.filter'?\"\n    );\n  if (typeof newConfig.stega.enabled != \"boolean\")\n    throw new Error(`stega.enabled must be a boolean, received ${newConfig.stega.enabled}`);\n  if (newConfig.stega.enabled && newConfig.stega.studioUrl === void 0)\n    throw new Error(\"stega.studioUrl must be defined when stega.enabled is true\");\n  if (newConfig.stega.enabled && typeof newConfig.stega.studioUrl != \"string\" && typeof newConfig.stega.studioUrl != \"function\")\n    throw new Error(\n      `stega.studioUrl must be a string or a function, received ${newConfig.stega.studioUrl}`\n    );\n  const isBrowser = typeof window < \"u\" && window.location && window.location.hostname, isLocalhost = isBrowser && isLocal(window.location.hostname);\n  isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== !0 ? printBrowserTokenWarning() : typeof newConfig.useCdn > \"u\" && printCdnWarning(), projectBased && projectId(newConfig.projectId), newConfig.dataset && dataset(newConfig.dataset), \"requestTagPrefix\" in newConfig && (newConfig.requestTagPrefix = newConfig.requestTagPrefix ? requestTag(newConfig.requestTagPrefix).replace(/\\.+$/, \"\") : void 0), newConfig.apiVersion = `${newConfig.apiVersion}`.replace(/^v/, \"\"), newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost, newConfig.useCdn === !0 && newConfig.withCredentials && printCdnAndWithCredentialsWarning(), newConfig.useCdn = newConfig.useCdn !== !1 && !newConfig.withCredentials, validateApiVersion(newConfig.apiVersion);\n  const hostParts = newConfig.apiHost.split(\"://\", 2), protocol = hostParts[0], host = hostParts[1], cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;\n  return newConfig.useProjectHostname ? (newConfig.url = `${protocol}://${newConfig.projectId}.${host}/v${newConfig.apiVersion}`, newConfig.cdnUrl = `${protocol}://${newConfig.projectId}.${cdnHost}/v${newConfig.apiVersion}`) : (newConfig.url = `${newConfig.apiHost}/v${newConfig.apiVersion}`, newConfig.cdnUrl = newConfig.url), newConfig;\n};\nfunction getSelection(sel) {\n  if (typeof sel == \"string\")\n    return { id: sel };\n  if (Array.isArray(sel))\n    return { query: \"*[_id in $ids]\", params: { ids: sel } };\n  if (typeof sel == \"object\" && sel !== null && \"query\" in sel && typeof sel.query == \"string\")\n    return \"params\" in sel && typeof sel.params == \"object\" && sel.params !== null ? { query: sel.query, params: sel.params } : { query: sel.query };\n  const selectionOpts = [\n    \"* Document ID (<docId>)\",\n    \"* Array of document IDs\",\n    \"* Object containing `query`\"\n  ].join(`\n`);\n  throw new Error(`Unknown selection - must be one of:\n\n${selectionOpts}`);\n}\nclass BasePatch {\n  selection;\n  operations;\n  constructor(selection, operations = {}) {\n    this.selection = selection, this.operations = operations;\n  }\n  /**\n   * Sets the given attributes to the document. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */\n  set(attrs) {\n    return this._assign(\"set\", attrs);\n  }\n  /**\n   * Sets the given attributes to the document if they are not currently set. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */\n  setIfMissing(attrs) {\n    return this._assign(\"setIfMissing\", attrs);\n  }\n  /**\n   * Performs a \"diff-match-patch\" operation on the string attributes provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to perform operation on. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"dmp\"\\}\n   */\n  diffMatchPatch(attrs) {\n    return validateObject(\"diffMatchPatch\", attrs), this._assign(\"diffMatchPatch\", attrs);\n  }\n  /**\n   * Unsets the attribute paths provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attribute paths to unset.\n   */\n  unset(attrs) {\n    if (!Array.isArray(attrs))\n      throw new Error(\"unset(attrs) takes an array of attributes to unset, non-array given\");\n    return this.operations = Object.assign({}, this.operations, { unset: attrs }), this;\n  }\n  /**\n   * Increment a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to increment, values representing the number to increment by.\n   */\n  inc(attrs) {\n    return this._assign(\"inc\", attrs);\n  }\n  /**\n   * Decrement a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to decrement, values representing the number to decrement by.\n   */\n  dec(attrs) {\n    return this._assign(\"dec\", attrs);\n  }\n  /**\n   * Provides methods for modifying arrays, by inserting, appending and replacing elements via a JSONPath expression.\n   *\n   * @param at - Location to insert at, relative to the given selector, or 'replace' the matched path\n   * @param selector - JSONPath expression, eg `comments[-1]` or `blocks[_key==\"abc123\"]`\n   * @param items - Array of items to insert/replace\n   */\n  insert(at, selector, items) {\n    return validateInsert(at, selector, items), this._assign(\"insert\", { [at]: selector, items });\n  }\n  /**\n   * Append the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to append to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to append to the array\n   */\n  append(selector, items) {\n    return this.insert(\"after\", `${selector}[-1]`, items);\n  }\n  /**\n   * Prepend the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to prepend to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to prepend to the array\n   */\n  prepend(selector, items) {\n    return this.insert(\"before\", `${selector}[0]`, items);\n  }\n  /**\n   * Change the contents of an array by removing existing elements and/or adding new elements.\n   *\n   * @param selector - Attribute or JSONPath expression for array\n   * @param start - Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.x\n   * @param deleteCount - An integer indicating the number of old array elements to remove.\n   * @param items - The elements to add to the array, beginning at the start index. If you don't specify any elements, splice() will only remove elements from the array.\n   */\n  splice(selector, start, deleteCount, items) {\n    const delAll = typeof deleteCount > \"u\" || deleteCount === -1, startIndex = start < 0 ? start - 1 : start, delCount = delAll ? -1 : Math.max(0, start + deleteCount), delRange = startIndex < 0 && delCount >= 0 ? \"\" : delCount, rangeSelector = `${selector}[${startIndex}:${delRange}]`;\n    return this.insert(\"replace\", rangeSelector, items || []);\n  }\n  /**\n   * Adds a revision clause, preventing the document from being patched if the `_rev` property does not match the given value\n   *\n   * @param rev - Revision to lock the patch to\n   */\n  ifRevisionId(rev) {\n    return this.operations.ifRevisionID = rev, this;\n  }\n  /**\n   * Return a plain JSON representation of the patch\n   */\n  serialize() {\n    return { ...getSelection(this.selection), ...this.operations };\n  }\n  /**\n   * Return a plain JSON representation of the patch\n   */\n  toJSON() {\n    return this.serialize();\n  }\n  /**\n   * Clears the patch of all operations\n   */\n  reset() {\n    return this.operations = {}, this;\n  }\n  _assign(op, props, merge = !0) {\n    return validateObject(op, props), this.operations = Object.assign({}, this.operations, {\n      [op]: Object.assign({}, merge && this.operations[op] || {}, props)\n    }), this;\n  }\n  _set(op, props) {\n    return this._assign(op, props, !1);\n  }\n}\nclass ObservablePatch extends BasePatch {\n  #client;\n  constructor(selection, operations, client) {\n    super(selection, operations), this.#client = client;\n  }\n  /**\n   * Clones the patch\n   */\n  clone() {\n    return new ObservablePatch(this.selection, { ...this.operations }, this.#client);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method\"\n      );\n    const returnFirst = typeof this.selection == \"string\", opts = Object.assign({ returnFirst, returnDocuments: !0 }, options);\n    return this.#client.mutate({ patch: this.serialize() }, opts);\n  }\n}\nclass Patch extends BasePatch {\n  #client;\n  constructor(selection, operations, client) {\n    super(selection, operations), this.#client = client;\n  }\n  /**\n   * Clones the patch\n   */\n  clone() {\n    return new Patch(this.selection, { ...this.operations }, this.#client);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method\"\n      );\n    const returnFirst = typeof this.selection == \"string\", opts = Object.assign({ returnFirst, returnDocuments: !0 }, options);\n    return this.#client.mutate({ patch: this.serialize() }, opts);\n  }\n}\nconst defaultMutateOptions = { returnDocuments: !1 };\nclass BaseTransaction {\n  operations;\n  trxId;\n  constructor(operations = [], transactionId) {\n    this.operations = operations, this.trxId = transactionId;\n  }\n  /**\n   * Creates a new Sanity document. If `_id` is provided and already exists, the mutation will fail. If no `_id` is given, one will automatically be generated by the database.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create. Requires a `_type` property.\n   */\n  create(doc) {\n    return validateObject(\"create\", doc), this._add({ create: doc });\n  }\n  /**\n   * Creates a new Sanity document. If a document with the same `_id` already exists, the create operation will be ignored.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create if it does not already exist. Requires `_id` and `_type` properties.\n   */\n  createIfNotExists(doc) {\n    const op = \"createIfNotExists\";\n    return validateObject(op, doc), requireDocumentId(op, doc), this._add({ [op]: doc });\n  }\n  /**\n   * Creates a new Sanity document, or replaces an existing one if the same `_id` is already used.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create or replace. Requires `_id` and `_type` properties.\n   */\n  createOrReplace(doc) {\n    const op = \"createOrReplace\";\n    return validateObject(op, doc), requireDocumentId(op, doc), this._add({ [op]: doc });\n  }\n  /**\n   * Deletes the document with the given document ID\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param documentId - Document ID to delete\n   */\n  delete(documentId) {\n    return validateDocumentId(\"delete\", documentId), this._add({ delete: { id: documentId } });\n  }\n  transactionId(id) {\n    return id ? (this.trxId = id, this) : this.trxId;\n  }\n  /**\n   * Return a plain JSON representation of the transaction\n   */\n  serialize() {\n    return [...this.operations];\n  }\n  /**\n   * Return a plain JSON representation of the transaction\n   */\n  toJSON() {\n    return this.serialize();\n  }\n  /**\n   * Clears the transaction of all operations\n   */\n  reset() {\n    return this.operations = [], this;\n  }\n  _add(mut) {\n    return this.operations.push(mut), this;\n  }\n}\nclass Transaction extends BaseTransaction {\n  #client;\n  constructor(operations, client, transactionId) {\n    super(operations, transactionId), this.#client = client;\n  }\n  /**\n   * Clones the transaction\n   */\n  clone() {\n    return new Transaction([...this.operations], this.#client, this.trxId);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method\"\n      );\n    return this.#client.mutate(\n      this.serialize(),\n      Object.assign({ transactionId: this.trxId }, defaultMutateOptions, options || {})\n    );\n  }\n  patch(patchOrDocumentId, patchOps) {\n    const isBuilder = typeof patchOps == \"function\";\n    if (typeof patchOrDocumentId != \"string\" && patchOrDocumentId instanceof Patch)\n      return this._add({ patch: patchOrDocumentId.serialize() });\n    if (isBuilder) {\n      const patch = patchOps(new Patch(patchOrDocumentId, {}, this.#client));\n      if (!(patch instanceof Patch))\n        throw new Error(\"function passed to `patch()` must return the patch\");\n      return this._add({ patch: patch.serialize() });\n    }\n    return this._add({ patch: { id: patchOrDocumentId, ...patchOps } });\n  }\n}\nclass ObservableTransaction extends BaseTransaction {\n  #client;\n  constructor(operations, client, transactionId) {\n    super(operations, transactionId), this.#client = client;\n  }\n  /**\n   * Clones the transaction\n   */\n  clone() {\n    return new ObservableTransaction([...this.operations], this.#client, this.trxId);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method\"\n      );\n    return this.#client.mutate(\n      this.serialize(),\n      Object.assign({ transactionId: this.trxId }, defaultMutateOptions, options || {})\n    );\n  }\n  patch(patchOrDocumentId, patchOps) {\n    const isBuilder = typeof patchOps == \"function\";\n    if (typeof patchOrDocumentId != \"string\" && patchOrDocumentId instanceof ObservablePatch)\n      return this._add({ patch: patchOrDocumentId.serialize() });\n    if (isBuilder) {\n      const patch = patchOps(new ObservablePatch(patchOrDocumentId, {}, this.#client));\n      if (!(patch instanceof ObservablePatch))\n        throw new Error(\"function passed to `patch()` must return the patch\");\n      return this._add({ patch: patch.serialize() });\n    }\n    return this._add({ patch: { id: patchOrDocumentId, ...patchOps } });\n  }\n}\nconst projectHeader = \"X-Sanity-Project-ID\";\nfunction requestOptions(config, overrides = {}) {\n  const headers = {}, token = overrides.token || config.token;\n  token && (headers.Authorization = `Bearer ${token}`), !overrides.useGlobalApi && !config.useProjectHostname && config.projectId && (headers[projectHeader] = config.projectId);\n  const withCredentials = !!(typeof overrides.withCredentials > \"u\" ? config.token || config.withCredentials : overrides.withCredentials), timeout = typeof overrides.timeout > \"u\" ? config.timeout : overrides.timeout;\n  return Object.assign({}, overrides, {\n    headers: Object.assign({}, headers, overrides.headers || {}),\n    timeout: typeof timeout > \"u\" ? 5 * 60 * 1e3 : timeout,\n    proxy: overrides.proxy || config.proxy,\n    json: !0,\n    withCredentials,\n    fetch: typeof overrides.fetch == \"object\" && typeof config.fetch == \"object\" ? { ...config.fetch, ...overrides.fetch } : overrides.fetch || config.fetch\n  });\n}\nconst encodeQueryString = ({\n  query,\n  params = {},\n  options = {}\n}) => {\n  const searchParams = new URLSearchParams(), { tag, includeMutations, returnQuery, ...opts } = options;\n  tag && searchParams.append(\"tag\", tag), searchParams.append(\"query\", query);\n  for (const [key, value] of Object.entries(params))\n    searchParams.append(`$${key}`, JSON.stringify(value));\n  for (const [key, value] of Object.entries(opts))\n    value && searchParams.append(key, `${value}`);\n  return returnQuery === !1 && searchParams.append(\"returnQuery\", \"false\"), includeMutations === !1 && searchParams.append(\"includeMutations\", \"false\"), `?${searchParams}`;\n}, excludeFalsey = (param, defValue) => param === !1 ? void 0 : typeof param > \"u\" ? defValue : param, getMutationQuery = (options = {}) => ({\n  dryRun: options.dryRun,\n  returnIds: !0,\n  returnDocuments: excludeFalsey(options.returnDocuments, !0),\n  visibility: options.visibility || \"sync\",\n  autoGenerateArrayKeys: options.autoGenerateArrayKeys,\n  skipCrossDatasetReferenceValidation: options.skipCrossDatasetReferenceValidation\n}), isResponse = (event) => event.type === \"response\", getBody = (event) => event.body, indexBy = (docs, attr) => docs.reduce((indexed, doc) => (indexed[attr(doc)] = doc, indexed), /* @__PURE__ */ Object.create(null)), getQuerySizeLimit = 11264;\nfunction _fetch(client, httpRequest, _stega, query, _params = {}, options = {}) {\n  const stega = \"stega\" in options ? {\n    ..._stega || {},\n    ...typeof options.stega == \"boolean\" ? { enabled: options.stega } : options.stega || {}\n  } : _stega, params = stega.enabled ? (0,_chunks_es_stegaClean_js__WEBPACK_IMPORTED_MODULE_3__.stegaClean)(_params) : _params, mapResponse = options.filterResponse === !1 ? (res) => res : (res) => res.result, { cache, next, ...opts } = {\n    // Opt out of setting a `signal` on an internal `fetch` if one isn't provided.\n    // This is necessary in React Server Components to avoid opting out of Request Memoization.\n    useAbortSignal: typeof options.signal < \"u\",\n    // Set `resultSourceMap' when stega is enabled, as it's required for encoding.\n    resultSourceMap: stega.enabled ? \"withKeyArraySelector\" : options.resultSourceMap,\n    ...options,\n    // Default to not returning the query, unless `filterResponse` is `false`,\n    // or `returnQuery` is explicitly set. `true` is the default in Content Lake, so skip if truthy\n    returnQuery: options.filterResponse === !1 && options.returnQuery !== !1\n  }, reqOpts = typeof cache < \"u\" || typeof next < \"u\" ? { ...opts, fetch: { cache, next } } : opts, $request = _dataRequest(client, httpRequest, \"query\", { query, params }, reqOpts);\n  return stega.enabled ? $request.pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.combineLatestWith)(\n      (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.from)(\n        __webpack_require__.e(/*! import() */ \"vendor-chunks/@sanity\").then(__webpack_require__.bind(__webpack_require__, /*! ./_chunks-es/stegaEncodeSourceMap.js */ \"(action-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\")).then(function(n) {\n          return n.stegaEncodeSourceMap$1;\n        }).then(\n          ({ stegaEncodeSourceMap }) => stegaEncodeSourceMap\n        )\n      )\n    ),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(\n      ([res, stegaEncodeSourceMap]) => {\n        const result = stegaEncodeSourceMap(res.result, res.resultSourceMap, stega);\n        return mapResponse({ ...res, result });\n      }\n    )\n  ) : $request.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(mapResponse));\n}\nfunction _getDocument(client, httpRequest, id, opts = {}) {\n  const options = {\n    uri: _getDataUrl(client, \"doc\", id),\n    json: !0,\n    tag: opts.tag,\n    signal: opts.signal\n  };\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((event) => event.body.documents && event.body.documents[0])\n  );\n}\nfunction _getDocuments(client, httpRequest, ids, opts = {}) {\n  const options = {\n    uri: _getDataUrl(client, \"doc\", ids.join(\",\")),\n    json: !0,\n    tag: opts.tag,\n    signal: opts.signal\n  };\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((event) => {\n      const indexed = indexBy(event.body.documents || [], (doc) => doc._id);\n      return ids.map((id) => indexed[id] || null);\n    })\n  );\n}\nfunction _createIfNotExists(client, httpRequest, doc, options) {\n  return requireDocumentId(\"createIfNotExists\", doc), _create(client, httpRequest, doc, \"createIfNotExists\", options);\n}\nfunction _createOrReplace(client, httpRequest, doc, options) {\n  return requireDocumentId(\"createOrReplace\", doc), _create(client, httpRequest, doc, \"createOrReplace\", options);\n}\nfunction _delete(client, httpRequest, selection, options) {\n  return _dataRequest(\n    client,\n    httpRequest,\n    \"mutate\",\n    { mutations: [{ delete: getSelection(selection) }] },\n    options\n  );\n}\nfunction _mutate(client, httpRequest, mutations, options) {\n  let mut;\n  mutations instanceof Patch || mutations instanceof ObservablePatch ? mut = { patch: mutations.serialize() } : mutations instanceof Transaction || mutations instanceof ObservableTransaction ? mut = mutations.serialize() : mut = mutations;\n  const muts = Array.isArray(mut) ? mut : [mut], transactionId = options && options.transactionId || void 0;\n  return _dataRequest(client, httpRequest, \"mutate\", { mutations: muts, transactionId }, options);\n}\nfunction _action(client, httpRequest, actions, options) {\n  const acts = Array.isArray(actions) ? actions : [actions], transactionId = options && options.transactionId || void 0, skipCrossDatasetReferenceValidation = options && options.skipCrossDatasetReferenceValidation || void 0, dryRun = options && options.dryRun || void 0;\n  return _dataRequest(\n    client,\n    httpRequest,\n    \"actions\",\n    { actions: acts, transactionId, skipCrossDatasetReferenceValidation, dryRun },\n    options\n  );\n}\nfunction _dataRequest(client, httpRequest, endpoint, body, options = {}) {\n  const isMutation = endpoint === \"mutate\", isAction = endpoint === \"actions\", isQuery = endpoint === \"query\", strQuery = isMutation || isAction ? \"\" : encodeQueryString(body), useGet = !isMutation && !isAction && strQuery.length < getQuerySizeLimit, stringQuery = useGet ? strQuery : \"\", returnFirst = options.returnFirst, { timeout, token, tag, headers, returnQuery, lastLiveEventId, cacheMode } = options, uri = _getDataUrl(client, endpoint, stringQuery), reqOptions = {\n    method: useGet ? \"GET\" : \"POST\",\n    uri,\n    json: !0,\n    body: useGet ? void 0 : body,\n    query: isMutation && getMutationQuery(options),\n    timeout,\n    headers,\n    token,\n    tag,\n    returnQuery,\n    perspective: options.perspective,\n    resultSourceMap: options.resultSourceMap,\n    lastLiveEventId: Array.isArray(lastLiveEventId) ? lastLiveEventId[0] : lastLiveEventId,\n    cacheMode,\n    canUseCdn: isQuery,\n    signal: options.signal,\n    fetch: options.fetch,\n    useAbortSignal: options.useAbortSignal,\n    useCdn: options.useCdn\n  };\n  return _requestObservable(client, httpRequest, reqOptions).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(getBody),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((res) => {\n      if (!isMutation)\n        return res;\n      const results = res.results || [];\n      if (options.returnDocuments)\n        return returnFirst ? results[0] && results[0].document : results.map((mut) => mut.document);\n      const key = returnFirst ? \"documentId\" : \"documentIds\", ids = returnFirst ? results[0] && results[0].id : results.map((mut) => mut.id);\n      return {\n        transactionId: res.transactionId,\n        results,\n        [key]: ids\n      };\n    })\n  );\n}\nfunction _create(client, httpRequest, doc, op, options = {}) {\n  const mutation = { [op]: doc }, opts = Object.assign({ returnFirst: !0, returnDocuments: !0 }, options);\n  return _dataRequest(client, httpRequest, \"mutate\", { mutations: [mutation] }, opts);\n}\nfunction _requestObservable(client, httpRequest, options) {\n  const uri = options.url || options.uri, config = client.config(), canUseCdn = typeof options.canUseCdn > \"u\" ? [\"GET\", \"HEAD\"].indexOf(options.method || \"GET\") >= 0 && uri.indexOf(\"/data/\") === 0 : options.canUseCdn;\n  let useCdn = (options.useCdn ?? config.useCdn) && canUseCdn;\n  const tag = options.tag && config.requestTagPrefix ? [config.requestTagPrefix, options.tag].join(\".\") : options.tag || config.requestTagPrefix;\n  if (tag && options.tag !== null && (options.query = { tag: requestTag(tag), ...options.query }), [\"GET\", \"HEAD\", \"POST\"].indexOf(options.method || \"GET\") >= 0 && uri.indexOf(\"/data/query/\") === 0) {\n    const resultSourceMap = options.resultSourceMap ?? config.resultSourceMap;\n    resultSourceMap !== void 0 && resultSourceMap !== !1 && (options.query = { resultSourceMap, ...options.query });\n    const perspectiveOption = options.perspective || config.perspective;\n    typeof perspectiveOption < \"u\" && (validateApiPerspective(perspectiveOption), options.query = {\n      perspective: Array.isArray(perspectiveOption) ? perspectiveOption.join(\",\") : perspectiveOption,\n      ...options.query\n    }, perspectiveOption === \"previewDrafts\" && useCdn && (useCdn = !1, printCdnPreviewDraftsWarning())), options.lastLiveEventId && (options.query = { ...options.query, lastLiveEventId: options.lastLiveEventId }), options.returnQuery === !1 && (options.query = { returnQuery: \"false\", ...options.query }), useCdn && options.cacheMode == \"noStale\" && (options.query = { cacheMode: \"noStale\", ...options.query });\n  }\n  const reqOptions = requestOptions(\n    config,\n    Object.assign({}, options, {\n      url: _getUrl(client, uri, useCdn)\n    })\n  ), request = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable(\n    (subscriber) => httpRequest(reqOptions, config.requester).subscribe(subscriber)\n  );\n  return options.signal ? request.pipe(_withAbortSignal(options.signal)) : request;\n}\nfunction _request(client, httpRequest, options) {\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)((event) => event.type === \"response\"),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((event) => event.body)\n  );\n}\nfunction _getDataUrl(client, operation, path) {\n  const config = client.config(), catalog = hasDataset(config), baseUri = `/${operation}/${catalog}`;\n  return `/data${path ? `${baseUri}/${path}` : baseUri}`.replace(/\\/($|\\?)/, \"$1\");\n}\nfunction _getUrl(client, uri, canUseCdn = !1) {\n  const { url, cdnUrl } = client.config();\n  return `${canUseCdn ? cdnUrl : url}/${uri.replace(/^\\//, \"\")}`;\n}\nfunction _withAbortSignal(signal) {\n  return (input) => new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => {\n    const abort = () => observer.error(_createAbortError(signal));\n    if (signal && signal.aborted) {\n      abort();\n      return;\n    }\n    const subscription = input.subscribe(observer);\n    return signal.addEventListener(\"abort\", abort), () => {\n      signal.removeEventListener(\"abort\", abort), subscription.unsubscribe();\n    };\n  });\n}\nconst isDomExceptionSupported = !!globalThis.DOMException;\nfunction _createAbortError(signal) {\n  if (isDomExceptionSupported)\n    return new DOMException(signal?.reason ?? \"The operation was aborted.\", \"AbortError\");\n  const error = new Error(signal?.reason ?? \"The operation was aborted.\");\n  return error.name = \"AbortError\", error;\n}\nclass ObservableAssetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  upload(assetType, body, options) {\n    return _upload(this.#client, this.#httpRequest, assetType, body, options);\n  }\n}\nclass AssetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  upload(assetType, body, options) {\n    const observable2 = _upload(this.#client, this.#httpRequest, assetType, body, options);\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      observable2.pipe(\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)((event) => event.type === \"response\"),\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(\n          (event) => event.body.document\n        )\n      )\n    );\n  }\n}\nfunction _upload(client, httpRequest, assetType, body, opts = {}) {\n  validateAssetType(assetType);\n  let meta = opts.extract || void 0;\n  meta && !meta.length && (meta = [\"none\"]);\n  const dataset2 = hasDataset(client.config()), assetEndpoint = assetType === \"image\" ? \"images\" : \"files\", options = optionsFromFile(opts, body), { tag, label, title, description, creditLine, filename, source } = options, query = {\n    label,\n    title,\n    description,\n    filename,\n    meta,\n    creditLine\n  };\n  return source && (query.sourceId = source.id, query.sourceName = source.name, query.sourceUrl = source.url), _requestObservable(client, httpRequest, {\n    tag,\n    method: \"POST\",\n    timeout: options.timeout || 0,\n    uri: `/assets/${assetEndpoint}/${dataset2}`,\n    headers: options.contentType ? { \"Content-Type\": options.contentType } : {},\n    query,\n    body\n  });\n}\nfunction optionsFromFile(opts, file) {\n  return typeof File > \"u\" || !(file instanceof File) ? opts : Object.assign(\n    {\n      filename: opts.preserveFilename === !1 ? void 0 : file.name,\n      contentType: file.type\n    },\n    opts\n  );\n}\nvar defaults = (obj, defaults2) => Object.keys(defaults2).concat(Object.keys(obj)).reduce((target, prop) => (target[prop] = typeof obj[prop] > \"u\" ? defaults2[prop] : obj[prop], target), {});\nconst pick = (obj, props) => props.reduce((selection, prop) => (typeof obj[prop] > \"u\" || (selection[prop] = obj[prop]), selection), {}), MAX_URL_LENGTH = 14800, possibleOptions = [\n  \"includePreviousRevision\",\n  \"includeResult\",\n  \"includeMutations\",\n  \"visibility\",\n  \"effectFormat\",\n  \"tag\"\n], defaultOptions = {\n  includeResult: !0\n};\nfunction _listen(query, params, opts = {}) {\n  const { url, token, withCredentials, requestTagPrefix } = this.config(), tag = opts.tag && requestTagPrefix ? [requestTagPrefix, opts.tag].join(\".\") : opts.tag, options = { ...defaults(opts, defaultOptions), tag }, listenOpts = pick(options, possibleOptions), qs = encodeQueryString({ query, params, options: { tag, ...listenOpts } }), uri = `${url}${_getDataUrl(this, \"listen\", qs)}`;\n  if (uri.length > MAX_URL_LENGTH)\n    return new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => observer.error(new Error(\"Query too large for listener\")));\n  const listenFor = options.events ? options.events : [\"mutation\"], shouldEmitReconnect = listenFor.indexOf(\"reconnect\") !== -1, esOptions = {};\n  return (token || withCredentials) && (esOptions.withCredentials = !0), token && (esOptions.headers = {\n    Authorization: `Bearer ${token}`\n  }), new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => {\n    let es, reconnectTimer, stopped = !1, unsubscribed = !1;\n    open();\n    function onError() {\n      stopped || (emitReconnect(), !stopped && es.readyState === es.CLOSED && (unsubscribe(), clearTimeout(reconnectTimer), reconnectTimer = setTimeout(open, 100)));\n    }\n    function onChannelError(err) {\n      observer.error(cooerceError(err));\n    }\n    function onMessage(evt) {\n      const event = parseEvent$1(evt);\n      return event instanceof Error ? observer.error(event) : observer.next(event);\n    }\n    function onDisconnect() {\n      stopped = !0, unsubscribe(), observer.complete();\n    }\n    function unsubscribe() {\n      es && (es.removeEventListener(\"error\", onError), es.removeEventListener(\"channelError\", onChannelError), es.removeEventListener(\"disconnect\", onDisconnect), listenFor.forEach((type) => es.removeEventListener(type, onMessage)), es.close());\n    }\n    function emitReconnect() {\n      shouldEmitReconnect && observer.next({ type: \"reconnect\" });\n    }\n    async function getEventSource() {\n      const { default: EventSource2 } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@sanity\"), __webpack_require__.e(\"vendor-chunks/eventsource\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! @sanity/eventsource */ \"(action-browser)/./node_modules/@sanity/eventsource/node.js\", 19));\n      if (unsubscribed)\n        return;\n      const evs = new EventSource2(uri, esOptions);\n      return evs.addEventListener(\"error\", onError), evs.addEventListener(\"channelError\", onChannelError), evs.addEventListener(\"disconnect\", onDisconnect), listenFor.forEach((type) => evs.addEventListener(type, onMessage)), evs;\n    }\n    function open() {\n      getEventSource().then((eventSource) => {\n        eventSource && (es = eventSource, unsubscribed && unsubscribe());\n      }).catch((reason) => {\n        observer.error(reason), stop();\n      });\n    }\n    function stop() {\n      stopped = !0, unsubscribe(), unsubscribed = !0;\n    }\n    return stop;\n  });\n}\nfunction parseEvent$1(event) {\n  try {\n    const data = event.data && JSON.parse(event.data) || {};\n    return Object.assign({ type: event.type }, data);\n  } catch (err) {\n    return err;\n  }\n}\nfunction cooerceError(err) {\n  if (err instanceof Error)\n    return err;\n  const evt = parseEvent$1(err);\n  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));\n}\nfunction extractErrorMessage(err) {\n  return err.error ? err.error.description ? err.error.description : typeof err.error == \"string\" ? err.error : JSON.stringify(err.error, null, 2) : err.message || \"Unknown listener error\";\n}\nconst requiredApiVersion = \"2021-03-26\";\nclass LiveClient {\n  #client;\n  constructor(client) {\n    this.#client = client;\n  }\n  /**\n   * Requires `apiVersion` to be `2021-03-26` or later.\n   */\n  events({\n    includeDrafts = !1,\n    tag: _tag\n  } = {}) {\n    const {\n      projectId: projectId2,\n      apiVersion: _apiVersion,\n      token,\n      withCredentials,\n      requestTagPrefix\n    } = this.#client.config(), apiVersion = _apiVersion.replace(/^v/, \"\");\n    if (apiVersion !== \"X\" && apiVersion < requiredApiVersion)\n      throw new Error(\n        `The live events API requires API version ${requiredApiVersion} or later. The current API version is ${apiVersion}. Please update your API version to use this feature.`\n      );\n    if (includeDrafts && !token && !withCredentials)\n      throw new Error(\n        \"The live events API requires a token or withCredentials when 'includeDrafts: true'. Please update your client configuration. The token should have the lowest possible access role.\"\n      );\n    if (includeDrafts && apiVersion !== \"X\")\n      throw new Error(\n        \"The live events API requires API version X when 'includeDrafts: true'. This API is experimental and may change or even be removed.\"\n      );\n    const path = _getDataUrl(this.#client, \"live/events\"), url = new URL(this.#client.getUrl(path, !1)), tag = _tag && requestTagPrefix ? [requestTagPrefix, _tag].join(\".\") : _tag;\n    tag && url.searchParams.set(\"tag\", tag), includeDrafts && url.searchParams.set(\"includeDrafts\", \"true\");\n    const listenFor = [\"restart\", \"message\", \"welcome\", \"reconnect\"], esOptions = {};\n    return includeDrafts && token && (esOptions.headers = {\n      Authorization: `Bearer ${token}`\n    }), includeDrafts && withCredentials && (esOptions.withCredentials = !0), new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => {\n      let es, reconnectTimer, stopped = !1, unsubscribed = !1;\n      open();\n      function onError(evt) {\n        if (!stopped) {\n          if (\"data\" in evt) {\n            const event = parseEvent(evt);\n            observer.error(new Error(event.message, { cause: event }));\n          }\n          es.readyState === es.CLOSED && (unsubscribe(), clearTimeout(reconnectTimer), reconnectTimer = setTimeout(open, 100));\n        }\n      }\n      function onMessage(evt) {\n        const event = parseEvent(evt);\n        return event instanceof Error ? observer.error(event) : observer.next(event);\n      }\n      function unsubscribe() {\n        if (es) {\n          es.removeEventListener(\"error\", onError);\n          for (const type of listenFor)\n            es.removeEventListener(type, onMessage);\n          es.close();\n        }\n      }\n      async function getEventSource() {\n        const EventSourceImplementation = typeof EventSource > \"u\" || esOptions.headers || esOptions.withCredentials ? (await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@sanity\"), __webpack_require__.e(\"vendor-chunks/eventsource\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! @sanity/eventsource */ \"(action-browser)/./node_modules/@sanity/eventsource/node.js\", 19))).default : EventSource;\n        if (unsubscribed)\n          return;\n        try {\n          if (await fetch(url, {\n            method: \"OPTIONS\",\n            mode: \"cors\",\n            credentials: esOptions.withCredentials ? \"include\" : \"omit\",\n            headers: esOptions.headers\n          }), unsubscribed)\n            return;\n        } catch {\n          throw new CorsOriginError({ projectId: projectId2 });\n        }\n        const evs = new EventSourceImplementation(url.toString(), esOptions);\n        evs.addEventListener(\"error\", onError);\n        for (const type of listenFor)\n          evs.addEventListener(type, onMessage);\n        return evs;\n      }\n      function open() {\n        getEventSource().then((eventSource) => {\n          eventSource && (es = eventSource, unsubscribed && unsubscribe());\n        }).catch((reason) => {\n          observer.error(reason), stop();\n        });\n      }\n      function stop() {\n        stopped = !0, unsubscribe(), unsubscribed = !0;\n      }\n      return stop;\n    });\n  }\n}\nfunction parseEvent(event) {\n  try {\n    const data = event.data && JSON.parse(event.data) || {};\n    return { type: event.type, id: event.lastEventId, ...data };\n  } catch (err) {\n    return err;\n  }\n}\nclass ObservableDatasetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */\n  create(name, options) {\n    return _modify(this.#client, this.#httpRequest, \"PUT\", name, options);\n  }\n  /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */\n  edit(name, options) {\n    return _modify(this.#client, this.#httpRequest, \"PATCH\", name, options);\n  }\n  /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */\n  delete(name) {\n    return _modify(this.#client, this.#httpRequest, \"DELETE\", name);\n  }\n  /**\n   * Fetch a list of datasets for the configured project\n   */\n  list() {\n    return _request(this.#client, this.#httpRequest, {\n      uri: \"/datasets\",\n      tag: null\n    });\n  }\n}\nclass DatasetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */\n  create(name, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _modify(this.#client, this.#httpRequest, \"PUT\", name, options)\n    );\n  }\n  /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */\n  edit(name, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _modify(this.#client, this.#httpRequest, \"PATCH\", name, options)\n    );\n  }\n  /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */\n  delete(name) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_modify(this.#client, this.#httpRequest, \"DELETE\", name));\n  }\n  /**\n   * Fetch a list of datasets for the configured project\n   */\n  list() {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _request(this.#client, this.#httpRequest, { uri: \"/datasets\", tag: null })\n    );\n  }\n}\nfunction _modify(client, httpRequest, method, name, options) {\n  return dataset(name), _request(client, httpRequest, {\n    method,\n    uri: `/datasets/${name}`,\n    body: options,\n    tag: null\n  });\n}\nclass ObservableProjectsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  list(options) {\n    const uri = options?.includeMembers === !1 ? \"/projects?includeMembers=false\" : \"/projects\";\n    return _request(this.#client, this.#httpRequest, { uri });\n  }\n  /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */\n  getById(projectId2) {\n    return _request(this.#client, this.#httpRequest, { uri: `/projects/${projectId2}` });\n  }\n}\nclass ProjectsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  list(options) {\n    const uri = options?.includeMembers === !1 ? \"/projects?includeMembers=false\" : \"/projects\";\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_request(this.#client, this.#httpRequest, { uri }));\n  }\n  /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */\n  getById(projectId2) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _request(this.#client, this.#httpRequest, { uri: `/projects/${projectId2}` })\n    );\n  }\n}\nclass ObservableUsersClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */\n  getById(id) {\n    return _request(\n      this.#client,\n      this.#httpRequest,\n      { uri: `/users/${id}` }\n    );\n  }\n}\nclass UsersClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */\n  getById(id) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _request(this.#client, this.#httpRequest, {\n        uri: `/users/${id}`\n      })\n    );\n  }\n}\nclass ObservableSanityClient {\n  assets;\n  datasets;\n  live;\n  projects;\n  users;\n  /**\n   * Private properties\n   */\n  #clientConfig;\n  #httpRequest;\n  /**\n   * Instance properties\n   */\n  listen = _listen;\n  constructor(httpRequest, config = defaultConfig) {\n    this.config(config), this.#httpRequest = httpRequest, this.assets = new ObservableAssetsClient(this, this.#httpRequest), this.datasets = new ObservableDatasetsClient(this, this.#httpRequest), this.live = new LiveClient(this), this.projects = new ObservableProjectsClient(this, this.#httpRequest), this.users = new ObservableUsersClient(this, this.#httpRequest);\n  }\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone() {\n    return new ObservableSanityClient(this.#httpRequest, this.config());\n  }\n  config(newConfig) {\n    if (newConfig === void 0)\n      return { ...this.#clientConfig };\n    if (this.#clientConfig && this.#clientConfig.allowReconfigure === !1)\n      throw new Error(\n        \"Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client\"\n      );\n    return this.#clientConfig = initConfig(newConfig, this.#clientConfig || {}), this;\n  }\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig) {\n    const thisConfig = this.config();\n    return new ObservableSanityClient(this.#httpRequest, {\n      ...thisConfig,\n      ...newConfig,\n      stega: {\n        ...thisConfig.stega || {},\n        ...typeof newConfig?.stega == \"boolean\" ? { enabled: newConfig.stega } : newConfig?.stega || {}\n      }\n    });\n  }\n  fetch(query, params, options) {\n    return _fetch(\n      this,\n      this.#httpRequest,\n      this.#clientConfig.stega,\n      query,\n      params,\n      options\n    );\n  }\n  /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */\n  getDocument(id, options) {\n    return _getDocument(this, this.#httpRequest, id, options);\n  }\n  /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */\n  getDocuments(ids, options) {\n    return _getDocuments(this, this.#httpRequest, ids, options);\n  }\n  create(document, options) {\n    return _create(this, this.#httpRequest, document, \"create\", options);\n  }\n  createIfNotExists(document, options) {\n    return _createIfNotExists(this, this.#httpRequest, document, options);\n  }\n  createOrReplace(document, options) {\n    return _createOrReplace(this, this.#httpRequest, document, options);\n  }\n  delete(selection, options) {\n    return _delete(this, this.#httpRequest, selection, options);\n  }\n  mutate(operations, options) {\n    return _mutate(this, this.#httpRequest, operations, options);\n  }\n  /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   * @returns Patch instance - call `.commit()` to perform the operations defined\n   */\n  patch(selection, operations) {\n    return new ObservablePatch(selection, operations, this);\n  }\n  /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */\n  transaction(operations) {\n    return new ObservableTransaction(operations, this);\n  }\n  /**\n   * Perform action operations against the configured dataset\n   *\n   * @param operations - Action operation(s) to execute\n   * @param options - Action options\n   */\n  action(operations, options) {\n    return _action(this, this.#httpRequest, operations, options);\n  }\n  /**\n   * Perform an HTTP request against the Sanity API\n   *\n   * @param options - Request options\n   */\n  request(options) {\n    return _request(this, this.#httpRequest, options);\n  }\n  /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */\n  getUrl(uri, canUseCdn) {\n    return _getUrl(this, uri, canUseCdn);\n  }\n  /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */\n  getDataUrl(operation, path) {\n    return _getDataUrl(this, operation, path);\n  }\n}\nclass SanityClient {\n  assets;\n  datasets;\n  live;\n  projects;\n  users;\n  /**\n   * Observable version of the Sanity client, with the same configuration as the promise-based one\n   */\n  observable;\n  /**\n   * Private properties\n   */\n  #clientConfig;\n  #httpRequest;\n  /**\n   * Instance properties\n   */\n  listen = _listen;\n  constructor(httpRequest, config = defaultConfig) {\n    this.config(config), this.#httpRequest = httpRequest, this.assets = new AssetsClient(this, this.#httpRequest), this.datasets = new DatasetsClient(this, this.#httpRequest), this.live = new LiveClient(this), this.projects = new ProjectsClient(this, this.#httpRequest), this.users = new UsersClient(this, this.#httpRequest), this.observable = new ObservableSanityClient(httpRequest, config);\n  }\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone() {\n    return new SanityClient(this.#httpRequest, this.config());\n  }\n  config(newConfig) {\n    if (newConfig === void 0)\n      return { ...this.#clientConfig };\n    if (this.#clientConfig && this.#clientConfig.allowReconfigure === !1)\n      throw new Error(\n        \"Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client\"\n      );\n    return this.observable && this.observable.config(newConfig), this.#clientConfig = initConfig(newConfig, this.#clientConfig || {}), this;\n  }\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig) {\n    const thisConfig = this.config();\n    return new SanityClient(this.#httpRequest, {\n      ...thisConfig,\n      ...newConfig,\n      stega: {\n        ...thisConfig.stega || {},\n        ...typeof newConfig?.stega == \"boolean\" ? { enabled: newConfig.stega } : newConfig?.stega || {}\n      }\n    });\n  }\n  fetch(query, params, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _fetch(\n        this,\n        this.#httpRequest,\n        this.#clientConfig.stega,\n        query,\n        params,\n        options\n      )\n    );\n  }\n  /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */\n  getDocument(id, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_getDocument(this, this.#httpRequest, id, options));\n  }\n  /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */\n  getDocuments(ids, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_getDocuments(this, this.#httpRequest, ids, options));\n  }\n  create(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _create(this, this.#httpRequest, document, \"create\", options)\n    );\n  }\n  createIfNotExists(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _createIfNotExists(this, this.#httpRequest, document, options)\n    );\n  }\n  createOrReplace(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _createOrReplace(this, this.#httpRequest, document, options)\n    );\n  }\n  delete(selection, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_delete(this, this.#httpRequest, selection, options));\n  }\n  mutate(operations, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_mutate(this, this.#httpRequest, operations, options));\n  }\n  /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   * @returns Patch instance - call `.commit()` to perform the operations defined\n   */\n  patch(documentId, operations) {\n    return new Patch(documentId, operations, this);\n  }\n  /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */\n  transaction(operations) {\n    return new Transaction(operations, this);\n  }\n  /**\n   * Perform action operations against the configured dataset\n   * Returns a promise that resolves to the transaction result\n   *\n   * @param operations - Action operation(s) to execute\n   * @param options - Action options\n   */\n  action(operations, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_action(this, this.#httpRequest, operations, options));\n  }\n  /**\n   * Perform a request against the Sanity API\n   * NOTE: Only use this for Sanity API endpoints, not for your own APIs!\n   *\n   * @param options - Request options\n   * @returns Promise resolving to the response body\n   */\n  request(options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_request(this, this.#httpRequest, options));\n  }\n  /**\n   * Perform an HTTP request a `/data` sub-endpoint\n   * NOTE: Considered internal, thus marked as deprecated. Use `request` instead.\n   *\n   * @deprecated - Use `request()` or your own HTTP library instead\n   * @param endpoint - Endpoint to hit (mutate, query etc)\n   * @param body - Request body\n   * @param options - Request options\n   * @internal\n   */\n  dataRequest(endpoint, body, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_dataRequest(this, this.#httpRequest, endpoint, body, options));\n  }\n  /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */\n  getUrl(uri, canUseCdn) {\n    return _getUrl(this, uri, canUseCdn);\n  }\n  /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */\n  getDataUrl(operation, path) {\n    return _getDataUrl(this, operation, path);\n  }\n}\nfunction defineCreateClientExports(envMiddleware2, ClassConstructor) {\n  const defaultRequester = defineHttpRequest(envMiddleware2);\n  return { requester: defaultRequester, createClient: (config) => new ClassConstructor(\n    (options, requester2) => (requester2 || defaultRequester)({\n      maxRedirects: 0,\n      maxRetries: config.maxRetries,\n      retryDelay: config.retryDelay,\n      ...options\n    }),\n    config\n  ) };\n}\nfunction defineDeprecatedCreateClient(createClient2) {\n  return function(config) {\n    return printNoDefaultExport(), createClient2(config);\n  };\n}\nvar envMiddleware = [];\nconst exp = defineCreateClientExports(envMiddleware, SanityClient), requester = exp.requester, createClient = exp.createClient, deprecatedCreateClient = defineDeprecatedCreateClient(createClient);\n\n//# sourceMappingURL=index.browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L2luZGV4LmJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ2U7QUFDNkM7QUFDcEM7QUFDQztBQUNRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWSxJQUFJLGFBQWE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEtBQUs7QUFDTDtBQUNBLFNBQVMscUJBQXFCLDJCQUEyQix1QkFBdUIsRUFBRSxTQUFTO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtCQUFrQjtBQUNsRSxZQUFZLFdBQVcsY0FBYyxTQUFTLG1CQUFtQixlQUFlLEVBQUUsY0FBYztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQSw0REFBNEQsV0FBVztBQUN2RTtBQUNBLGNBQWMsU0FBUztBQUN2QixpTkFBaU4sSUFBSTtBQUNyTixNQUFNO0FBQ04sOEhBQThILElBQUk7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2Q0FBSztBQUNkLElBQUksd0RBQUssR0FBRyxhQUFhO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLDhEQUFXO0FBQ2YsSUFBSSwrREFBWTtBQUNoQixJQUFJLDJEQUFRO0FBQ1o7QUFDQSxJQUFJLDZEQUFVLEdBQUcsZ0JBQWdCLDRDQUFVLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG9EQUFLO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixFQUFFLE1BQU0sS0FBSyxVQUFVLEVBQUUsTUFBTSxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMkNBQTJDLEtBQUssbUJBQW1CLDZCQUE2QjtBQUNoRyxDQUFDO0FBQ0Q7QUFDQSx1QkFBdUIsR0FBRztBQUMxQixDQUFDO0FBQ0QsdURBQXVELE1BQU07QUFDN0QsdUJBQXVCLEdBQUcsT0FBTyxHQUFHO0FBQ3BDLENBQUM7QUFDRDtBQUNBLHVCQUF1QixHQUFHO0FBQzFCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwwREFBMEQsSUFBSTtBQUM5RCx1QkFBdUIsV0FBVywwQ0FBMEMsTUFBTTtBQUNsRjtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQSx1QkFBdUIsV0FBVztBQUNsQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsU0FBUyx5Q0FBeUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDRCQUE0QjtBQUM5RSw4Q0FBOEMsd0JBQXdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUZBQXFGLFFBQVE7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHdCQUF3QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSwwQkFBMEI7QUFDNUY7QUFDQTtBQUNBLDhjQUE4YyxxQkFBcUI7QUFDbmU7QUFDQSw0REFBNEQsU0FBUyxLQUFLLG9CQUFvQixHQUFHLEtBQUssSUFBSSxxQkFBcUIseUJBQXlCLFNBQVMsS0FBSyxvQkFBb0IsR0FBRyxRQUFRLElBQUkscUJBQXFCLHlCQUF5QixrQkFBa0IsSUFBSSxxQkFBcUI7QUFDbFM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQSx1RkFBdUYsdUNBQXVDLElBQUk7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxjQUFjO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCLGNBQWM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsdUJBQXVCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5UEFBeVAsU0FBUyxHQUFHLFdBQVcsR0FBRyxTQUFTO0FBQzVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLDRCQUE0QixvQ0FBb0M7QUFDaEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0JBQW9CO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixrQ0FBa0M7QUFDcEgsaUNBQWlDLHlCQUF5QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Ysa0NBQWtDO0FBQ3BILGlDQUFpQyx5QkFBeUI7QUFDMUQ7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxXQUFXO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxXQUFXO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVSxrQkFBa0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkIscUNBQXFDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0NBQXNDO0FBQy9EO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSx5QkFBeUIsMEJBQTBCO0FBQ25EO0FBQ0EsdUJBQXVCLFNBQVMsc0NBQXNDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCLHFDQUFxQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNDQUFzQztBQUMvRDtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EseUJBQXlCLDBCQUEwQjtBQUNuRDtBQUNBLHVCQUF1QixTQUFTLHNDQUFzQztBQUN0RTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsb0JBQW9CO0FBQ3BCLDhDQUE4QyxNQUFNO0FBQ3BEO0FBQ0EseUJBQXlCO0FBQ3pCLDZCQUE2QixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsc0NBQXNDO0FBQzNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxDQUFDO0FBQ0QsZ0RBQWdELDhDQUE4QztBQUM5RjtBQUNBO0FBQ0EsNEJBQTRCLElBQUk7QUFDaEM7QUFDQSx5Q0FBeUMsTUFBTTtBQUMvQyw2SkFBNkosYUFBYTtBQUMxSyxDQUFDLHNJQUFzSTtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0VBQWdFLGNBQWM7QUFDOUU7QUFDQSxtQkFBbUI7QUFDbkIsNkNBQTZDLHlCQUF5QjtBQUN0RSxJQUFJLG1DQUFtQyxvRUFBVSx5R0FBeUcsdUJBQXVCO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsd0RBQXdELGtCQUFrQixnQkFBZ0IsZ0VBQWdFLGVBQWU7QUFDNUs7QUFDQSxJQUFJLGlFQUFpQjtBQUNyQixNQUFNLDBDQUFJO0FBQ1YsUUFBUSx3UEFBOEM7QUFDdEQ7QUFDQSxTQUFTO0FBQ1QsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtREFBRztBQUNQO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQSxvQkFBb0IsbURBQUc7QUFDdkI7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFNO0FBQ1YsSUFBSSxtREFBRztBQUNQO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFNO0FBQ1YsSUFBSSxtREFBRztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGNBQWMsaUNBQWlDLEdBQUc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSwrQkFBK0I7QUFDOUc7QUFDQSx1REFBdUQsZ0NBQWdDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyRUFBMkU7QUFDakY7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFLHNVQUFzVSx3RUFBd0U7QUFDOVk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzREFBTTtBQUNWLElBQUksbURBQUc7QUFDUCxJQUFJLG1EQUFHO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELHFCQUFxQixXQUFXLHlCQUF5QixzQ0FBc0M7QUFDL0YsdURBQXVELHVCQUF1QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHdDQUF3QztBQUNoRztBQUNBLCtFQUErRSxtQ0FBbUM7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG1KQUFtSiw0REFBNEQsb0RBQW9ELHdDQUF3QyxrRUFBa0Usd0NBQXdDO0FBQzFaO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEtBQUs7QUFDTCxtQkFBbUIsNENBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzREFBTTtBQUNWLElBQUksbURBQUc7QUFDUDtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsVUFBVSxHQUFHLFFBQVE7QUFDbkcsaUJBQWlCLFVBQVUsUUFBUSxHQUFHLEtBQUssWUFBWTtBQUN2RDtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCLFlBQVkseUJBQXlCLEdBQUcsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQSx3QkFBd0IsNENBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1EQUFhO0FBQ3hCO0FBQ0EsUUFBUSxzREFBTTtBQUNkLFFBQVEsbURBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0EscUpBQXFKLCtEQUErRDtBQUNwTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWMsR0FBRyxTQUFTO0FBQzlDLHFDQUFxQyxzQ0FBc0MsSUFBSTtBQUMvRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2TEFBNkw7QUFDN0wsdUlBQXVJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxVQUFVLGdEQUFnRCxxSEFBcUgsd0NBQXdDLHdFQUF3RSwwQkFBMEIsc0JBQXNCLFlBQVksSUFBSSxFQUFFLGdDQUFnQztBQUNqWTtBQUNBLGVBQWUsNENBQVU7QUFDekI7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DLEdBQUcsT0FBTyw0Q0FBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtQkFBbUI7QUFDaEU7QUFDQTtBQUNBLGNBQWMsd0JBQXdCLFFBQVEsb1JBQTZCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0MsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0RBQW9ELG9CQUFvQix1Q0FBdUMsV0FBVztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDLEtBQUssNkVBQTZFLDRDQUFVO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxjQUFjO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEgsb1JBQTZCO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Ysc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1EQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1EQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1EQUFhO0FBQ3hCLGtEQUFrRCw2QkFBNkI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsS0FBSztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0IsV0FBVyxHQUFHO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBYSw2Q0FBNkMsS0FBSztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQWE7QUFDeEIsa0RBQWtELGtCQUFrQixXQUFXLEdBQUc7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxlQUFlLEdBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBYTtBQUN4QjtBQUNBLHVCQUF1QixHQUFHO0FBQzFCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxvREFBb0QsMkJBQTJCO0FBQy9FO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0k7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLG9EQUFvRCwyQkFBMkI7QUFDL0U7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsbURBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQWE7QUFDeEI7QUFDQTtBQUNBLFdBQVcsbURBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1EQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQWE7QUFDeEI7QUFDQTtBQUNBLFdBQVcsbURBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1EQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW1CRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWNfZGlyZWN0b3J5Ly4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2Rpc3QvaW5kZXguYnJvd3Nlci5qcz9iZjBkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEl0IH0gZnJvbSBcImdldC1pdFwiO1xuaW1wb3J0IHsgYWRhcHRlciwgZW52aXJvbm1lbnQgfSBmcm9tIFwiZ2V0LWl0XCI7XG5pbXBvcnQgeyByZXRyeSwganNvblJlcXVlc3QsIGpzb25SZXNwb25zZSwgcHJvZ3Jlc3MsIG9ic2VydmFibGUgfSBmcm9tIFwiZ2V0LWl0L21pZGRsZXdhcmVcIjtcbmltcG9ydCB7IE9ic2VydmFibGUsIGZyb20sIGxhc3RWYWx1ZUZyb20gfSBmcm9tIFwicnhqc1wiO1xuaW1wb3J0IHsgc3RlZ2FDbGVhbiB9IGZyb20gXCIuL19jaHVua3MtZXMvc3RlZ2FDbGVhbi5qc1wiO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdFdpdGgsIG1hcCwgZmlsdGVyIH0gZnJvbSBcInJ4anMvb3BlcmF0b3JzXCI7XG5jbGFzcyBDbGllbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcmVzcG9uc2U7XG4gIHN0YXR1c0NvZGUgPSA0MDA7XG4gIHJlc3BvbnNlQm9keTtcbiAgZGV0YWlscztcbiAgY29uc3RydWN0b3IocmVzKSB7XG4gICAgY29uc3QgcHJvcHMgPSBleHRyYWN0RXJyb3JQcm9wcyhyZXMpO1xuICAgIHN1cGVyKHByb3BzLm1lc3NhZ2UpLCBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgfVxufVxuY2xhc3MgU2VydmVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHJlc3BvbnNlO1xuICBzdGF0dXNDb2RlID0gNTAwO1xuICByZXNwb25zZUJvZHk7XG4gIGRldGFpbHM7XG4gIGNvbnN0cnVjdG9yKHJlcykge1xuICAgIGNvbnN0IHByb3BzID0gZXh0cmFjdEVycm9yUHJvcHMocmVzKTtcbiAgICBzdXBlcihwcm9wcy5tZXNzYWdlKSwgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3RFcnJvclByb3BzKHJlcykge1xuICBjb25zdCBib2R5ID0gcmVzLmJvZHksIHByb3BzID0ge1xuICAgIHJlc3BvbnNlOiByZXMsXG4gICAgc3RhdHVzQ29kZTogcmVzLnN0YXR1c0NvZGUsXG4gICAgcmVzcG9uc2VCb2R5OiBzdHJpbmdpZnlCb2R5KGJvZHksIHJlcyksXG4gICAgbWVzc2FnZTogXCJcIixcbiAgICBkZXRhaWxzOiB2b2lkIDBcbiAgfTtcbiAgaWYgKGJvZHkuZXJyb3IgJiYgYm9keS5tZXNzYWdlKVxuICAgIHJldHVybiBwcm9wcy5tZXNzYWdlID0gYCR7Ym9keS5lcnJvcn0gLSAke2JvZHkubWVzc2FnZX1gLCBwcm9wcztcbiAgaWYgKGlzTXV0YXRpb25FcnJvcihib2R5KSB8fCBpc0FjdGlvbkVycm9yKGJvZHkpKSB7XG4gICAgY29uc3QgYWxsSXRlbXMgPSBib2R5LmVycm9yLml0ZW1zIHx8IFtdLCBpdGVtcyA9IGFsbEl0ZW1zLnNsaWNlKDAsIDUpLm1hcCgoaXRlbSkgPT4gaXRlbS5lcnJvcj8uZGVzY3JpcHRpb24pLmZpbHRlcihCb29sZWFuKTtcbiAgICBsZXQgaXRlbXNTdHIgPSBpdGVtcy5sZW5ndGggPyBgOlxuLSAke2l0ZW1zLmpvaW4oYFxuLSBgKX1gIDogXCJcIjtcbiAgICByZXR1cm4gYWxsSXRlbXMubGVuZ3RoID4gNSAmJiAoaXRlbXNTdHIgKz0gYFxuLi4uYW5kICR7YWxsSXRlbXMubGVuZ3RoIC0gNX0gbW9yZWApLCBwcm9wcy5tZXNzYWdlID0gYCR7Ym9keS5lcnJvci5kZXNjcmlwdGlvbn0ke2l0ZW1zU3RyfWAsIHByb3BzLmRldGFpbHMgPSBib2R5LmVycm9yLCBwcm9wcztcbiAgfVxuICByZXR1cm4gYm9keS5lcnJvciAmJiBib2R5LmVycm9yLmRlc2NyaXB0aW9uID8gKHByb3BzLm1lc3NhZ2UgPSBib2R5LmVycm9yLmRlc2NyaXB0aW9uLCBwcm9wcy5kZXRhaWxzID0gYm9keS5lcnJvciwgcHJvcHMpIDogKHByb3BzLm1lc3NhZ2UgPSBib2R5LmVycm9yIHx8IGJvZHkubWVzc2FnZSB8fCBodHRwRXJyb3JNZXNzYWdlKHJlcyksIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGlzTXV0YXRpb25FcnJvcihib2R5KSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGJvZHkpICYmIGlzUGxhaW5PYmplY3QoYm9keS5lcnJvcikgJiYgYm9keS5lcnJvci50eXBlID09PSBcIm11dGF0aW9uRXJyb3JcIiAmJiB0eXBlb2YgYm9keS5lcnJvci5kZXNjcmlwdGlvbiA9PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNBY3Rpb25FcnJvcihib2R5KSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGJvZHkpICYmIGlzUGxhaW5PYmplY3QoYm9keS5lcnJvcikgJiYgYm9keS5lcnJvci50eXBlID09PSBcImFjdGlvbkVycm9yXCIgJiYgdHlwZW9mIGJvZHkuZXJyb3IuZGVzY3JpcHRpb24gPT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KG9iaik7XG59XG5mdW5jdGlvbiBodHRwRXJyb3JNZXNzYWdlKHJlcykge1xuICBjb25zdCBzdGF0dXNNZXNzYWdlID0gcmVzLnN0YXR1c01lc3NhZ2UgPyBgICR7cmVzLnN0YXR1c01lc3NhZ2V9YCA6IFwiXCI7XG4gIHJldHVybiBgJHtyZXMubWV0aG9kfS1yZXF1ZXN0IHRvICR7cmVzLnVybH0gcmVzdWx0ZWQgaW4gSFRUUCAke3Jlcy5zdGF0dXNDb2RlfSR7c3RhdHVzTWVzc2FnZX1gO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5Qm9keShib2R5LCByZXMpIHtcbiAgcmV0dXJuIChyZXMuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpICE9PSAtMSA/IEpTT04uc3RyaW5naWZ5KGJvZHksIG51bGwsIDIpIDogYm9keTtcbn1cbmNsYXNzIENvcnNPcmlnaW5FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHJvamVjdElkO1xuICBhZGRPcmlnaW5Vcmw7XG4gIGNvbnN0cnVjdG9yKHsgcHJvamVjdElkOiBwcm9qZWN0SWQyIH0pIHtcbiAgICBzdXBlcihcIkNvcnNPcmlnaW5FcnJvclwiKSwgdGhpcy5uYW1lID0gXCJDb3JzT3JpZ2luRXJyb3JcIiwgdGhpcy5wcm9qZWN0SWQgPSBwcm9qZWN0SWQyO1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYGh0dHBzOi8vc2FuaXR5LmlvL21hbmFnZS9wcm9qZWN0LyR7cHJvamVjdElkMn0vYXBpYCk7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA8IFwidVwiKSB7XG4gICAgICBjb25zdCB7IG9yaWdpbiB9ID0gbG9jYXRpb247XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcImNvcnNcIiwgXCJhZGRcIiksIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwib3JpZ2luXCIsIG9yaWdpbiksIHRoaXMuYWRkT3JpZ2luVXJsID0gdXJsLCB0aGlzLm1lc3NhZ2UgPSBgVGhlIGN1cnJlbnQgb3JpZ2luIGlzIG5vdCBhbGxvd2VkIHRvIGNvbm5lY3QgdG8gdGhlIExpdmUgQ29udGVudCBBUEkuIEFkZCBpdCBoZXJlOiAke3VybH1gO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5tZXNzYWdlID0gYFRoZSBjdXJyZW50IG9yaWdpbiBpcyBub3QgYWxsb3dlZCB0byBjb25uZWN0IHRvIHRoZSBMaXZlIENvbnRlbnQgQVBJLiBDaGFuZ2UgeW91ciBjb25maWd1cmF0aW9uIGhlcmU6ICR7dXJsfWA7XG4gIH1cbn1cbmNvbnN0IGh0dHBFcnJvciA9IHtcbiAgb25SZXNwb25zZTogKHJlcykgPT4ge1xuICAgIGlmIChyZXMuc3RhdHVzQ29kZSA+PSA1MDApXG4gICAgICB0aHJvdyBuZXcgU2VydmVyRXJyb3IocmVzKTtcbiAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gNDAwKVxuICAgICAgdGhyb3cgbmV3IENsaWVudEVycm9yKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxufSwgcHJpbnRXYXJuaW5ncyA9IHtcbiAgb25SZXNwb25zZTogKHJlcykgPT4ge1xuICAgIGNvbnN0IHdhcm4gPSByZXMuaGVhZGVyc1tcIngtc2FuaXR5LXdhcm5pbmdcIl07XG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHdhcm4pID8gd2FybiA6IFt3YXJuXSkuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goKG1zZykgPT4gY29uc29sZS53YXJuKG1zZykpLCByZXM7XG4gIH1cbn07XG5mdW5jdGlvbiBkZWZpbmVIdHRwUmVxdWVzdChlbnZNaWRkbGV3YXJlMikge1xuICByZXR1cm4gZ2V0SXQoW1xuICAgIHJldHJ5KHsgc2hvdWxkUmV0cnkgfSksXG4gICAgLi4uZW52TWlkZGxld2FyZTIsXG4gICAgcHJpbnRXYXJuaW5ncyxcbiAgICBqc29uUmVxdWVzdCgpLFxuICAgIGpzb25SZXNwb25zZSgpLFxuICAgIHByb2dyZXNzKCksXG4gICAgaHR0cEVycm9yLFxuICAgIG9ic2VydmFibGUoeyBpbXBsZW1lbnRhdGlvbjogT2JzZXJ2YWJsZSB9KVxuICBdKTtcbn1cbmZ1bmN0aW9uIHNob3VsZFJldHJ5KGVyciwgYXR0ZW1wdCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5tYXhSZXRyaWVzID09PSAwKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgaXNTYWZlID0gb3B0aW9ucy5tZXRob2QgPT09IFwiR0VUXCIgfHwgb3B0aW9ucy5tZXRob2QgPT09IFwiSEVBRFwiLCBpc1F1ZXJ5ID0gKG9wdGlvbnMudXJpIHx8IG9wdGlvbnMudXJsKS5zdGFydHNXaXRoKFwiL2RhdGEvcXVlcnlcIiksIGlzUmV0cmlhYmxlUmVzcG9uc2UgPSBlcnIucmVzcG9uc2UgJiYgKGVyci5yZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkgfHwgZXJyLnJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDUwMiB8fCBlcnIucmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNTAzKTtcbiAgcmV0dXJuIChpc1NhZmUgfHwgaXNRdWVyeSkgJiYgaXNSZXRyaWFibGVSZXNwb25zZSA/ICEwIDogcmV0cnkuc2hvdWxkUmV0cnkoZXJyLCBhdHRlbXB0LCBvcHRpb25zKTtcbn1cbmNvbnN0IEJBU0VfVVJMID0gXCJodHRwczovL3d3dy5zYW5pdHkuaW8vaGVscC9cIjtcbmZ1bmN0aW9uIGdlbmVyYXRlSGVscFVybChzbHVnKSB7XG4gIHJldHVybiBCQVNFX1VSTCArIHNsdWc7XG59XG5jb25zdCBWQUxJRF9BU1NFVF9UWVBFUyA9IFtcImltYWdlXCIsIFwiZmlsZVwiXSwgVkFMSURfSU5TRVJUX0xPQ0FUSU9OUyA9IFtcImJlZm9yZVwiLCBcImFmdGVyXCIsIFwicmVwbGFjZVwiXSwgZGF0YXNldCA9IChuYW1lKSA9PiB7XG4gIGlmICghL14oflthLXowLTldezF9Wy1cXHddezAsNjN9fFthLXowLTldezF9Wy1cXHddezAsNjN9KSQvLnRlc3QobmFtZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJEYXRhc2V0cyBjYW4gb25seSBjb250YWluIGxvd2VyY2FzZSBjaGFyYWN0ZXJzLCBudW1iZXJzLCB1bmRlcnNjb3JlcyBhbmQgZGFzaGVzLCBhbmQgc3RhcnQgd2l0aCB0aWxkZSwgYW5kIGJlIG1heGltdW0gNjQgY2hhcmFjdGVyc1wiXG4gICAgKTtcbn0sIHByb2plY3RJZCA9IChpZCkgPT4ge1xuICBpZiAoIS9eWy1hLXowLTldKyQvaS50ZXN0KGlkKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgcHJvamVjdElkYCBjYW4gb25seSBjb250YWluIG9ubHkgYS16LCAwLTkgYW5kIGRhc2hlc1wiKTtcbn0sIHZhbGlkYXRlQXNzZXRUeXBlID0gKHR5cGUpID0+IHtcbiAgaWYgKFZBTElEX0FTU0VUX1RZUEVTLmluZGV4T2YodHlwZSkgPT09IC0xKVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3NldCB0eXBlOiAke3R5cGV9LiBNdXN0IGJlIG9uZSBvZiAke1ZBTElEX0FTU0VUX1RZUEVTLmpvaW4oXCIsIFwiKX1gKTtcbn0sIHZhbGlkYXRlT2JqZWN0ID0gKG9wLCB2YWwpID0+IHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheSh2YWwpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtvcH0oKSB0YWtlcyBhbiBvYmplY3Qgb2YgcHJvcGVydGllc2ApO1xufSwgdmFsaWRhdGVEb2N1bWVudElkID0gKG9wLCBpZCkgPT4ge1xuICBpZiAodHlwZW9mIGlkICE9IFwic3RyaW5nXCIgfHwgIS9eW2EtejAtOV9dW2EtejAtOV8uLV17MCwxMjd9JC9pLnRlc3QoaWQpIHx8IGlkLmluY2x1ZGVzKFwiLi5cIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke29wfSgpOiBcIiR7aWR9XCIgaXMgbm90IGEgdmFsaWQgZG9jdW1lbnQgSURgKTtcbn0sIHJlcXVpcmVEb2N1bWVudElkID0gKG9wLCBkb2MpID0+IHtcbiAgaWYgKCFkb2MuX2lkKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtvcH0oKSByZXF1aXJlcyB0aGF0IHRoZSBkb2N1bWVudCBjb250YWlucyBhbiBJRCAoXCJfaWRcIiBwcm9wZXJ0eSlgKTtcbiAgdmFsaWRhdGVEb2N1bWVudElkKG9wLCBkb2MuX2lkKTtcbn0sIHZhbGlkYXRlSW5zZXJ0ID0gKGF0LCBzZWxlY3RvciwgaXRlbXMpID0+IHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gXCJpbnNlcnQoYXQsIHNlbGVjdG9yLCBpdGVtcylcIjtcbiAgaWYgKFZBTElEX0lOU0VSVF9MT0NBVElPTlMuaW5kZXhPZihhdCkgPT09IC0xKSB7XG4gICAgY29uc3QgdmFsaWQgPSBWQUxJRF9JTlNFUlRfTE9DQVRJT05TLm1hcCgobG9jKSA9PiBgXCIke2xvY31cImApLmpvaW4oXCIsIFwiKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c2lnbmF0dXJlfSB0YWtlcyBhbiBcImF0XCItYXJndW1lbnQgd2hpY2ggaXMgb25lIG9mOiAke3ZhbGlkfWApO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c2lnbmF0dXJlfSB0YWtlcyBhIFwic2VsZWN0b3JcIi1hcmd1bWVudCB3aGljaCBtdXN0IGJlIGEgc3RyaW5nYCk7XG4gIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3NpZ25hdHVyZX0gdGFrZXMgYW4gXCJpdGVtc1wiLWFyZ3VtZW50IHdoaWNoIG11c3QgYmUgYW4gYXJyYXlgKTtcbn0sIGhhc0RhdGFzZXQgPSAoY29uZmlnKSA9PiB7XG4gIGlmICghY29uZmlnLmRhdGFzZXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYGRhdGFzZXRgIG11c3QgYmUgcHJvdmlkZWQgdG8gcGVyZm9ybSBxdWVyaWVzXCIpO1xuICByZXR1cm4gY29uZmlnLmRhdGFzZXQgfHwgXCJcIjtcbn0sIHJlcXVlc3RUYWcgPSAodGFnKSA9PiB7XG4gIGlmICh0eXBlb2YgdGFnICE9IFwic3RyaW5nXCIgfHwgIS9eW2EtejAtOS5fLV17MSw3NX0kL2kudGVzdCh0YWcpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGFnIGNhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMsIHVuZGVyc2NvcmVzLCBkYXNoZXMgYW5kIGRvdHMsIGFuZCBiZSBiZXR3ZWVuIG9uZSBhbmQgNzUgY2hhcmFjdGVycyBsb25nLlwiXG4gICAgKTtcbiAgcmV0dXJuIHRhZztcbn07XG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gIGxldCBkaWRDYWxsID0gITEsIHJldHVyblZhbHVlO1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IChkaWRDYWxsIHx8IChyZXR1cm5WYWx1ZSA9IGZuKC4uLmFyZ3MpLCBkaWRDYWxsID0gITApLCByZXR1cm5WYWx1ZSk7XG59XG5jb25zdCBjcmVhdGVXYXJuaW5nUHJpbnRlciA9IChtZXNzYWdlKSA9PiAoXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIG9uY2UoKC4uLmFyZ3MpID0+IGNvbnNvbGUud2FybihtZXNzYWdlLmpvaW4oXCIgXCIpLCAuLi5hcmdzKSlcbiksIHByaW50Q2RuQW5kV2l0aENyZWRlbnRpYWxzV2FybmluZyA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFtcbiAgXCJCZWNhdXNlIHlvdSBzZXQgYHdpdGhDcmVkZW50aWFsc2AgdG8gdHJ1ZSwgd2Ugd2lsbCBvdmVycmlkZSB5b3VyIGB1c2VDZG5gXCIsXG4gIFwic2V0dGluZyB0byBiZSBmYWxzZSBzaW5jZSAoY29va2llLWJhc2VkKSBjcmVkZW50aWFscyBhcmUgbmV2ZXIgc2V0IG9uIHRoZSBDRE5cIlxuXSksIHByaW50Q2RuV2FybmluZyA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFtcbiAgXCJTaW5jZSB5b3UgaGF2ZW4ndCBzZXQgYSB2YWx1ZSBmb3IgYHVzZUNkbmAsIHdlIHdpbGwgZGVsaXZlciBjb250ZW50IHVzaW5nIG91clwiLFxuICBcImdsb2JhbCwgZWRnZS1jYWNoZWQgQVBJLUNETi4gSWYgeW91IHdpc2ggdG8gaGF2ZSBjb250ZW50IGRlbGl2ZXJlZCBmYXN0ZXIsIHNldFwiLFxuICBcImB1c2VDZG46IGZhbHNlYCB0byB1c2UgdGhlIExpdmUgQVBJLiBOb3RlOiBZb3UgbWF5IGluY3VyIGhpZ2hlciBjb3N0cyB1c2luZyB0aGUgbGl2ZSBBUEkuXCJcbl0pLCBwcmludENkblByZXZpZXdEcmFmdHNXYXJuaW5nID0gY3JlYXRlV2FybmluZ1ByaW50ZXIoW1xuICBcIlRoZSBTYW5pdHkgY2xpZW50IGlzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgYHBlcnNwZWN0aXZlYCBzZXQgdG8gYHByZXZpZXdEcmFmdHNgLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgdGhlIEFQSS1DRE4uXCIsXG4gIFwiVGhlIExpdmUgQVBJIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBTZXQgYHVzZUNkbjogZmFsc2VgIGluIHlvdXIgY29uZmlndXJhdGlvbiB0byBoaWRlIHRoaXMgd2FybmluZy5cIlxuXSksIHByaW50QnJvd3NlclRva2VuV2FybmluZyA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFtcbiAgXCJZb3UgaGF2ZSBjb25maWd1cmVkIFNhbml0eSBjbGllbnQgdG8gdXNlIGEgdG9rZW4gaW4gdGhlIGJyb3dzZXIuIFRoaXMgbWF5IGNhdXNlIHVuaW50ZW50aW9uYWwgc2VjdXJpdHkgaXNzdWVzLlwiLFxuICBgU2VlICR7Z2VuZXJhdGVIZWxwVXJsKFxuICAgIFwianMtY2xpZW50LWJyb3dzZXItdG9rZW5cIlxuICApfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgaG93IHRvIGhpZGUgdGhpcyB3YXJuaW5nLmBcbl0pLCBwcmludE5vQXBpVmVyc2lvblNwZWNpZmllZFdhcm5pbmcgPSBjcmVhdGVXYXJuaW5nUHJpbnRlcihbXG4gIFwiVXNpbmcgdGhlIFNhbml0eSBjbGllbnQgd2l0aG91dCBzcGVjaWZ5aW5nIGFuIEFQSSB2ZXJzaW9uIGlzIGRlcHJlY2F0ZWQuXCIsXG4gIGBTZWUgJHtnZW5lcmF0ZUhlbHBVcmwoXCJqcy1jbGllbnQtYXBpLXZlcnNpb25cIil9YFxuXSksIHByaW50Tm9EZWZhdWx0RXhwb3J0ID0gY3JlYXRlV2FybmluZ1ByaW50ZXIoW1xuICBcIlRoZSBkZWZhdWx0IGV4cG9ydCBvZiBAc2FuaXR5L2NsaWVudCBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgdGhlIG5hbWVkIGV4cG9ydCBgY3JlYXRlQ2xpZW50YCBpbnN0ZWFkLlwiXG5dKSwgZGVmYXVsdENkbkhvc3QgPSBcImFwaWNkbi5zYW5pdHkuaW9cIiwgZGVmYXVsdENvbmZpZyA9IHtcbiAgYXBpSG9zdDogXCJodHRwczovL2FwaS5zYW5pdHkuaW9cIixcbiAgYXBpVmVyc2lvbjogXCIxXCIsXG4gIHVzZVByb2plY3RIb3N0bmFtZTogITAsXG4gIHN0ZWdhOiB7IGVuYWJsZWQ6ICExIH1cbn0sIExPQ0FMSE9TVFMgPSBbXCJsb2NhbGhvc3RcIiwgXCIxMjcuMC4wLjFcIiwgXCIwLjAuMC4wXCJdLCBpc0xvY2FsID0gKGhvc3QpID0+IExPQ0FMSE9TVFMuaW5kZXhPZihob3N0KSAhPT0gLTE7XG5mdW5jdGlvbiB2YWxpZGF0ZUFwaVZlcnNpb24oYXBpVmVyc2lvbikge1xuICBpZiAoYXBpVmVyc2lvbiA9PT0gXCIxXCIgfHwgYXBpVmVyc2lvbiA9PT0gXCJYXCIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBhcGlEYXRlID0gbmV3IERhdGUoYXBpVmVyc2lvbik7XG4gIGlmICghKC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLy50ZXN0KGFwaVZlcnNpb24pICYmIGFwaURhdGUgaW5zdGFuY2VvZiBEYXRlICYmIGFwaURhdGUuZ2V0VGltZSgpID4gMCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBBUEkgdmVyc2lvbiBzdHJpbmcsIGV4cGVjdGVkIGAxYCBvciBkYXRlIGluIGZvcm1hdCBgWVlZWS1NTS1ERGBcIik7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFwaVBlcnNwZWN0aXZlKHBlcnNwZWN0aXZlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBlcnNwZWN0aXZlKSkge1xuICAgIGZvciAoY29uc3QgcGVyc3BlY3RpdmVWYWx1ZSBvZiBwZXJzcGVjdGl2ZSlcbiAgICAgIGlmIChwZXJzcGVjdGl2ZVZhbHVlICE9PSBcInB1Ymxpc2hlZFwiICYmIHBlcnNwZWN0aXZlVmFsdWUgIT09IFwiZHJhZnRzXCIgJiYgISh0eXBlb2YgcGVyc3BlY3RpdmVWYWx1ZSA9PSBcInN0cmluZ1wiICYmIHBlcnNwZWN0aXZlVmFsdWUuc3RhcnRzV2l0aChcInJcIikgJiYgcGVyc3BlY3RpdmVWYWx1ZSAhPT0gXCJyYXdcIikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIEFQSSBwZXJzcGVjdGl2ZSB2YWx1ZSwgZXhwZWN0ZWQgYHB1Ymxpc2hlZGAsIGBkcmFmdHNgIG9yIGEgdmFsaWQgcmVsZWFzZSBpZGVudGlmaWVyIHN0cmluZ1wiXG4gICAgICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN3aXRjaCAocGVyc3BlY3RpdmUpIHtcbiAgICBjYXNlIFwicHJldmlld0RyYWZ0c1wiOlxuICAgIGNhc2UgXCJkcmFmdHNcIjpcbiAgICBjYXNlIFwicHVibGlzaGVkXCI6XG4gICAgY2FzZSBcInJhd1wiOlxuICAgICAgcmV0dXJuO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkludmFsaWQgQVBJIHBlcnNwZWN0aXZlIHN0cmluZywgZXhwZWN0ZWQgYHB1Ymxpc2hlZGAsIGBwcmV2aWV3RHJhZnRzYCBvciBgcmF3YFwiXG4gICAgICApO1xuICB9XG59XG5jb25zdCBpbml0Q29uZmlnID0gKGNvbmZpZywgcHJldkNvbmZpZykgPT4ge1xuICBjb25zdCBzcGVjaWZpZWRDb25maWcgPSB7XG4gICAgLi4ucHJldkNvbmZpZyxcbiAgICAuLi5jb25maWcsXG4gICAgc3RlZ2E6IHtcbiAgICAgIC4uLnR5cGVvZiBwcmV2Q29uZmlnLnN0ZWdhID09IFwiYm9vbGVhblwiID8geyBlbmFibGVkOiBwcmV2Q29uZmlnLnN0ZWdhIH0gOiBwcmV2Q29uZmlnLnN0ZWdhIHx8IGRlZmF1bHRDb25maWcuc3RlZ2EsXG4gICAgICAuLi50eXBlb2YgY29uZmlnLnN0ZWdhID09IFwiYm9vbGVhblwiID8geyBlbmFibGVkOiBjb25maWcuc3RlZ2EgfSA6IGNvbmZpZy5zdGVnYSB8fCB7fVxuICAgIH1cbiAgfTtcbiAgc3BlY2lmaWVkQ29uZmlnLmFwaVZlcnNpb24gfHwgcHJpbnROb0FwaVZlcnNpb25TcGVjaWZpZWRXYXJuaW5nKCk7XG4gIGNvbnN0IG5ld0NvbmZpZyA9IHtcbiAgICAuLi5kZWZhdWx0Q29uZmlnLFxuICAgIC4uLnNwZWNpZmllZENvbmZpZ1xuICB9LCBwcm9qZWN0QmFzZWQgPSBuZXdDb25maWcudXNlUHJvamVjdEhvc3RuYW1lO1xuICBpZiAodHlwZW9mIFByb21pc2UgPiBcInVcIikge1xuICAgIGNvbnN0IGhlbHBVcmwgPSBnZW5lcmF0ZUhlbHBVcmwoXCJqcy1jbGllbnQtcHJvbWlzZS1wb2x5ZmlsbFwiKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG5hdGl2ZSBQcm9taXNlLWltcGxlbWVudGF0aW9uIGZvdW5kLCBwb2x5ZmlsbCBuZWVkZWQgLSBzZWUgJHtoZWxwVXJsfWApO1xuICB9XG4gIGlmIChwcm9qZWN0QmFzZWQgJiYgIW5ld0NvbmZpZy5wcm9qZWN0SWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZmlndXJhdGlvbiBtdXN0IGNvbnRhaW4gYHByb2plY3RJZGBcIik7XG4gIGlmICh0eXBlb2YgbmV3Q29uZmlnLnBlcnNwZWN0aXZlIDwgXCJ1XCIgJiYgdmFsaWRhdGVBcGlQZXJzcGVjdGl2ZShuZXdDb25maWcucGVyc3BlY3RpdmUpLCBcImVuY29kZVNvdXJjZU1hcFwiIGluIG5ld0NvbmZpZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIG9wdGlvbnMgbWVhbnQgZm9yICdAc2FuaXR5L3ByZXZpZXcta2l0L2NsaWVudCcuICdlbmNvZGVTb3VyY2VNYXAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gJ0BzYW5pdHkvY2xpZW50Jy4gRGlkIHlvdSBtZWFuICdzdGVnYS5lbmFibGVkJz9cIlxuICAgICk7XG4gIGlmIChcImVuY29kZVNvdXJjZU1hcEF0UGF0aFwiIGluIG5ld0NvbmZpZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIG9wdGlvbnMgbWVhbnQgZm9yICdAc2FuaXR5L3ByZXZpZXcta2l0L2NsaWVudCcuICdlbmNvZGVTb3VyY2VNYXBBdFBhdGgnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gJ0BzYW5pdHkvY2xpZW50Jy4gRGlkIHlvdSBtZWFuICdzdGVnYS5maWx0ZXInP1wiXG4gICAgKTtcbiAgaWYgKHR5cGVvZiBuZXdDb25maWcuc3RlZ2EuZW5hYmxlZCAhPSBcImJvb2xlYW5cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHN0ZWdhLmVuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4sIHJlY2VpdmVkICR7bmV3Q29uZmlnLnN0ZWdhLmVuYWJsZWR9YCk7XG4gIGlmIChuZXdDb25maWcuc3RlZ2EuZW5hYmxlZCAmJiBuZXdDb25maWcuc3RlZ2Euc3R1ZGlvVXJsID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwic3RlZ2Euc3R1ZGlvVXJsIG11c3QgYmUgZGVmaW5lZCB3aGVuIHN0ZWdhLmVuYWJsZWQgaXMgdHJ1ZVwiKTtcbiAgaWYgKG5ld0NvbmZpZy5zdGVnYS5lbmFibGVkICYmIHR5cGVvZiBuZXdDb25maWcuc3RlZ2Euc3R1ZGlvVXJsICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIG5ld0NvbmZpZy5zdGVnYS5zdHVkaW9VcmwgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBzdGVnYS5zdHVkaW9VcmwgbXVzdCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLCByZWNlaXZlZCAke25ld0NvbmZpZy5zdGVnYS5zdHVkaW9Vcmx9YFxuICAgICk7XG4gIGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLCBpc0xvY2FsaG9zdCA9IGlzQnJvd3NlciAmJiBpc0xvY2FsKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gIGlzQnJvd3NlciAmJiBpc0xvY2FsaG9zdCAmJiBuZXdDb25maWcudG9rZW4gJiYgbmV3Q29uZmlnLmlnbm9yZUJyb3dzZXJUb2tlbldhcm5pbmcgIT09ICEwID8gcHJpbnRCcm93c2VyVG9rZW5XYXJuaW5nKCkgOiB0eXBlb2YgbmV3Q29uZmlnLnVzZUNkbiA+IFwidVwiICYmIHByaW50Q2RuV2FybmluZygpLCBwcm9qZWN0QmFzZWQgJiYgcHJvamVjdElkKG5ld0NvbmZpZy5wcm9qZWN0SWQpLCBuZXdDb25maWcuZGF0YXNldCAmJiBkYXRhc2V0KG5ld0NvbmZpZy5kYXRhc2V0KSwgXCJyZXF1ZXN0VGFnUHJlZml4XCIgaW4gbmV3Q29uZmlnICYmIChuZXdDb25maWcucmVxdWVzdFRhZ1ByZWZpeCA9IG5ld0NvbmZpZy5yZXF1ZXN0VGFnUHJlZml4ID8gcmVxdWVzdFRhZyhuZXdDb25maWcucmVxdWVzdFRhZ1ByZWZpeCkucmVwbGFjZSgvXFwuKyQvLCBcIlwiKSA6IHZvaWQgMCksIG5ld0NvbmZpZy5hcGlWZXJzaW9uID0gYCR7bmV3Q29uZmlnLmFwaVZlcnNpb259YC5yZXBsYWNlKC9edi8sIFwiXCIpLCBuZXdDb25maWcuaXNEZWZhdWx0QXBpID0gbmV3Q29uZmlnLmFwaUhvc3QgPT09IGRlZmF1bHRDb25maWcuYXBpSG9zdCwgbmV3Q29uZmlnLnVzZUNkbiA9PT0gITAgJiYgbmV3Q29uZmlnLndpdGhDcmVkZW50aWFscyAmJiBwcmludENkbkFuZFdpdGhDcmVkZW50aWFsc1dhcm5pbmcoKSwgbmV3Q29uZmlnLnVzZUNkbiA9IG5ld0NvbmZpZy51c2VDZG4gIT09ICExICYmICFuZXdDb25maWcud2l0aENyZWRlbnRpYWxzLCB2YWxpZGF0ZUFwaVZlcnNpb24obmV3Q29uZmlnLmFwaVZlcnNpb24pO1xuICBjb25zdCBob3N0UGFydHMgPSBuZXdDb25maWcuYXBpSG9zdC5zcGxpdChcIjovL1wiLCAyKSwgcHJvdG9jb2wgPSBob3N0UGFydHNbMF0sIGhvc3QgPSBob3N0UGFydHNbMV0sIGNkbkhvc3QgPSBuZXdDb25maWcuaXNEZWZhdWx0QXBpID8gZGVmYXVsdENkbkhvc3QgOiBob3N0O1xuICByZXR1cm4gbmV3Q29uZmlnLnVzZVByb2plY3RIb3N0bmFtZSA/IChuZXdDb25maWcudXJsID0gYCR7cHJvdG9jb2x9Oi8vJHtuZXdDb25maWcucHJvamVjdElkfS4ke2hvc3R9L3Yke25ld0NvbmZpZy5hcGlWZXJzaW9ufWAsIG5ld0NvbmZpZy5jZG5VcmwgPSBgJHtwcm90b2NvbH06Ly8ke25ld0NvbmZpZy5wcm9qZWN0SWR9LiR7Y2RuSG9zdH0vdiR7bmV3Q29uZmlnLmFwaVZlcnNpb259YCkgOiAobmV3Q29uZmlnLnVybCA9IGAke25ld0NvbmZpZy5hcGlIb3N0fS92JHtuZXdDb25maWcuYXBpVmVyc2lvbn1gLCBuZXdDb25maWcuY2RuVXJsID0gbmV3Q29uZmlnLnVybCksIG5ld0NvbmZpZztcbn07XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24oc2VsKSB7XG4gIGlmICh0eXBlb2Ygc2VsID09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHsgaWQ6IHNlbCB9O1xuICBpZiAoQXJyYXkuaXNBcnJheShzZWwpKVxuICAgIHJldHVybiB7IHF1ZXJ5OiBcIipbX2lkIGluICRpZHNdXCIsIHBhcmFtczogeyBpZHM6IHNlbCB9IH07XG4gIGlmICh0eXBlb2Ygc2VsID09IFwib2JqZWN0XCIgJiYgc2VsICE9PSBudWxsICYmIFwicXVlcnlcIiBpbiBzZWwgJiYgdHlwZW9mIHNlbC5xdWVyeSA9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBcInBhcmFtc1wiIGluIHNlbCAmJiB0eXBlb2Ygc2VsLnBhcmFtcyA9PSBcIm9iamVjdFwiICYmIHNlbC5wYXJhbXMgIT09IG51bGwgPyB7IHF1ZXJ5OiBzZWwucXVlcnksIHBhcmFtczogc2VsLnBhcmFtcyB9IDogeyBxdWVyeTogc2VsLnF1ZXJ5IH07XG4gIGNvbnN0IHNlbGVjdGlvbk9wdHMgPSBbXG4gICAgXCIqIERvY3VtZW50IElEICg8ZG9jSWQ+KVwiLFxuICAgIFwiKiBBcnJheSBvZiBkb2N1bWVudCBJRHNcIixcbiAgICBcIiogT2JqZWN0IGNvbnRhaW5pbmcgYHF1ZXJ5YFwiXG4gIF0uam9pbihgXG5gKTtcbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNlbGVjdGlvbiAtIG11c3QgYmUgb25lIG9mOlxuXG4ke3NlbGVjdGlvbk9wdHN9YCk7XG59XG5jbGFzcyBCYXNlUGF0Y2gge1xuICBzZWxlY3Rpb247XG4gIG9wZXJhdGlvbnM7XG4gIGNvbnN0cnVjdG9yKHNlbGVjdGlvbiwgb3BlcmF0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb24sIHRoaXMub3BlcmF0aW9ucyA9IG9wZXJhdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgdG8gdGhlIGRvY3VtZW50LiBEb2VzIE5PVCBtZXJnZSBvYmplY3RzLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHBhdGNoLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyAtIEF0dHJpYnV0ZXMgdG8gc2V0LiBUbyBzZXQgYSBkZWVwIGF0dHJpYnV0ZSwgdXNlIEpTT05NYXRjaCwgZWc6IFxce1wibmVzdGVkLnByb3BcIjogXCJ2YWx1ZVwiXFx9XG4gICAqL1xuICBzZXQoYXR0cnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYXNzaWduKFwic2V0XCIsIGF0dHJzKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyB0byB0aGUgZG9jdW1lbnQgaWYgdGhleSBhcmUgbm90IGN1cnJlbnRseSBzZXQuIERvZXMgTk9UIG1lcmdlIG9iamVjdHMuXG4gICAqIFRoZSBvcGVyYXRpb24gaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnQgcGF0Y2gsIHJlYWR5IHRvIGJlIGNvbW1pdGVkIGJ5IGBjb21taXQoKWBcbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIC0gQXR0cmlidXRlcyB0byBzZXQuIFRvIHNldCBhIGRlZXAgYXR0cmlidXRlLCB1c2UgSlNPTk1hdGNoLCBlZzogXFx7XCJuZXN0ZWQucHJvcFwiOiBcInZhbHVlXCJcXH1cbiAgICovXG4gIHNldElmTWlzc2luZyhhdHRycykge1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24oXCJzZXRJZk1pc3NpbmdcIiwgYXR0cnMpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIFwiZGlmZi1tYXRjaC1wYXRjaFwiIG9wZXJhdGlvbiBvbiB0aGUgc3RyaW5nIGF0dHJpYnV0ZXMgcHJvdmlkZWQuXG4gICAqIFRoZSBvcGVyYXRpb24gaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnQgcGF0Y2gsIHJlYWR5IHRvIGJlIGNvbW1pdGVkIGJ5IGBjb21taXQoKWBcbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIC0gQXR0cmlidXRlcyB0byBwZXJmb3JtIG9wZXJhdGlvbiBvbi4gVG8gc2V0IGEgZGVlcCBhdHRyaWJ1dGUsIHVzZSBKU09OTWF0Y2gsIGVnOiBcXHtcIm5lc3RlZC5wcm9wXCI6IFwiZG1wXCJcXH1cbiAgICovXG4gIGRpZmZNYXRjaFBhdGNoKGF0dHJzKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KFwiZGlmZk1hdGNoUGF0Y2hcIiwgYXR0cnMpLCB0aGlzLl9hc3NpZ24oXCJkaWZmTWF0Y2hQYXRjaFwiLCBhdHRycyk7XG4gIH1cbiAgLyoqXG4gICAqIFVuc2V0cyB0aGUgYXR0cmlidXRlIHBhdGhzIHByb3ZpZGVkLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHBhdGNoLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyAtIEF0dHJpYnV0ZSBwYXRocyB0byB1bnNldC5cbiAgICovXG4gIHVuc2V0KGF0dHJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGF0dHJzKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc2V0KGF0dHJzKSB0YWtlcyBhbiBhcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHVuc2V0LCBub24tYXJyYXkgZ2l2ZW5cIik7XG4gICAgcmV0dXJuIHRoaXMub3BlcmF0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3BlcmF0aW9ucywgeyB1bnNldDogYXR0cnMgfSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEluY3JlbWVudCBhIG51bWVyaWMgdmFsdWUuIEVhY2ggZW50cnkgaW4gdGhlIGFyZ3VtZW50IGlzIGVpdGhlciBhbiBhdHRyaWJ1dGUgb3IgYSBKU09OIHBhdGguIFRoZSB2YWx1ZSBtYXkgYmUgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLiBUaGUgb3BlcmF0aW9uIHdpbGwgZmFpbCBpZiB0YXJnZXQgdmFsdWUgaXMgbm90IGEgbnVtZXJpYyB2YWx1ZSwgb3IgZG9lc24ndCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIC0gT2JqZWN0IG9mIGF0dHJpYnV0ZSBwYXRocyB0byBpbmNyZW1lbnQsIHZhbHVlcyByZXByZXNlbnRpbmcgdGhlIG51bWJlciB0byBpbmNyZW1lbnQgYnkuXG4gICAqL1xuICBpbmMoYXR0cnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYXNzaWduKFwiaW5jXCIsIGF0dHJzKTtcbiAgfVxuICAvKipcbiAgICogRGVjcmVtZW50IGEgbnVtZXJpYyB2YWx1ZS4gRWFjaCBlbnRyeSBpbiB0aGUgYXJndW1lbnQgaXMgZWl0aGVyIGFuIGF0dHJpYnV0ZSBvciBhIEpTT04gcGF0aC4gVGhlIHZhbHVlIG1heSBiZSBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuIFRoZSBvcGVyYXRpb24gd2lsbCBmYWlsIGlmIHRhcmdldCB2YWx1ZSBpcyBub3QgYSBudW1lcmljIHZhbHVlLCBvciBkb2Vzbid0IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgLSBPYmplY3Qgb2YgYXR0cmlidXRlIHBhdGhzIHRvIGRlY3JlbWVudCwgdmFsdWVzIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIHRvIGRlY3JlbWVudCBieS5cbiAgICovXG4gIGRlYyhhdHRycykge1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24oXCJkZWNcIiwgYXR0cnMpO1xuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBtZXRob2RzIGZvciBtb2RpZnlpbmcgYXJyYXlzLCBieSBpbnNlcnRpbmcsIGFwcGVuZGluZyBhbmQgcmVwbGFjaW5nIGVsZW1lbnRzIHZpYSBhIEpTT05QYXRoIGV4cHJlc3Npb24uXG4gICAqXG4gICAqIEBwYXJhbSBhdCAtIExvY2F0aW9uIHRvIGluc2VydCBhdCwgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHNlbGVjdG9yLCBvciAncmVwbGFjZScgdGhlIG1hdGNoZWQgcGF0aFxuICAgKiBAcGFyYW0gc2VsZWN0b3IgLSBKU09OUGF0aCBleHByZXNzaW9uLCBlZyBgY29tbWVudHNbLTFdYCBvciBgYmxvY2tzW19rZXk9PVwiYWJjMTIzXCJdYFxuICAgKiBAcGFyYW0gaXRlbXMgLSBBcnJheSBvZiBpdGVtcyB0byBpbnNlcnQvcmVwbGFjZVxuICAgKi9cbiAgaW5zZXJ0KGF0LCBzZWxlY3RvciwgaXRlbXMpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVJbnNlcnQoYXQsIHNlbGVjdG9yLCBpdGVtcyksIHRoaXMuX2Fzc2lnbihcImluc2VydFwiLCB7IFthdF06IHNlbGVjdG9yLCBpdGVtcyB9KTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kIHRoZSBnaXZlbiBpdGVtcyB0byB0aGUgYXJyYXkgYXQgdGhlIGdpdmVuIEpTT05QYXRoXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3RvciAtIEF0dHJpYnV0ZS9wYXRoIHRvIGFwcGVuZCB0bywgZWcgYGNvbW1lbnRzYCBvciBgcGVyc29uLmhvYmJpZXNgXG4gICAqIEBwYXJhbSBpdGVtcyAtIEFycmF5IG9mIGl0ZW1zIHRvIGFwcGVuZCB0byB0aGUgYXJyYXlcbiAgICovXG4gIGFwcGVuZChzZWxlY3RvciwgaXRlbXMpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoXCJhZnRlclwiLCBgJHtzZWxlY3Rvcn1bLTFdYCwgaXRlbXMpO1xuICB9XG4gIC8qKlxuICAgKiBQcmVwZW5kIHRoZSBnaXZlbiBpdGVtcyB0byB0aGUgYXJyYXkgYXQgdGhlIGdpdmVuIEpTT05QYXRoXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3RvciAtIEF0dHJpYnV0ZS9wYXRoIHRvIHByZXBlbmQgdG8sIGVnIGBjb21tZW50c2Agb3IgYHBlcnNvbi5ob2JiaWVzYFxuICAgKiBAcGFyYW0gaXRlbXMgLSBBcnJheSBvZiBpdGVtcyB0byBwcmVwZW5kIHRvIHRoZSBhcnJheVxuICAgKi9cbiAgcHJlcGVuZChzZWxlY3RvciwgaXRlbXMpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoXCJiZWZvcmVcIiwgYCR7c2VsZWN0b3J9WzBdYCwgaXRlbXMpO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGNvbnRlbnRzIG9mIGFuIGFycmF5IGJ5IHJlbW92aW5nIGV4aXN0aW5nIGVsZW1lbnRzIGFuZC9vciBhZGRpbmcgbmV3IGVsZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgLSBBdHRyaWJ1dGUgb3IgSlNPTlBhdGggZXhwcmVzc2lvbiBmb3IgYXJyYXlcbiAgICogQHBhcmFtIHN0YXJ0IC0gSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgY2hhbmdpbmcgdGhlIGFycmF5ICh3aXRoIG9yaWdpbiAwKS4gSWYgZ3JlYXRlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LCBhY3R1YWwgc3RhcnRpbmcgaW5kZXggd2lsbCBiZSBzZXQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuIElmIG5lZ2F0aXZlLCB3aWxsIGJlZ2luIHRoYXQgbWFueSBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5ICh3aXRoIG9yaWdpbiAtMSkgYW5kIHdpbGwgYmUgc2V0IHRvIDAgaWYgYWJzb2x1dGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LnhcbiAgICogQHBhcmFtIGRlbGV0ZUNvdW50IC0gQW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBudW1iZXIgb2Ygb2xkIGFycmF5IGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIGl0ZW1zIC0gVGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgYXJyYXksIGJlZ2lubmluZyBhdCB0aGUgc3RhcnQgaW5kZXguIElmIHlvdSBkb24ndCBzcGVjaWZ5IGFueSBlbGVtZW50cywgc3BsaWNlKCkgd2lsbCBvbmx5IHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBhcnJheS5cbiAgICovXG4gIHNwbGljZShzZWxlY3Rvciwgc3RhcnQsIGRlbGV0ZUNvdW50LCBpdGVtcykge1xuICAgIGNvbnN0IGRlbEFsbCA9IHR5cGVvZiBkZWxldGVDb3VudCA+IFwidVwiIHx8IGRlbGV0ZUNvdW50ID09PSAtMSwgc3RhcnRJbmRleCA9IHN0YXJ0IDwgMCA/IHN0YXJ0IC0gMSA6IHN0YXJ0LCBkZWxDb3VudCA9IGRlbEFsbCA/IC0xIDogTWF0aC5tYXgoMCwgc3RhcnQgKyBkZWxldGVDb3VudCksIGRlbFJhbmdlID0gc3RhcnRJbmRleCA8IDAgJiYgZGVsQ291bnQgPj0gMCA/IFwiXCIgOiBkZWxDb3VudCwgcmFuZ2VTZWxlY3RvciA9IGAke3NlbGVjdG9yfVske3N0YXJ0SW5kZXh9OiR7ZGVsUmFuZ2V9XWA7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KFwicmVwbGFjZVwiLCByYW5nZVNlbGVjdG9yLCBpdGVtcyB8fCBbXSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSByZXZpc2lvbiBjbGF1c2UsIHByZXZlbnRpbmcgdGhlIGRvY3VtZW50IGZyb20gYmVpbmcgcGF0Y2hlZCBpZiB0aGUgYF9yZXZgIHByb3BlcnR5IGRvZXMgbm90IG1hdGNoIHRoZSBnaXZlbiB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0gcmV2IC0gUmV2aXNpb24gdG8gbG9jayB0aGUgcGF0Y2ggdG9cbiAgICovXG4gIGlmUmV2aXNpb25JZChyZXYpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zLmlmUmV2aXNpb25JRCA9IHJldiwgdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgcGxhaW4gSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgcGF0Y2hcbiAgICovXG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4geyAuLi5nZXRTZWxlY3Rpb24odGhpcy5zZWxlY3Rpb24pLCAuLi50aGlzLm9wZXJhdGlvbnMgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgcGxhaW4gSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgcGF0Y2hcbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBwYXRjaCBvZiBhbGwgb3BlcmF0aW9uc1xuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3BlcmF0aW9ucyA9IHt9LCB0aGlzO1xuICB9XG4gIF9hc3NpZ24ob3AsIHByb3BzLCBtZXJnZSA9ICEwKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KG9wLCBwcm9wcyksIHRoaXMub3BlcmF0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3BlcmF0aW9ucywge1xuICAgICAgW29wXTogT2JqZWN0LmFzc2lnbih7fSwgbWVyZ2UgJiYgdGhpcy5vcGVyYXRpb25zW29wXSB8fCB7fSwgcHJvcHMpXG4gICAgfSksIHRoaXM7XG4gIH1cbiAgX3NldChvcCwgcHJvcHMpIHtcbiAgICByZXR1cm4gdGhpcy5fYXNzaWduKG9wLCBwcm9wcywgITEpO1xuICB9XG59XG5jbGFzcyBPYnNlcnZhYmxlUGF0Y2ggZXh0ZW5kcyBCYXNlUGF0Y2gge1xuICAjY2xpZW50O1xuICBjb25zdHJ1Y3RvcihzZWxlY3Rpb24sIG9wZXJhdGlvbnMsIGNsaWVudCkge1xuICAgIHN1cGVyKHNlbGVjdGlvbiwgb3BlcmF0aW9ucyksIHRoaXMuI2NsaWVudCA9IGNsaWVudDtcbiAgfVxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBwYXRjaFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlUGF0Y2godGhpcy5zZWxlY3Rpb24sIHsgLi4udGhpcy5vcGVyYXRpb25zIH0sIHRoaXMuI2NsaWVudCk7XG4gIH1cbiAgY29tbWl0KG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuI2NsaWVudClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJObyBgY2xpZW50YCBwYXNzZWQgdG8gcGF0Y2gsIGVpdGhlciBwcm92aWRlIG9uZSBvciBwYXNzIHRoZSBwYXRjaCB0byBhIGNsaWVudHMgYG11dGF0ZSgpYCBtZXRob2RcIlxuICAgICAgKTtcbiAgICBjb25zdCByZXR1cm5GaXJzdCA9IHR5cGVvZiB0aGlzLnNlbGVjdGlvbiA9PSBcInN0cmluZ1wiLCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHJldHVybkZpcnN0LCByZXR1cm5Eb2N1bWVudHM6ICEwIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLiNjbGllbnQubXV0YXRlKHsgcGF0Y2g6IHRoaXMuc2VyaWFsaXplKCkgfSwgb3B0cyk7XG4gIH1cbn1cbmNsYXNzIFBhdGNoIGV4dGVuZHMgQmFzZVBhdGNoIHtcbiAgI2NsaWVudDtcbiAgY29uc3RydWN0b3Ioc2VsZWN0aW9uLCBvcGVyYXRpb25zLCBjbGllbnQpIHtcbiAgICBzdXBlcihzZWxlY3Rpb24sIG9wZXJhdGlvbnMpLCB0aGlzLiNjbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgcGF0Y2hcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUGF0Y2godGhpcy5zZWxlY3Rpb24sIHsgLi4udGhpcy5vcGVyYXRpb25zIH0sIHRoaXMuI2NsaWVudCk7XG4gIH1cbiAgY29tbWl0KG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuI2NsaWVudClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJObyBgY2xpZW50YCBwYXNzZWQgdG8gcGF0Y2gsIGVpdGhlciBwcm92aWRlIG9uZSBvciBwYXNzIHRoZSBwYXRjaCB0byBhIGNsaWVudHMgYG11dGF0ZSgpYCBtZXRob2RcIlxuICAgICAgKTtcbiAgICBjb25zdCByZXR1cm5GaXJzdCA9IHR5cGVvZiB0aGlzLnNlbGVjdGlvbiA9PSBcInN0cmluZ1wiLCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHJldHVybkZpcnN0LCByZXR1cm5Eb2N1bWVudHM6ICEwIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLiNjbGllbnQubXV0YXRlKHsgcGF0Y2g6IHRoaXMuc2VyaWFsaXplKCkgfSwgb3B0cyk7XG4gIH1cbn1cbmNvbnN0IGRlZmF1bHRNdXRhdGVPcHRpb25zID0geyByZXR1cm5Eb2N1bWVudHM6ICExIH07XG5jbGFzcyBCYXNlVHJhbnNhY3Rpb24ge1xuICBvcGVyYXRpb25zO1xuICB0cnhJZDtcbiAgY29uc3RydWN0b3Iob3BlcmF0aW9ucyA9IFtdLCB0cmFuc2FjdGlvbklkKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zID0gb3BlcmF0aW9ucywgdGhpcy50cnhJZCA9IHRyYW5zYWN0aW9uSWQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU2FuaXR5IGRvY3VtZW50LiBJZiBgX2lkYCBpcyBwcm92aWRlZCBhbmQgYWxyZWFkeSBleGlzdHMsIHRoZSBtdXRhdGlvbiB3aWxsIGZhaWwuIElmIG5vIGBfaWRgIGlzIGdpdmVuLCBvbmUgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGdlbmVyYXRlZCBieSB0aGUgZGF0YWJhc2UuXG4gICAqIFRoZSBvcGVyYXRpb24gaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24sIHJlYWR5IHRvIGJlIGNvbW1pdGVkIGJ5IGBjb21taXQoKWBcbiAgICpcbiAgICogQHBhcmFtIGRvYyAtIERvY3VtZW50IHRvIGNyZWF0ZS4gUmVxdWlyZXMgYSBgX3R5cGVgIHByb3BlcnR5LlxuICAgKi9cbiAgY3JlYXRlKGRvYykge1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChcImNyZWF0ZVwiLCBkb2MpLCB0aGlzLl9hZGQoeyBjcmVhdGU6IGRvYyB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTYW5pdHkgZG9jdW1lbnQuIElmIGEgZG9jdW1lbnQgd2l0aCB0aGUgc2FtZSBgX2lkYCBhbHJlYWR5IGV4aXN0cywgdGhlIGNyZWF0ZSBvcGVyYXRpb24gd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBkb2MgLSBEb2N1bWVudCB0byBjcmVhdGUgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC4gUmVxdWlyZXMgYF9pZGAgYW5kIGBfdHlwZWAgcHJvcGVydGllcy5cbiAgICovXG4gIGNyZWF0ZUlmTm90RXhpc3RzKGRvYykge1xuICAgIGNvbnN0IG9wID0gXCJjcmVhdGVJZk5vdEV4aXN0c1wiO1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChvcCwgZG9jKSwgcmVxdWlyZURvY3VtZW50SWQob3AsIGRvYyksIHRoaXMuX2FkZCh7IFtvcF06IGRvYyB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTYW5pdHkgZG9jdW1lbnQsIG9yIHJlcGxhY2VzIGFuIGV4aXN0aW5nIG9uZSBpZiB0aGUgc2FtZSBgX2lkYCBpcyBhbHJlYWR5IHVzZWQuXG4gICAqIFRoZSBvcGVyYXRpb24gaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24sIHJlYWR5IHRvIGJlIGNvbW1pdGVkIGJ5IGBjb21taXQoKWBcbiAgICpcbiAgICogQHBhcmFtIGRvYyAtIERvY3VtZW50IHRvIGNyZWF0ZSBvciByZXBsYWNlLiBSZXF1aXJlcyBgX2lkYCBhbmQgYF90eXBlYCBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgY3JlYXRlT3JSZXBsYWNlKGRvYykge1xuICAgIGNvbnN0IG9wID0gXCJjcmVhdGVPclJlcGxhY2VcIjtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qob3AsIGRvYyksIHJlcXVpcmVEb2N1bWVudElkKG9wLCBkb2MpLCB0aGlzLl9hZGQoeyBbb3BdOiBkb2MgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIGRvY3VtZW50IHdpdGggdGhlIGdpdmVuIGRvY3VtZW50IElEXG4gICAqIFRoZSBvcGVyYXRpb24gaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24sIHJlYWR5IHRvIGJlIGNvbW1pdGVkIGJ5IGBjb21taXQoKWBcbiAgICpcbiAgICogQHBhcmFtIGRvY3VtZW50SWQgLSBEb2N1bWVudCBJRCB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShkb2N1bWVudElkKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlRG9jdW1lbnRJZChcImRlbGV0ZVwiLCBkb2N1bWVudElkKSwgdGhpcy5fYWRkKHsgZGVsZXRlOiB7IGlkOiBkb2N1bWVudElkIH0gfSk7XG4gIH1cbiAgdHJhbnNhY3Rpb25JZChpZCkge1xuICAgIHJldHVybiBpZCA/ICh0aGlzLnRyeElkID0gaWQsIHRoaXMpIDogdGhpcy50cnhJZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgcGxhaW4gSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMub3BlcmF0aW9uc107XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIHBsYWluIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgdHJhbnNhY3Rpb24gb2YgYWxsIG9wZXJhdGlvbnNcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnMgPSBbXSwgdGhpcztcbiAgfVxuICBfYWRkKG11dCkge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnMucHVzaChtdXQpLCB0aGlzO1xuICB9XG59XG5jbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbiB7XG4gICNjbGllbnQ7XG4gIGNvbnN0cnVjdG9yKG9wZXJhdGlvbnMsIGNsaWVudCwgdHJhbnNhY3Rpb25JZCkge1xuICAgIHN1cGVyKG9wZXJhdGlvbnMsIHRyYW5zYWN0aW9uSWQpLCB0aGlzLiNjbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oWy4uLnRoaXMub3BlcmF0aW9uc10sIHRoaXMuI2NsaWVudCwgdGhpcy50cnhJZCk7XG4gIH1cbiAgY29tbWl0KG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuI2NsaWVudClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJObyBgY2xpZW50YCBwYXNzZWQgdG8gdHJhbnNhY3Rpb24sIGVpdGhlciBwcm92aWRlIG9uZSBvciBwYXNzIHRoZSB0cmFuc2FjdGlvbiB0byBhIGNsaWVudHMgYG11dGF0ZSgpYCBtZXRob2RcIlxuICAgICAgKTtcbiAgICByZXR1cm4gdGhpcy4jY2xpZW50Lm11dGF0ZShcbiAgICAgIHRoaXMuc2VyaWFsaXplKCksXG4gICAgICBPYmplY3QuYXNzaWduKHsgdHJhbnNhY3Rpb25JZDogdGhpcy50cnhJZCB9LCBkZWZhdWx0TXV0YXRlT3B0aW9ucywgb3B0aW9ucyB8fCB7fSlcbiAgICApO1xuICB9XG4gIHBhdGNoKHBhdGNoT3JEb2N1bWVudElkLCBwYXRjaE9wcykge1xuICAgIGNvbnN0IGlzQnVpbGRlciA9IHR5cGVvZiBwYXRjaE9wcyA9PSBcImZ1bmN0aW9uXCI7XG4gICAgaWYgKHR5cGVvZiBwYXRjaE9yRG9jdW1lbnRJZCAhPSBcInN0cmluZ1wiICYmIHBhdGNoT3JEb2N1bWVudElkIGluc3RhbmNlb2YgUGF0Y2gpXG4gICAgICByZXR1cm4gdGhpcy5fYWRkKHsgcGF0Y2g6IHBhdGNoT3JEb2N1bWVudElkLnNlcmlhbGl6ZSgpIH0pO1xuICAgIGlmIChpc0J1aWxkZXIpIHtcbiAgICAgIGNvbnN0IHBhdGNoID0gcGF0Y2hPcHMobmV3IFBhdGNoKHBhdGNoT3JEb2N1bWVudElkLCB7fSwgdGhpcy4jY2xpZW50KSk7XG4gICAgICBpZiAoIShwYXRjaCBpbnN0YW5jZW9mIFBhdGNoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZnVuY3Rpb24gcGFzc2VkIHRvIGBwYXRjaCgpYCBtdXN0IHJldHVybiB0aGUgcGF0Y2hcIik7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkKHsgcGF0Y2g6IHBhdGNoLnNlcmlhbGl6ZSgpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkKHsgcGF0Y2g6IHsgaWQ6IHBhdGNoT3JEb2N1bWVudElkLCAuLi5wYXRjaE9wcyB9IH0pO1xuICB9XG59XG5jbGFzcyBPYnNlcnZhYmxlVHJhbnNhY3Rpb24gZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb24ge1xuICAjY2xpZW50O1xuICBjb25zdHJ1Y3RvcihvcGVyYXRpb25zLCBjbGllbnQsIHRyYW5zYWN0aW9uSWQpIHtcbiAgICBzdXBlcihvcGVyYXRpb25zLCB0cmFuc2FjdGlvbklkKSwgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVUcmFuc2FjdGlvbihbLi4udGhpcy5vcGVyYXRpb25zXSwgdGhpcy4jY2xpZW50LCB0aGlzLnRyeElkKTtcbiAgfVxuICBjb21taXQob3B0aW9ucykge1xuICAgIGlmICghdGhpcy4jY2xpZW50KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIk5vIGBjbGllbnRgIHBhc3NlZCB0byB0cmFuc2FjdGlvbiwgZWl0aGVyIHByb3ZpZGUgb25lIG9yIHBhc3MgdGhlIHRyYW5zYWN0aW9uIHRvIGEgY2xpZW50cyBgbXV0YXRlKClgIG1ldGhvZFwiXG4gICAgICApO1xuICAgIHJldHVybiB0aGlzLiNjbGllbnQubXV0YXRlKFxuICAgICAgdGhpcy5zZXJpYWxpemUoKSxcbiAgICAgIE9iamVjdC5hc3NpZ24oeyB0cmFuc2FjdGlvbklkOiB0aGlzLnRyeElkIH0sIGRlZmF1bHRNdXRhdGVPcHRpb25zLCBvcHRpb25zIHx8IHt9KVxuICAgICk7XG4gIH1cbiAgcGF0Y2gocGF0Y2hPckRvY3VtZW50SWQsIHBhdGNoT3BzKSB7XG4gICAgY29uc3QgaXNCdWlsZGVyID0gdHlwZW9mIHBhdGNoT3BzID09IFwiZnVuY3Rpb25cIjtcbiAgICBpZiAodHlwZW9mIHBhdGNoT3JEb2N1bWVudElkICE9IFwic3RyaW5nXCIgJiYgcGF0Y2hPckRvY3VtZW50SWQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlUGF0Y2gpXG4gICAgICByZXR1cm4gdGhpcy5fYWRkKHsgcGF0Y2g6IHBhdGNoT3JEb2N1bWVudElkLnNlcmlhbGl6ZSgpIH0pO1xuICAgIGlmIChpc0J1aWxkZXIpIHtcbiAgICAgIGNvbnN0IHBhdGNoID0gcGF0Y2hPcHMobmV3IE9ic2VydmFibGVQYXRjaChwYXRjaE9yRG9jdW1lbnRJZCwge30sIHRoaXMuI2NsaWVudCkpO1xuICAgICAgaWYgKCEocGF0Y2ggaW5zdGFuY2VvZiBPYnNlcnZhYmxlUGF0Y2gpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmdW5jdGlvbiBwYXNzZWQgdG8gYHBhdGNoKClgIG11c3QgcmV0dXJuIHRoZSBwYXRjaFwiKTtcbiAgICAgIHJldHVybiB0aGlzLl9hZGQoeyBwYXRjaDogcGF0Y2guc2VyaWFsaXplKCkgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hZGQoeyBwYXRjaDogeyBpZDogcGF0Y2hPckRvY3VtZW50SWQsIC4uLnBhdGNoT3BzIH0gfSk7XG4gIH1cbn1cbmNvbnN0IHByb2plY3RIZWFkZXIgPSBcIlgtU2FuaXR5LVByb2plY3QtSURcIjtcbmZ1bmN0aW9uIHJlcXVlc3RPcHRpb25zKGNvbmZpZywgb3ZlcnJpZGVzID0ge30pIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9LCB0b2tlbiA9IG92ZXJyaWRlcy50b2tlbiB8fCBjb25maWcudG9rZW47XG4gIHRva2VuICYmIChoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YCksICFvdmVycmlkZXMudXNlR2xvYmFsQXBpICYmICFjb25maWcudXNlUHJvamVjdEhvc3RuYW1lICYmIGNvbmZpZy5wcm9qZWN0SWQgJiYgKGhlYWRlcnNbcHJvamVjdEhlYWRlcl0gPSBjb25maWcucHJvamVjdElkKTtcbiAgY29uc3Qgd2l0aENyZWRlbnRpYWxzID0gISEodHlwZW9mIG92ZXJyaWRlcy53aXRoQ3JlZGVudGlhbHMgPiBcInVcIiA/IGNvbmZpZy50b2tlbiB8fCBjb25maWcud2l0aENyZWRlbnRpYWxzIDogb3ZlcnJpZGVzLndpdGhDcmVkZW50aWFscyksIHRpbWVvdXQgPSB0eXBlb2Ygb3ZlcnJpZGVzLnRpbWVvdXQgPiBcInVcIiA/IGNvbmZpZy50aW1lb3V0IDogb3ZlcnJpZGVzLnRpbWVvdXQ7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIHtcbiAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBoZWFkZXJzLCBvdmVycmlkZXMuaGVhZGVycyB8fCB7fSksXG4gICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPiBcInVcIiA/IDUgKiA2MCAqIDFlMyA6IHRpbWVvdXQsXG4gICAgcHJveHk6IG92ZXJyaWRlcy5wcm94eSB8fCBjb25maWcucHJveHksXG4gICAganNvbjogITAsXG4gICAgd2l0aENyZWRlbnRpYWxzLFxuICAgIGZldGNoOiB0eXBlb2Ygb3ZlcnJpZGVzLmZldGNoID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNvbmZpZy5mZXRjaCA9PSBcIm9iamVjdFwiID8geyAuLi5jb25maWcuZmV0Y2gsIC4uLm92ZXJyaWRlcy5mZXRjaCB9IDogb3ZlcnJpZGVzLmZldGNoIHx8IGNvbmZpZy5mZXRjaFxuICB9KTtcbn1cbmNvbnN0IGVuY29kZVF1ZXJ5U3RyaW5nID0gKHtcbiAgcXVlcnksXG4gIHBhcmFtcyA9IHt9LFxuICBvcHRpb25zID0ge31cbn0pID0+IHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpLCB7IHRhZywgaW5jbHVkZU11dGF0aW9ucywgcmV0dXJuUXVlcnksIC4uLm9wdHMgfSA9IG9wdGlvbnM7XG4gIHRhZyAmJiBzZWFyY2hQYXJhbXMuYXBwZW5kKFwidGFnXCIsIHRhZyksIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJxdWVyeVwiLCBxdWVyeSk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpXG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChgJCR7a2V5fWAsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdHMpKVxuICAgIHZhbHVlICYmIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBgJHt2YWx1ZX1gKTtcbiAgcmV0dXJuIHJldHVyblF1ZXJ5ID09PSAhMSAmJiBzZWFyY2hQYXJhbXMuYXBwZW5kKFwicmV0dXJuUXVlcnlcIiwgXCJmYWxzZVwiKSwgaW5jbHVkZU11dGF0aW9ucyA9PT0gITEgJiYgc2VhcmNoUGFyYW1zLmFwcGVuZChcImluY2x1ZGVNdXRhdGlvbnNcIiwgXCJmYWxzZVwiKSwgYD8ke3NlYXJjaFBhcmFtc31gO1xufSwgZXhjbHVkZUZhbHNleSA9IChwYXJhbSwgZGVmVmFsdWUpID0+IHBhcmFtID09PSAhMSA/IHZvaWQgMCA6IHR5cGVvZiBwYXJhbSA+IFwidVwiID8gZGVmVmFsdWUgOiBwYXJhbSwgZ2V0TXV0YXRpb25RdWVyeSA9IChvcHRpb25zID0ge30pID0+ICh7XG4gIGRyeVJ1bjogb3B0aW9ucy5kcnlSdW4sXG4gIHJldHVybklkczogITAsXG4gIHJldHVybkRvY3VtZW50czogZXhjbHVkZUZhbHNleShvcHRpb25zLnJldHVybkRvY3VtZW50cywgITApLFxuICB2aXNpYmlsaXR5OiBvcHRpb25zLnZpc2liaWxpdHkgfHwgXCJzeW5jXCIsXG4gIGF1dG9HZW5lcmF0ZUFycmF5S2V5czogb3B0aW9ucy5hdXRvR2VuZXJhdGVBcnJheUtleXMsXG4gIHNraXBDcm9zc0RhdGFzZXRSZWZlcmVuY2VWYWxpZGF0aW9uOiBvcHRpb25zLnNraXBDcm9zc0RhdGFzZXRSZWZlcmVuY2VWYWxpZGF0aW9uXG59KSwgaXNSZXNwb25zZSA9IChldmVudCkgPT4gZXZlbnQudHlwZSA9PT0gXCJyZXNwb25zZVwiLCBnZXRCb2R5ID0gKGV2ZW50KSA9PiBldmVudC5ib2R5LCBpbmRleEJ5ID0gKGRvY3MsIGF0dHIpID0+IGRvY3MucmVkdWNlKChpbmRleGVkLCBkb2MpID0+IChpbmRleGVkW2F0dHIoZG9jKV0gPSBkb2MsIGluZGV4ZWQpLCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSksIGdldFF1ZXJ5U2l6ZUxpbWl0ID0gMTEyNjQ7XG5mdW5jdGlvbiBfZmV0Y2goY2xpZW50LCBodHRwUmVxdWVzdCwgX3N0ZWdhLCBxdWVyeSwgX3BhcmFtcyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgc3RlZ2EgPSBcInN0ZWdhXCIgaW4gb3B0aW9ucyA/IHtcbiAgICAuLi5fc3RlZ2EgfHwge30sXG4gICAgLi4udHlwZW9mIG9wdGlvbnMuc3RlZ2EgPT0gXCJib29sZWFuXCIgPyB7IGVuYWJsZWQ6IG9wdGlvbnMuc3RlZ2EgfSA6IG9wdGlvbnMuc3RlZ2EgfHwge31cbiAgfSA6IF9zdGVnYSwgcGFyYW1zID0gc3RlZ2EuZW5hYmxlZCA/IHN0ZWdhQ2xlYW4oX3BhcmFtcykgOiBfcGFyYW1zLCBtYXBSZXNwb25zZSA9IG9wdGlvbnMuZmlsdGVyUmVzcG9uc2UgPT09ICExID8gKHJlcykgPT4gcmVzIDogKHJlcykgPT4gcmVzLnJlc3VsdCwgeyBjYWNoZSwgbmV4dCwgLi4ub3B0cyB9ID0ge1xuICAgIC8vIE9wdCBvdXQgb2Ygc2V0dGluZyBhIGBzaWduYWxgIG9uIGFuIGludGVybmFsIGBmZXRjaGAgaWYgb25lIGlzbid0IHByb3ZpZGVkLlxuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGluIFJlYWN0IFNlcnZlciBDb21wb25lbnRzIHRvIGF2b2lkIG9wdGluZyBvdXQgb2YgUmVxdWVzdCBNZW1vaXphdGlvbi5cbiAgICB1c2VBYm9ydFNpZ25hbDogdHlwZW9mIG9wdGlvbnMuc2lnbmFsIDwgXCJ1XCIsXG4gICAgLy8gU2V0IGByZXN1bHRTb3VyY2VNYXAnIHdoZW4gc3RlZ2EgaXMgZW5hYmxlZCwgYXMgaXQncyByZXF1aXJlZCBmb3IgZW5jb2RpbmcuXG4gICAgcmVzdWx0U291cmNlTWFwOiBzdGVnYS5lbmFibGVkID8gXCJ3aXRoS2V5QXJyYXlTZWxlY3RvclwiIDogb3B0aW9ucy5yZXN1bHRTb3VyY2VNYXAsXG4gICAgLi4ub3B0aW9ucyxcbiAgICAvLyBEZWZhdWx0IHRvIG5vdCByZXR1cm5pbmcgdGhlIHF1ZXJ5LCB1bmxlc3MgYGZpbHRlclJlc3BvbnNlYCBpcyBgZmFsc2VgLFxuICAgIC8vIG9yIGByZXR1cm5RdWVyeWAgaXMgZXhwbGljaXRseSBzZXQuIGB0cnVlYCBpcyB0aGUgZGVmYXVsdCBpbiBDb250ZW50IExha2UsIHNvIHNraXAgaWYgdHJ1dGh5XG4gICAgcmV0dXJuUXVlcnk6IG9wdGlvbnMuZmlsdGVyUmVzcG9uc2UgPT09ICExICYmIG9wdGlvbnMucmV0dXJuUXVlcnkgIT09ICExXG4gIH0sIHJlcU9wdHMgPSB0eXBlb2YgY2FjaGUgPCBcInVcIiB8fCB0eXBlb2YgbmV4dCA8IFwidVwiID8geyAuLi5vcHRzLCBmZXRjaDogeyBjYWNoZSwgbmV4dCB9IH0gOiBvcHRzLCAkcmVxdWVzdCA9IF9kYXRhUmVxdWVzdChjbGllbnQsIGh0dHBSZXF1ZXN0LCBcInF1ZXJ5XCIsIHsgcXVlcnksIHBhcmFtcyB9LCByZXFPcHRzKTtcbiAgcmV0dXJuIHN0ZWdhLmVuYWJsZWQgPyAkcmVxdWVzdC5waXBlKFxuICAgIGNvbWJpbmVMYXRlc3RXaXRoKFxuICAgICAgZnJvbShcbiAgICAgICAgaW1wb3J0KFwiLi9fY2h1bmtzLWVzL3N0ZWdhRW5jb2RlU291cmNlTWFwLmpzXCIpLnRoZW4oZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBuLnN0ZWdhRW5jb2RlU291cmNlTWFwJDE7XG4gICAgICAgIH0pLnRoZW4oXG4gICAgICAgICAgKHsgc3RlZ2FFbmNvZGVTb3VyY2VNYXAgfSkgPT4gc3RlZ2FFbmNvZGVTb3VyY2VNYXBcbiAgICAgICAgKVxuICAgICAgKVxuICAgICksXG4gICAgbWFwKFxuICAgICAgKFtyZXMsIHN0ZWdhRW5jb2RlU291cmNlTWFwXSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdGVnYUVuY29kZVNvdXJjZU1hcChyZXMucmVzdWx0LCByZXMucmVzdWx0U291cmNlTWFwLCBzdGVnYSk7XG4gICAgICAgIHJldHVybiBtYXBSZXNwb25zZSh7IC4uLnJlcywgcmVzdWx0IH0pO1xuICAgICAgfVxuICAgIClcbiAgKSA6ICRyZXF1ZXN0LnBpcGUobWFwKG1hcFJlc3BvbnNlKSk7XG59XG5mdW5jdGlvbiBfZ2V0RG9jdW1lbnQoY2xpZW50LCBodHRwUmVxdWVzdCwgaWQsIG9wdHMgPSB7fSkge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIHVyaTogX2dldERhdGFVcmwoY2xpZW50LCBcImRvY1wiLCBpZCksXG4gICAganNvbjogITAsXG4gICAgdGFnOiBvcHRzLnRhZyxcbiAgICBzaWduYWw6IG9wdHMuc2lnbmFsXG4gIH07XG4gIHJldHVybiBfcmVxdWVzdE9ic2VydmFibGUoY2xpZW50LCBodHRwUmVxdWVzdCwgb3B0aW9ucykucGlwZShcbiAgICBmaWx0ZXIoaXNSZXNwb25zZSksXG4gICAgbWFwKChldmVudCkgPT4gZXZlbnQuYm9keS5kb2N1bWVudHMgJiYgZXZlbnQuYm9keS5kb2N1bWVudHNbMF0pXG4gICk7XG59XG5mdW5jdGlvbiBfZ2V0RG9jdW1lbnRzKGNsaWVudCwgaHR0cFJlcXVlc3QsIGlkcywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgdXJpOiBfZ2V0RGF0YVVybChjbGllbnQsIFwiZG9jXCIsIGlkcy5qb2luKFwiLFwiKSksXG4gICAganNvbjogITAsXG4gICAgdGFnOiBvcHRzLnRhZyxcbiAgICBzaWduYWw6IG9wdHMuc2lnbmFsXG4gIH07XG4gIHJldHVybiBfcmVxdWVzdE9ic2VydmFibGUoY2xpZW50LCBodHRwUmVxdWVzdCwgb3B0aW9ucykucGlwZShcbiAgICBmaWx0ZXIoaXNSZXNwb25zZSksXG4gICAgbWFwKChldmVudCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXhlZCA9IGluZGV4QnkoZXZlbnQuYm9keS5kb2N1bWVudHMgfHwgW10sIChkb2MpID0+IGRvYy5faWQpO1xuICAgICAgcmV0dXJuIGlkcy5tYXAoKGlkKSA9PiBpbmRleGVkW2lkXSB8fCBudWxsKTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUlmTm90RXhpc3RzKGNsaWVudCwgaHR0cFJlcXVlc3QsIGRvYywgb3B0aW9ucykge1xuICByZXR1cm4gcmVxdWlyZURvY3VtZW50SWQoXCJjcmVhdGVJZk5vdEV4aXN0c1wiLCBkb2MpLCBfY3JlYXRlKGNsaWVudCwgaHR0cFJlcXVlc3QsIGRvYywgXCJjcmVhdGVJZk5vdEV4aXN0c1wiLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVPclJlcGxhY2UoY2xpZW50LCBodHRwUmVxdWVzdCwgZG9jLCBvcHRpb25zKSB7XG4gIHJldHVybiByZXF1aXJlRG9jdW1lbnRJZChcImNyZWF0ZU9yUmVwbGFjZVwiLCBkb2MpLCBfY3JlYXRlKGNsaWVudCwgaHR0cFJlcXVlc3QsIGRvYywgXCJjcmVhdGVPclJlcGxhY2VcIiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBfZGVsZXRlKGNsaWVudCwgaHR0cFJlcXVlc3QsIHNlbGVjdGlvbiwgb3B0aW9ucykge1xuICByZXR1cm4gX2RhdGFSZXF1ZXN0KFxuICAgIGNsaWVudCxcbiAgICBodHRwUmVxdWVzdCxcbiAgICBcIm11dGF0ZVwiLFxuICAgIHsgbXV0YXRpb25zOiBbeyBkZWxldGU6IGdldFNlbGVjdGlvbihzZWxlY3Rpb24pIH1dIH0sXG4gICAgb3B0aW9uc1xuICApO1xufVxuZnVuY3Rpb24gX211dGF0ZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBtdXRhdGlvbnMsIG9wdGlvbnMpIHtcbiAgbGV0IG11dDtcbiAgbXV0YXRpb25zIGluc3RhbmNlb2YgUGF0Y2ggfHwgbXV0YXRpb25zIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVBhdGNoID8gbXV0ID0geyBwYXRjaDogbXV0YXRpb25zLnNlcmlhbGl6ZSgpIH0gOiBtdXRhdGlvbnMgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbiB8fCBtdXRhdGlvbnMgaW5zdGFuY2VvZiBPYnNlcnZhYmxlVHJhbnNhY3Rpb24gPyBtdXQgPSBtdXRhdGlvbnMuc2VyaWFsaXplKCkgOiBtdXQgPSBtdXRhdGlvbnM7XG4gIGNvbnN0IG11dHMgPSBBcnJheS5pc0FycmF5KG11dCkgPyBtdXQgOiBbbXV0XSwgdHJhbnNhY3Rpb25JZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50cmFuc2FjdGlvbklkIHx8IHZvaWQgMDtcbiAgcmV0dXJuIF9kYXRhUmVxdWVzdChjbGllbnQsIGh0dHBSZXF1ZXN0LCBcIm11dGF0ZVwiLCB7IG11dGF0aW9uczogbXV0cywgdHJhbnNhY3Rpb25JZCB9LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIF9hY3Rpb24oY2xpZW50LCBodHRwUmVxdWVzdCwgYWN0aW9ucywgb3B0aW9ucykge1xuICBjb25zdCBhY3RzID0gQXJyYXkuaXNBcnJheShhY3Rpb25zKSA/IGFjdGlvbnMgOiBbYWN0aW9uc10sIHRyYW5zYWN0aW9uSWQgPSBvcHRpb25zICYmIG9wdGlvbnMudHJhbnNhY3Rpb25JZCB8fCB2b2lkIDAsIHNraXBDcm9zc0RhdGFzZXRSZWZlcmVuY2VWYWxpZGF0aW9uID0gb3B0aW9ucyAmJiBvcHRpb25zLnNraXBDcm9zc0RhdGFzZXRSZWZlcmVuY2VWYWxpZGF0aW9uIHx8IHZvaWQgMCwgZHJ5UnVuID0gb3B0aW9ucyAmJiBvcHRpb25zLmRyeVJ1biB8fCB2b2lkIDA7XG4gIHJldHVybiBfZGF0YVJlcXVlc3QoXG4gICAgY2xpZW50LFxuICAgIGh0dHBSZXF1ZXN0LFxuICAgIFwiYWN0aW9uc1wiLFxuICAgIHsgYWN0aW9uczogYWN0cywgdHJhbnNhY3Rpb25JZCwgc2tpcENyb3NzRGF0YXNldFJlZmVyZW5jZVZhbGlkYXRpb24sIGRyeVJ1biB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbmZ1bmN0aW9uIF9kYXRhUmVxdWVzdChjbGllbnQsIGh0dHBSZXF1ZXN0LCBlbmRwb2ludCwgYm9keSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGlzTXV0YXRpb24gPSBlbmRwb2ludCA9PT0gXCJtdXRhdGVcIiwgaXNBY3Rpb24gPSBlbmRwb2ludCA9PT0gXCJhY3Rpb25zXCIsIGlzUXVlcnkgPSBlbmRwb2ludCA9PT0gXCJxdWVyeVwiLCBzdHJRdWVyeSA9IGlzTXV0YXRpb24gfHwgaXNBY3Rpb24gPyBcIlwiIDogZW5jb2RlUXVlcnlTdHJpbmcoYm9keSksIHVzZUdldCA9ICFpc011dGF0aW9uICYmICFpc0FjdGlvbiAmJiBzdHJRdWVyeS5sZW5ndGggPCBnZXRRdWVyeVNpemVMaW1pdCwgc3RyaW5nUXVlcnkgPSB1c2VHZXQgPyBzdHJRdWVyeSA6IFwiXCIsIHJldHVybkZpcnN0ID0gb3B0aW9ucy5yZXR1cm5GaXJzdCwgeyB0aW1lb3V0LCB0b2tlbiwgdGFnLCBoZWFkZXJzLCByZXR1cm5RdWVyeSwgbGFzdExpdmVFdmVudElkLCBjYWNoZU1vZGUgfSA9IG9wdGlvbnMsIHVyaSA9IF9nZXREYXRhVXJsKGNsaWVudCwgZW5kcG9pbnQsIHN0cmluZ1F1ZXJ5KSwgcmVxT3B0aW9ucyA9IHtcbiAgICBtZXRob2Q6IHVzZUdldCA/IFwiR0VUXCIgOiBcIlBPU1RcIixcbiAgICB1cmksXG4gICAganNvbjogITAsXG4gICAgYm9keTogdXNlR2V0ID8gdm9pZCAwIDogYm9keSxcbiAgICBxdWVyeTogaXNNdXRhdGlvbiAmJiBnZXRNdXRhdGlvblF1ZXJ5KG9wdGlvbnMpLFxuICAgIHRpbWVvdXQsXG4gICAgaGVhZGVycyxcbiAgICB0b2tlbixcbiAgICB0YWcsXG4gICAgcmV0dXJuUXVlcnksXG4gICAgcGVyc3BlY3RpdmU6IG9wdGlvbnMucGVyc3BlY3RpdmUsXG4gICAgcmVzdWx0U291cmNlTWFwOiBvcHRpb25zLnJlc3VsdFNvdXJjZU1hcCxcbiAgICBsYXN0TGl2ZUV2ZW50SWQ6IEFycmF5LmlzQXJyYXkobGFzdExpdmVFdmVudElkKSA/IGxhc3RMaXZlRXZlbnRJZFswXSA6IGxhc3RMaXZlRXZlbnRJZCxcbiAgICBjYWNoZU1vZGUsXG4gICAgY2FuVXNlQ2RuOiBpc1F1ZXJ5LFxuICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2gsXG4gICAgdXNlQWJvcnRTaWduYWw6IG9wdGlvbnMudXNlQWJvcnRTaWduYWwsXG4gICAgdXNlQ2RuOiBvcHRpb25zLnVzZUNkblxuICB9O1xuICByZXR1cm4gX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIHJlcU9wdGlvbnMpLnBpcGUoXG4gICAgZmlsdGVyKGlzUmVzcG9uc2UpLFxuICAgIG1hcChnZXRCb2R5KSxcbiAgICBtYXAoKHJlcykgPT4ge1xuICAgICAgaWYgKCFpc011dGF0aW9uKVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IHJlcy5yZXN1bHRzIHx8IFtdO1xuICAgICAgaWYgKG9wdGlvbnMucmV0dXJuRG9jdW1lbnRzKVxuICAgICAgICByZXR1cm4gcmV0dXJuRmlyc3QgPyByZXN1bHRzWzBdICYmIHJlc3VsdHNbMF0uZG9jdW1lbnQgOiByZXN1bHRzLm1hcCgobXV0KSA9PiBtdXQuZG9jdW1lbnQpO1xuICAgICAgY29uc3Qga2V5ID0gcmV0dXJuRmlyc3QgPyBcImRvY3VtZW50SWRcIiA6IFwiZG9jdW1lbnRJZHNcIiwgaWRzID0gcmV0dXJuRmlyc3QgPyByZXN1bHRzWzBdICYmIHJlc3VsdHNbMF0uaWQgOiByZXN1bHRzLm1hcCgobXV0KSA9PiBtdXQuaWQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNhY3Rpb25JZDogcmVzLnRyYW5zYWN0aW9uSWQsXG4gICAgICAgIHJlc3VsdHMsXG4gICAgICAgIFtrZXldOiBpZHNcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGUoY2xpZW50LCBodHRwUmVxdWVzdCwgZG9jLCBvcCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IG11dGF0aW9uID0geyBbb3BdOiBkb2MgfSwgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyByZXR1cm5GaXJzdDogITAsIHJldHVybkRvY3VtZW50czogITAgfSwgb3B0aW9ucyk7XG4gIHJldHVybiBfZGF0YVJlcXVlc3QoY2xpZW50LCBodHRwUmVxdWVzdCwgXCJtdXRhdGVcIiwgeyBtdXRhdGlvbnM6IFttdXRhdGlvbl0gfSwgb3B0cyk7XG59XG5mdW5jdGlvbiBfcmVxdWVzdE9ic2VydmFibGUoY2xpZW50LCBodHRwUmVxdWVzdCwgb3B0aW9ucykge1xuICBjb25zdCB1cmkgPSBvcHRpb25zLnVybCB8fCBvcHRpb25zLnVyaSwgY29uZmlnID0gY2xpZW50LmNvbmZpZygpLCBjYW5Vc2VDZG4gPSB0eXBlb2Ygb3B0aW9ucy5jYW5Vc2VDZG4gPiBcInVcIiA/IFtcIkdFVFwiLCBcIkhFQURcIl0uaW5kZXhPZihvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiKSA+PSAwICYmIHVyaS5pbmRleE9mKFwiL2RhdGEvXCIpID09PSAwIDogb3B0aW9ucy5jYW5Vc2VDZG47XG4gIGxldCB1c2VDZG4gPSAob3B0aW9ucy51c2VDZG4gPz8gY29uZmlnLnVzZUNkbikgJiYgY2FuVXNlQ2RuO1xuICBjb25zdCB0YWcgPSBvcHRpb25zLnRhZyAmJiBjb25maWcucmVxdWVzdFRhZ1ByZWZpeCA/IFtjb25maWcucmVxdWVzdFRhZ1ByZWZpeCwgb3B0aW9ucy50YWddLmpvaW4oXCIuXCIpIDogb3B0aW9ucy50YWcgfHwgY29uZmlnLnJlcXVlc3RUYWdQcmVmaXg7XG4gIGlmICh0YWcgJiYgb3B0aW9ucy50YWcgIT09IG51bGwgJiYgKG9wdGlvbnMucXVlcnkgPSB7IHRhZzogcmVxdWVzdFRhZyh0YWcpLCAuLi5vcHRpb25zLnF1ZXJ5IH0pLCBbXCJHRVRcIiwgXCJIRUFEXCIsIFwiUE9TVFwiXS5pbmRleE9mKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIpID49IDAgJiYgdXJpLmluZGV4T2YoXCIvZGF0YS9xdWVyeS9cIikgPT09IDApIHtcbiAgICBjb25zdCByZXN1bHRTb3VyY2VNYXAgPSBvcHRpb25zLnJlc3VsdFNvdXJjZU1hcCA/PyBjb25maWcucmVzdWx0U291cmNlTWFwO1xuICAgIHJlc3VsdFNvdXJjZU1hcCAhPT0gdm9pZCAwICYmIHJlc3VsdFNvdXJjZU1hcCAhPT0gITEgJiYgKG9wdGlvbnMucXVlcnkgPSB7IHJlc3VsdFNvdXJjZU1hcCwgLi4ub3B0aW9ucy5xdWVyeSB9KTtcbiAgICBjb25zdCBwZXJzcGVjdGl2ZU9wdGlvbiA9IG9wdGlvbnMucGVyc3BlY3RpdmUgfHwgY29uZmlnLnBlcnNwZWN0aXZlO1xuICAgIHR5cGVvZiBwZXJzcGVjdGl2ZU9wdGlvbiA8IFwidVwiICYmICh2YWxpZGF0ZUFwaVBlcnNwZWN0aXZlKHBlcnNwZWN0aXZlT3B0aW9uKSwgb3B0aW9ucy5xdWVyeSA9IHtcbiAgICAgIHBlcnNwZWN0aXZlOiBBcnJheS5pc0FycmF5KHBlcnNwZWN0aXZlT3B0aW9uKSA/IHBlcnNwZWN0aXZlT3B0aW9uLmpvaW4oXCIsXCIpIDogcGVyc3BlY3RpdmVPcHRpb24sXG4gICAgICAuLi5vcHRpb25zLnF1ZXJ5XG4gICAgfSwgcGVyc3BlY3RpdmVPcHRpb24gPT09IFwicHJldmlld0RyYWZ0c1wiICYmIHVzZUNkbiAmJiAodXNlQ2RuID0gITEsIHByaW50Q2RuUHJldmlld0RyYWZ0c1dhcm5pbmcoKSkpLCBvcHRpb25zLmxhc3RMaXZlRXZlbnRJZCAmJiAob3B0aW9ucy5xdWVyeSA9IHsgLi4ub3B0aW9ucy5xdWVyeSwgbGFzdExpdmVFdmVudElkOiBvcHRpb25zLmxhc3RMaXZlRXZlbnRJZCB9KSwgb3B0aW9ucy5yZXR1cm5RdWVyeSA9PT0gITEgJiYgKG9wdGlvbnMucXVlcnkgPSB7IHJldHVyblF1ZXJ5OiBcImZhbHNlXCIsIC4uLm9wdGlvbnMucXVlcnkgfSksIHVzZUNkbiAmJiBvcHRpb25zLmNhY2hlTW9kZSA9PSBcIm5vU3RhbGVcIiAmJiAob3B0aW9ucy5xdWVyeSA9IHsgY2FjaGVNb2RlOiBcIm5vU3RhbGVcIiwgLi4ub3B0aW9ucy5xdWVyeSB9KTtcbiAgfVxuICBjb25zdCByZXFPcHRpb25zID0gcmVxdWVzdE9wdGlvbnMoXG4gICAgY29uZmlnLFxuICAgIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHVybDogX2dldFVybChjbGllbnQsIHVyaSwgdXNlQ2RuKVxuICAgIH0pXG4gICksIHJlcXVlc3QgPSBuZXcgT2JzZXJ2YWJsZShcbiAgICAoc3Vic2NyaWJlcikgPT4gaHR0cFJlcXVlc3QocmVxT3B0aW9ucywgY29uZmlnLnJlcXVlc3Rlcikuc3Vic2NyaWJlKHN1YnNjcmliZXIpXG4gICk7XG4gIHJldHVybiBvcHRpb25zLnNpZ25hbCA/IHJlcXVlc3QucGlwZShfd2l0aEFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsKSkgOiByZXF1ZXN0O1xufVxuZnVuY3Rpb24gX3JlcXVlc3QoY2xpZW50LCBodHRwUmVxdWVzdCwgb3B0aW9ucykge1xuICByZXR1cm4gX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIG9wdGlvbnMpLnBpcGUoXG4gICAgZmlsdGVyKChldmVudCkgPT4gZXZlbnQudHlwZSA9PT0gXCJyZXNwb25zZVwiKSxcbiAgICBtYXAoKGV2ZW50KSA9PiBldmVudC5ib2R5KVxuICApO1xufVxuZnVuY3Rpb24gX2dldERhdGFVcmwoY2xpZW50LCBvcGVyYXRpb24sIHBhdGgpIHtcbiAgY29uc3QgY29uZmlnID0gY2xpZW50LmNvbmZpZygpLCBjYXRhbG9nID0gaGFzRGF0YXNldChjb25maWcpLCBiYXNlVXJpID0gYC8ke29wZXJhdGlvbn0vJHtjYXRhbG9nfWA7XG4gIHJldHVybiBgL2RhdGEke3BhdGggPyBgJHtiYXNlVXJpfS8ke3BhdGh9YCA6IGJhc2VVcml9YC5yZXBsYWNlKC9cXC8oJHxcXD8pLywgXCIkMVwiKTtcbn1cbmZ1bmN0aW9uIF9nZXRVcmwoY2xpZW50LCB1cmksIGNhblVzZUNkbiA9ICExKSB7XG4gIGNvbnN0IHsgdXJsLCBjZG5VcmwgfSA9IGNsaWVudC5jb25maWcoKTtcbiAgcmV0dXJuIGAke2NhblVzZUNkbiA/IGNkblVybCA6IHVybH0vJHt1cmkucmVwbGFjZSgvXlxcLy8sIFwiXCIpfWA7XG59XG5mdW5jdGlvbiBfd2l0aEFib3J0U2lnbmFsKHNpZ25hbCkge1xuICByZXR1cm4gKGlucHV0KSA9PiBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICBjb25zdCBhYm9ydCA9ICgpID0+IG9ic2VydmVyLmVycm9yKF9jcmVhdGVBYm9ydEVycm9yKHNpZ25hbCkpO1xuICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGFib3J0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGlucHV0LnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgcmV0dXJuIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnQpLCAoKSA9PiB7XG4gICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0KSwgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSk7XG59XG5jb25zdCBpc0RvbUV4Y2VwdGlvblN1cHBvcnRlZCA9ICEhZ2xvYmFsVGhpcy5ET01FeGNlcHRpb247XG5mdW5jdGlvbiBfY3JlYXRlQWJvcnRFcnJvcihzaWduYWwpIHtcbiAgaWYgKGlzRG9tRXhjZXB0aW9uU3VwcG9ydGVkKVxuICAgIHJldHVybiBuZXcgRE9NRXhjZXB0aW9uKHNpZ25hbD8ucmVhc29uID8/IFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIiwgXCJBYm9ydEVycm9yXCIpO1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihzaWduYWw/LnJlYXNvbiA/PyBcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuXCIpO1xuICByZXR1cm4gZXJyb3IubmFtZSA9IFwiQWJvcnRFcnJvclwiLCBlcnJvcjtcbn1cbmNsYXNzIE9ic2VydmFibGVBc3NldHNDbGllbnQge1xuICAjY2xpZW50O1xuICAjaHR0cFJlcXVlc3Q7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG4gIH1cbiAgdXBsb2FkKGFzc2V0VHlwZSwgYm9keSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfdXBsb2FkKHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIGFzc2V0VHlwZSwgYm9keSwgb3B0aW9ucyk7XG4gIH1cbn1cbmNsYXNzIEFzc2V0c0NsaWVudCB7XG4gICNjbGllbnQ7XG4gICNodHRwUmVxdWVzdDtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdDtcbiAgfVxuICB1cGxvYWQoYXNzZXRUeXBlLCBib2R5LCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb2JzZXJ2YWJsZTIgPSBfdXBsb2FkKHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIGFzc2V0VHlwZSwgYm9keSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICBvYnNlcnZhYmxlMi5waXBlKFxuICAgICAgICBmaWx0ZXIoKGV2ZW50KSA9PiBldmVudC50eXBlID09PSBcInJlc3BvbnNlXCIpLFxuICAgICAgICBtYXAoXG4gICAgICAgICAgKGV2ZW50KSA9PiBldmVudC5ib2R5LmRvY3VtZW50XG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBfdXBsb2FkKGNsaWVudCwgaHR0cFJlcXVlc3QsIGFzc2V0VHlwZSwgYm9keSwgb3B0cyA9IHt9KSB7XG4gIHZhbGlkYXRlQXNzZXRUeXBlKGFzc2V0VHlwZSk7XG4gIGxldCBtZXRhID0gb3B0cy5leHRyYWN0IHx8IHZvaWQgMDtcbiAgbWV0YSAmJiAhbWV0YS5sZW5ndGggJiYgKG1ldGEgPSBbXCJub25lXCJdKTtcbiAgY29uc3QgZGF0YXNldDIgPSBoYXNEYXRhc2V0KGNsaWVudC5jb25maWcoKSksIGFzc2V0RW5kcG9pbnQgPSBhc3NldFR5cGUgPT09IFwiaW1hZ2VcIiA/IFwiaW1hZ2VzXCIgOiBcImZpbGVzXCIsIG9wdGlvbnMgPSBvcHRpb25zRnJvbUZpbGUob3B0cywgYm9keSksIHsgdGFnLCBsYWJlbCwgdGl0bGUsIGRlc2NyaXB0aW9uLCBjcmVkaXRMaW5lLCBmaWxlbmFtZSwgc291cmNlIH0gPSBvcHRpb25zLCBxdWVyeSA9IHtcbiAgICBsYWJlbCxcbiAgICB0aXRsZSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBmaWxlbmFtZSxcbiAgICBtZXRhLFxuICAgIGNyZWRpdExpbmVcbiAgfTtcbiAgcmV0dXJuIHNvdXJjZSAmJiAocXVlcnkuc291cmNlSWQgPSBzb3VyY2UuaWQsIHF1ZXJ5LnNvdXJjZU5hbWUgPSBzb3VyY2UubmFtZSwgcXVlcnkuc291cmNlVXJsID0gc291cmNlLnVybCksIF9yZXF1ZXN0T2JzZXJ2YWJsZShjbGllbnQsIGh0dHBSZXF1ZXN0LCB7XG4gICAgdGFnLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0IHx8IDAsXG4gICAgdXJpOiBgL2Fzc2V0cy8ke2Fzc2V0RW5kcG9pbnR9LyR7ZGF0YXNldDJ9YCxcbiAgICBoZWFkZXJzOiBvcHRpb25zLmNvbnRlbnRUeXBlID8geyBcIkNvbnRlbnQtVHlwZVwiOiBvcHRpb25zLmNvbnRlbnRUeXBlIH0gOiB7fSxcbiAgICBxdWVyeSxcbiAgICBib2R5XG4gIH0pO1xufVxuZnVuY3Rpb24gb3B0aW9uc0Zyb21GaWxlKG9wdHMsIGZpbGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBGaWxlID4gXCJ1XCIgfHwgIShmaWxlIGluc3RhbmNlb2YgRmlsZSkgPyBvcHRzIDogT2JqZWN0LmFzc2lnbihcbiAgICB7XG4gICAgICBmaWxlbmFtZTogb3B0cy5wcmVzZXJ2ZUZpbGVuYW1lID09PSAhMSA/IHZvaWQgMCA6IGZpbGUubmFtZSxcbiAgICAgIGNvbnRlbnRUeXBlOiBmaWxlLnR5cGVcbiAgICB9LFxuICAgIG9wdHNcbiAgKTtcbn1cbnZhciBkZWZhdWx0cyA9IChvYmosIGRlZmF1bHRzMikgPT4gT2JqZWN0LmtleXMoZGVmYXVsdHMyKS5jb25jYXQoT2JqZWN0LmtleXMob2JqKSkucmVkdWNlKCh0YXJnZXQsIHByb3ApID0+ICh0YXJnZXRbcHJvcF0gPSB0eXBlb2Ygb2JqW3Byb3BdID4gXCJ1XCIgPyBkZWZhdWx0czJbcHJvcF0gOiBvYmpbcHJvcF0sIHRhcmdldCksIHt9KTtcbmNvbnN0IHBpY2sgPSAob2JqLCBwcm9wcykgPT4gcHJvcHMucmVkdWNlKChzZWxlY3Rpb24sIHByb3ApID0+ICh0eXBlb2Ygb2JqW3Byb3BdID4gXCJ1XCIgfHwgKHNlbGVjdGlvbltwcm9wXSA9IG9ialtwcm9wXSksIHNlbGVjdGlvbiksIHt9KSwgTUFYX1VSTF9MRU5HVEggPSAxNDgwMCwgcG9zc2libGVPcHRpb25zID0gW1xuICBcImluY2x1ZGVQcmV2aW91c1JldmlzaW9uXCIsXG4gIFwiaW5jbHVkZVJlc3VsdFwiLFxuICBcImluY2x1ZGVNdXRhdGlvbnNcIixcbiAgXCJ2aXNpYmlsaXR5XCIsXG4gIFwiZWZmZWN0Rm9ybWF0XCIsXG4gIFwidGFnXCJcbl0sIGRlZmF1bHRPcHRpb25zID0ge1xuICBpbmNsdWRlUmVzdWx0OiAhMFxufTtcbmZ1bmN0aW9uIF9saXN0ZW4ocXVlcnksIHBhcmFtcywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgdXJsLCB0b2tlbiwgd2l0aENyZWRlbnRpYWxzLCByZXF1ZXN0VGFnUHJlZml4IH0gPSB0aGlzLmNvbmZpZygpLCB0YWcgPSBvcHRzLnRhZyAmJiByZXF1ZXN0VGFnUHJlZml4ID8gW3JlcXVlc3RUYWdQcmVmaXgsIG9wdHMudGFnXS5qb2luKFwiLlwiKSA6IG9wdHMudGFnLCBvcHRpb25zID0geyAuLi5kZWZhdWx0cyhvcHRzLCBkZWZhdWx0T3B0aW9ucyksIHRhZyB9LCBsaXN0ZW5PcHRzID0gcGljayhvcHRpb25zLCBwb3NzaWJsZU9wdGlvbnMpLCBxcyA9IGVuY29kZVF1ZXJ5U3RyaW5nKHsgcXVlcnksIHBhcmFtcywgb3B0aW9uczogeyB0YWcsIC4uLmxpc3Rlbk9wdHMgfSB9KSwgdXJpID0gYCR7dXJsfSR7X2dldERhdGFVcmwodGhpcywgXCJsaXN0ZW5cIiwgcXMpfWA7XG4gIGlmICh1cmkubGVuZ3RoID4gTUFYX1VSTF9MRU5HVEgpXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4gb2JzZXJ2ZXIuZXJyb3IobmV3IEVycm9yKFwiUXVlcnkgdG9vIGxhcmdlIGZvciBsaXN0ZW5lclwiKSkpO1xuICBjb25zdCBsaXN0ZW5Gb3IgPSBvcHRpb25zLmV2ZW50cyA/IG9wdGlvbnMuZXZlbnRzIDogW1wibXV0YXRpb25cIl0sIHNob3VsZEVtaXRSZWNvbm5lY3QgPSBsaXN0ZW5Gb3IuaW5kZXhPZihcInJlY29ubmVjdFwiKSAhPT0gLTEsIGVzT3B0aW9ucyA9IHt9O1xuICByZXR1cm4gKHRva2VuIHx8IHdpdGhDcmVkZW50aWFscykgJiYgKGVzT3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgPSAhMCksIHRva2VuICYmIChlc09wdGlvbnMuaGVhZGVycyA9IHtcbiAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICB9KSwgbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gICAgbGV0IGVzLCByZWNvbm5lY3RUaW1lciwgc3RvcHBlZCA9ICExLCB1bnN1YnNjcmliZWQgPSAhMTtcbiAgICBvcGVuKCk7XG4gICAgZnVuY3Rpb24gb25FcnJvcigpIHtcbiAgICAgIHN0b3BwZWQgfHwgKGVtaXRSZWNvbm5lY3QoKSwgIXN0b3BwZWQgJiYgZXMucmVhZHlTdGF0ZSA9PT0gZXMuQ0xPU0VEICYmICh1bnN1YnNjcmliZSgpLCBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZXIpLCByZWNvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQob3BlbiwgMTAwKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkNoYW5uZWxFcnJvcihlcnIpIHtcbiAgICAgIG9ic2VydmVyLmVycm9yKGNvb2VyY2VFcnJvcihlcnIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25NZXNzYWdlKGV2dCkge1xuICAgICAgY29uc3QgZXZlbnQgPSBwYXJzZUV2ZW50JDEoZXZ0KTtcbiAgICAgIHJldHVybiBldmVudCBpbnN0YW5jZW9mIEVycm9yID8gb2JzZXJ2ZXIuZXJyb3IoZXZlbnQpIDogb2JzZXJ2ZXIubmV4dChldmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRGlzY29ubmVjdCgpIHtcbiAgICAgIHN0b3BwZWQgPSAhMCwgdW5zdWJzY3JpYmUoKSwgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBlcyAmJiAoZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpLCBlcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbm5lbEVycm9yXCIsIG9uQ2hhbm5lbEVycm9yKSwgZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRpc2Nvbm5lY3RcIiwgb25EaXNjb25uZWN0KSwgbGlzdGVuRm9yLmZvckVhY2goKHR5cGUpID0+IGVzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgb25NZXNzYWdlKSksIGVzLmNsb3NlKCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbWl0UmVjb25uZWN0KCkge1xuICAgICAgc2hvdWxkRW1pdFJlY29ubmVjdCAmJiBvYnNlcnZlci5uZXh0KHsgdHlwZTogXCJyZWNvbm5lY3RcIiB9KTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2UoKSB7XG4gICAgICBjb25zdCB7IGRlZmF1bHQ6IEV2ZW50U291cmNlMiB9ID0gYXdhaXQgaW1wb3J0KFwiQHNhbml0eS9ldmVudHNvdXJjZVwiKTtcbiAgICAgIGlmICh1bnN1YnNjcmliZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGV2cyA9IG5ldyBFdmVudFNvdXJjZTIodXJpLCBlc09wdGlvbnMpO1xuICAgICAgcmV0dXJuIGV2cy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvciksIGV2cy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbm5lbEVycm9yXCIsIG9uQ2hhbm5lbEVycm9yKSwgZXZzLmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNjb25uZWN0XCIsIG9uRGlzY29ubmVjdCksIGxpc3RlbkZvci5mb3JFYWNoKCh0eXBlKSA9PiBldnMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBvbk1lc3NhZ2UpKSwgZXZzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgZ2V0RXZlbnRTb3VyY2UoKS50aGVuKChldmVudFNvdXJjZSkgPT4ge1xuICAgICAgICBldmVudFNvdXJjZSAmJiAoZXMgPSBldmVudFNvdXJjZSwgdW5zdWJzY3JpYmVkICYmIHVuc3Vic2NyaWJlKCkpO1xuICAgICAgfSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICBvYnNlcnZlci5lcnJvcihyZWFzb24pLCBzdG9wKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHN0b3BwZWQgPSAhMCwgdW5zdWJzY3JpYmUoKSwgdW5zdWJzY3JpYmVkID0gITA7XG4gICAgfVxuICAgIHJldHVybiBzdG9wO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXZlbnQkMShldmVudCkge1xuICB0cnkge1xuICAgIGNvbnN0IGRhdGEgPSBldmVudC5kYXRhICYmIEpTT04ucGFyc2UoZXZlbnQuZGF0YSkgfHwge307XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0eXBlOiBldmVudC50eXBlIH0sIGRhdGEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG59XG5mdW5jdGlvbiBjb29lcmNlRXJyb3IoZXJyKSB7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcilcbiAgICByZXR1cm4gZXJyO1xuICBjb25zdCBldnQgPSBwYXJzZUV2ZW50JDEoZXJyKTtcbiAgcmV0dXJuIGV2dCBpbnN0YW5jZW9mIEVycm9yID8gZXZ0IDogbmV3IEVycm9yKGV4dHJhY3RFcnJvck1lc3NhZ2UoZXZ0KSk7XG59XG5mdW5jdGlvbiBleHRyYWN0RXJyb3JNZXNzYWdlKGVycikge1xuICByZXR1cm4gZXJyLmVycm9yID8gZXJyLmVycm9yLmRlc2NyaXB0aW9uID8gZXJyLmVycm9yLmRlc2NyaXB0aW9uIDogdHlwZW9mIGVyci5lcnJvciA9PSBcInN0cmluZ1wiID8gZXJyLmVycm9yIDogSlNPTi5zdHJpbmdpZnkoZXJyLmVycm9yLCBudWxsLCAyKSA6IGVyci5tZXNzYWdlIHx8IFwiVW5rbm93biBsaXN0ZW5lciBlcnJvclwiO1xufVxuY29uc3QgcmVxdWlyZWRBcGlWZXJzaW9uID0gXCIyMDIxLTAzLTI2XCI7XG5jbGFzcyBMaXZlQ2xpZW50IHtcbiAgI2NsaWVudDtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBSZXF1aXJlcyBgYXBpVmVyc2lvbmAgdG8gYmUgYDIwMjEtMDMtMjZgIG9yIGxhdGVyLlxuICAgKi9cbiAgZXZlbnRzKHtcbiAgICBpbmNsdWRlRHJhZnRzID0gITEsXG4gICAgdGFnOiBfdGFnXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHByb2plY3RJZDogcHJvamVjdElkMixcbiAgICAgIGFwaVZlcnNpb246IF9hcGlWZXJzaW9uLFxuICAgICAgdG9rZW4sXG4gICAgICB3aXRoQ3JlZGVudGlhbHMsXG4gICAgICByZXF1ZXN0VGFnUHJlZml4XG4gICAgfSA9IHRoaXMuI2NsaWVudC5jb25maWcoKSwgYXBpVmVyc2lvbiA9IF9hcGlWZXJzaW9uLnJlcGxhY2UoL152LywgXCJcIik7XG4gICAgaWYgKGFwaVZlcnNpb24gIT09IFwiWFwiICYmIGFwaVZlcnNpb24gPCByZXF1aXJlZEFwaVZlcnNpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGUgbGl2ZSBldmVudHMgQVBJIHJlcXVpcmVzIEFQSSB2ZXJzaW9uICR7cmVxdWlyZWRBcGlWZXJzaW9ufSBvciBsYXRlci4gVGhlIGN1cnJlbnQgQVBJIHZlcnNpb24gaXMgJHthcGlWZXJzaW9ufS4gUGxlYXNlIHVwZGF0ZSB5b3VyIEFQSSB2ZXJzaW9uIHRvIHVzZSB0aGlzIGZlYXR1cmUuYFxuICAgICAgKTtcbiAgICBpZiAoaW5jbHVkZURyYWZ0cyAmJiAhdG9rZW4gJiYgIXdpdGhDcmVkZW50aWFscylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaGUgbGl2ZSBldmVudHMgQVBJIHJlcXVpcmVzIGEgdG9rZW4gb3Igd2l0aENyZWRlbnRpYWxzIHdoZW4gJ2luY2x1ZGVEcmFmdHM6IHRydWUnLiBQbGVhc2UgdXBkYXRlIHlvdXIgY2xpZW50IGNvbmZpZ3VyYXRpb24uIFRoZSB0b2tlbiBzaG91bGQgaGF2ZSB0aGUgbG93ZXN0IHBvc3NpYmxlIGFjY2VzcyByb2xlLlwiXG4gICAgICApO1xuICAgIGlmIChpbmNsdWRlRHJhZnRzICYmIGFwaVZlcnNpb24gIT09IFwiWFwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRoZSBsaXZlIGV2ZW50cyBBUEkgcmVxdWlyZXMgQVBJIHZlcnNpb24gWCB3aGVuICdpbmNsdWRlRHJhZnRzOiB0cnVlJy4gVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIG9yIGV2ZW4gYmUgcmVtb3ZlZC5cIlxuICAgICAgKTtcbiAgICBjb25zdCBwYXRoID0gX2dldERhdGFVcmwodGhpcy4jY2xpZW50LCBcImxpdmUvZXZlbnRzXCIpLCB1cmwgPSBuZXcgVVJMKHRoaXMuI2NsaWVudC5nZXRVcmwocGF0aCwgITEpKSwgdGFnID0gX3RhZyAmJiByZXF1ZXN0VGFnUHJlZml4ID8gW3JlcXVlc3RUYWdQcmVmaXgsIF90YWddLmpvaW4oXCIuXCIpIDogX3RhZztcbiAgICB0YWcgJiYgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0YWdcIiwgdGFnKSwgaW5jbHVkZURyYWZ0cyAmJiB1cmwuc2VhcmNoUGFyYW1zLnNldChcImluY2x1ZGVEcmFmdHNcIiwgXCJ0cnVlXCIpO1xuICAgIGNvbnN0IGxpc3RlbkZvciA9IFtcInJlc3RhcnRcIiwgXCJtZXNzYWdlXCIsIFwid2VsY29tZVwiLCBcInJlY29ubmVjdFwiXSwgZXNPcHRpb25zID0ge307XG4gICAgcmV0dXJuIGluY2x1ZGVEcmFmdHMgJiYgdG9rZW4gJiYgKGVzT3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICB9KSwgaW5jbHVkZURyYWZ0cyAmJiB3aXRoQ3JlZGVudGlhbHMgJiYgKGVzT3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgPSAhMCksIG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgICAgbGV0IGVzLCByZWNvbm5lY3RUaW1lciwgc3RvcHBlZCA9ICExLCB1bnN1YnNjcmliZWQgPSAhMTtcbiAgICAgIG9wZW4oKTtcbiAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXZ0KSB7XG4gICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBldnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gcGFyc2VFdmVudChldnQpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmV3IEVycm9yKGV2ZW50Lm1lc3NhZ2UsIHsgY2F1c2U6IGV2ZW50IH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXMucmVhZHlTdGF0ZSA9PT0gZXMuQ0xPU0VEICYmICh1bnN1YnNjcmliZSgpLCBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZXIpLCByZWNvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQob3BlbiwgMTAwKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTWVzc2FnZShldnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBwYXJzZUV2ZW50KGV2dCk7XG4gICAgICAgIHJldHVybiBldmVudCBpbnN0YW5jZW9mIEVycm9yID8gb2JzZXJ2ZXIuZXJyb3IoZXZlbnQpIDogb2JzZXJ2ZXIubmV4dChldmVudCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKGVzKSB7XG4gICAgICAgICAgZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBsaXN0ZW5Gb3IpXG4gICAgICAgICAgICBlcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIG9uTWVzc2FnZSk7XG4gICAgICAgICAgZXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXN5bmMgZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2UoKSB7XG4gICAgICAgIGNvbnN0IEV2ZW50U291cmNlSW1wbGVtZW50YXRpb24gPSB0eXBlb2YgRXZlbnRTb3VyY2UgPiBcInVcIiB8fCBlc09wdGlvbnMuaGVhZGVycyB8fCBlc09wdGlvbnMud2l0aENyZWRlbnRpYWxzID8gKGF3YWl0IGltcG9ydChcIkBzYW5pdHkvZXZlbnRzb3VyY2VcIikpLmRlZmF1bHQgOiBFdmVudFNvdXJjZTtcbiAgICAgICAgaWYgKHVuc3Vic2NyaWJlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIk9QVElPTlNcIixcbiAgICAgICAgICAgIG1vZGU6IFwiY29yc1wiLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6IGVzT3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwib21pdFwiLFxuICAgICAgICAgICAgaGVhZGVyczogZXNPcHRpb25zLmhlYWRlcnNcbiAgICAgICAgICB9KSwgdW5zdWJzY3JpYmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQ29yc09yaWdpbkVycm9yKHsgcHJvamVjdElkOiBwcm9qZWN0SWQyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2cyA9IG5ldyBFdmVudFNvdXJjZUltcGxlbWVudGF0aW9uKHVybC50b1N0cmluZygpLCBlc09wdGlvbnMpO1xuICAgICAgICBldnMuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgbGlzdGVuRm9yKVxuICAgICAgICAgIGV2cy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIG9uTWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBldnM7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBnZXRFdmVudFNvdXJjZSgpLnRoZW4oKGV2ZW50U291cmNlKSA9PiB7XG4gICAgICAgICAgZXZlbnRTb3VyY2UgJiYgKGVzID0gZXZlbnRTb3VyY2UsIHVuc3Vic2NyaWJlZCAmJiB1bnN1YnNjcmliZSgpKTtcbiAgICAgICAgfSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yKHJlYXNvbiksIHN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBzdG9wcGVkID0gITAsIHVuc3Vic2NyaWJlKCksIHVuc3Vic2NyaWJlZCA9ICEwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0b3A7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlRXZlbnQoZXZlbnQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YSAmJiBKU09OLnBhcnNlKGV2ZW50LmRhdGEpIHx8IHt9O1xuICAgIHJldHVybiB7IHR5cGU6IGV2ZW50LnR5cGUsIGlkOiBldmVudC5sYXN0RXZlbnRJZCwgLi4uZGF0YSB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG59XG5jbGFzcyBPYnNlcnZhYmxlRGF0YXNldHNDbGllbnQge1xuICAjY2xpZW50O1xuICAjaHR0cFJlcXVlc3Q7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBkYXRhc2V0XG4gICAqL1xuICBjcmVhdGUobmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfbW9kaWZ5KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIFwiUFVUXCIsIG5hbWUsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBFZGl0IGEgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgZGF0YXNldCB0byBlZGl0XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmV3IG9wdGlvbnMgZm9yIHRoZSBkYXRhc2V0XG4gICAqL1xuICBlZGl0KG5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX21vZGlmeSh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCBcIlBBVENIXCIsIG5hbWUsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKG5hbWUpIHtcbiAgICByZXR1cm4gX21vZGlmeSh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCBcIkRFTEVURVwiLCBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIGRhdGFzZXRzIGZvciB0aGUgY29uZmlndXJlZCBwcm9qZWN0XG4gICAqL1xuICBsaXN0KCkge1xuICAgIHJldHVybiBfcmVxdWVzdCh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCB7XG4gICAgICB1cmk6IFwiL2RhdGFzZXRzXCIsXG4gICAgICB0YWc6IG51bGxcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgRGF0YXNldHNDbGllbnQge1xuICAjY2xpZW50O1xuICAjaHR0cFJlcXVlc3Q7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBkYXRhc2V0XG4gICAqL1xuICBjcmVhdGUobmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX21vZGlmeSh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCBcIlBVVFwiLCBuYW1lLCBvcHRpb25zKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEVkaXQgYSBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGVkaXRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOZXcgb3B0aW9ucyBmb3IgdGhlIGRhdGFzZXRcbiAgICovXG4gIGVkaXQobmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX21vZGlmeSh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCBcIlBBVENIXCIsIG5hbWUsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgZGF0YXNldCB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX21vZGlmeSh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCBcIkRFTEVURVwiLCBuYW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBkYXRhc2V0cyBmb3IgdGhlIGNvbmZpZ3VyZWQgcHJvamVjdFxuICAgKi9cbiAgbGlzdCgpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIF9yZXF1ZXN0KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIHsgdXJpOiBcIi9kYXRhc2V0c1wiLCB0YWc6IG51bGwgfSlcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBfbW9kaWZ5KGNsaWVudCwgaHR0cFJlcXVlc3QsIG1ldGhvZCwgbmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4gZGF0YXNldChuYW1lKSwgX3JlcXVlc3QoY2xpZW50LCBodHRwUmVxdWVzdCwge1xuICAgIG1ldGhvZCxcbiAgICB1cmk6IGAvZGF0YXNldHMvJHtuYW1lfWAsXG4gICAgYm9keTogb3B0aW9ucyxcbiAgICB0YWc6IG51bGxcbiAgfSk7XG59XG5jbGFzcyBPYnNlcnZhYmxlUHJvamVjdHNDbGllbnQge1xuICAjY2xpZW50O1xuICAjaHR0cFJlcXVlc3Q7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG4gIH1cbiAgbGlzdChvcHRpb25zKSB7XG4gICAgY29uc3QgdXJpID0gb3B0aW9ucz8uaW5jbHVkZU1lbWJlcnMgPT09ICExID8gXCIvcHJvamVjdHM/aW5jbHVkZU1lbWJlcnM9ZmFsc2VcIiA6IFwiL3Byb2plY3RzXCI7XG4gICAgcmV0dXJuIF9yZXF1ZXN0KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIHsgdXJpIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2plY3QgYnkgcHJvamVjdCBJRFxuICAgKlxuICAgKiBAcGFyYW0gcHJvamVjdElkIC0gSUQgb2YgdGhlIHByb2plY3QgdG8gZmV0Y2hcbiAgICovXG4gIGdldEJ5SWQocHJvamVjdElkMikge1xuICAgIHJldHVybiBfcmVxdWVzdCh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCB7IHVyaTogYC9wcm9qZWN0cy8ke3Byb2plY3RJZDJ9YCB9KTtcbiAgfVxufVxuY2xhc3MgUHJvamVjdHNDbGllbnQge1xuICAjY2xpZW50O1xuICAjaHR0cFJlcXVlc3Q7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG4gIH1cbiAgbGlzdChvcHRpb25zKSB7XG4gICAgY29uc3QgdXJpID0gb3B0aW9ucz8uaW5jbHVkZU1lbWJlcnMgPT09ICExID8gXCIvcHJvamVjdHM/aW5jbHVkZU1lbWJlcnM9ZmFsc2VcIiA6IFwiL3Byb2plY3RzXCI7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX3JlcXVlc3QodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgeyB1cmkgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2plY3QgYnkgcHJvamVjdCBJRFxuICAgKlxuICAgKiBAcGFyYW0gcHJvamVjdElkIC0gSUQgb2YgdGhlIHByb2plY3QgdG8gZmV0Y2hcbiAgICovXG4gIGdldEJ5SWQocHJvamVjdElkMikge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX3JlcXVlc3QodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgeyB1cmk6IGAvcHJvamVjdHMvJHtwcm9qZWN0SWQyfWAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBPYnNlcnZhYmxlVXNlcnNDbGllbnQge1xuICAjY2xpZW50O1xuICAjaHR0cFJlcXVlc3Q7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgdXNlciBieSB1c2VyIElEXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFVzZXIgSUQgb2YgdGhlIHVzZXIgdG8gZmV0Y2guIElmIGBtZWAgaXMgcHJvdmlkZWQsIGEgbWluaW1hbCByZXNwb25zZSBpbmNsdWRpbmcgdGhlIHVzZXJzIHJvbGUgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIF9yZXF1ZXN0KFxuICAgICAgdGhpcy4jY2xpZW50LFxuICAgICAgdGhpcy4jaHR0cFJlcXVlc3QsXG4gICAgICB7IHVyaTogYC91c2Vycy8ke2lkfWAgfVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIFVzZXJzQ2xpZW50IHtcbiAgI2NsaWVudDtcbiAgI2h0dHBSZXF1ZXN0O1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGh0dHBSZXF1ZXN0KSB7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0O1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHVzZXIgYnkgdXNlciBJRFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBVc2VyIElEIG9mIHRoZSB1c2VyIHRvIGZldGNoLiBJZiBgbWVgIGlzIHByb3ZpZGVkLCBhIG1pbmltYWwgcmVzcG9uc2UgaW5jbHVkaW5nIHRoZSB1c2VycyByb2xlIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX3JlcXVlc3QodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwge1xuICAgICAgICB1cmk6IGAvdXNlcnMvJHtpZH1gXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIE9ic2VydmFibGVTYW5pdHlDbGllbnQge1xuICBhc3NldHM7XG4gIGRhdGFzZXRzO1xuICBsaXZlO1xuICBwcm9qZWN0cztcbiAgdXNlcnM7XG4gIC8qKlxuICAgKiBQcml2YXRlIHByb3BlcnRpZXNcbiAgICovXG4gICNjbGllbnRDb25maWc7XG4gICNodHRwUmVxdWVzdDtcbiAgLyoqXG4gICAqIEluc3RhbmNlIHByb3BlcnRpZXNcbiAgICovXG4gIGxpc3RlbiA9IF9saXN0ZW47XG4gIGNvbnN0cnVjdG9yKGh0dHBSZXF1ZXN0LCBjb25maWcgPSBkZWZhdWx0Q29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcoY29uZmlnKSwgdGhpcy4jaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdCwgdGhpcy5hc3NldHMgPSBuZXcgT2JzZXJ2YWJsZUFzc2V0c0NsaWVudCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCksIHRoaXMuZGF0YXNldHMgPSBuZXcgT2JzZXJ2YWJsZURhdGFzZXRzQ2xpZW50KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0KSwgdGhpcy5saXZlID0gbmV3IExpdmVDbGllbnQodGhpcyksIHRoaXMucHJvamVjdHMgPSBuZXcgT2JzZXJ2YWJsZVByb2plY3RzQ2xpZW50KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0KSwgdGhpcy51c2VycyA9IG5ldyBPYnNlcnZhYmxlVXNlcnNDbGllbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZSB0aGUgY2xpZW50IC0gcmV0dXJucyBhIG5ldyBpbnN0YW5jZVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlU2FuaXR5Q2xpZW50KHRoaXMuI2h0dHBSZXF1ZXN0LCB0aGlzLmNvbmZpZygpKTtcbiAgfVxuICBjb25maWcobmV3Q29uZmlnKSB7XG4gICAgaWYgKG5ld0NvbmZpZyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHsgLi4udGhpcy4jY2xpZW50Q29uZmlnIH07XG4gICAgaWYgKHRoaXMuI2NsaWVudENvbmZpZyAmJiB0aGlzLiNjbGllbnRDb25maWcuYWxsb3dSZWNvbmZpZ3VyZSA9PT0gITEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXhpc3RpbmcgY2xpZW50IGluc3RhbmNlIGNhbm5vdCBiZSByZWNvbmZpZ3VyZWQgLSB1c2UgYHdpdGhDb25maWcobmV3Q29uZmlnKWAgdG8gcmV0dXJuIGEgbmV3IGNsaWVudFwiXG4gICAgICApO1xuICAgIHJldHVybiB0aGlzLiNjbGllbnRDb25maWcgPSBpbml0Q29uZmlnKG5ld0NvbmZpZywgdGhpcy4jY2xpZW50Q29uZmlnIHx8IHt9KSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2xvbmUgdGhlIGNsaWVudCB3aXRoIGEgbmV3IChwYXJ0aWFsKSBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbmV3Q29uZmlnIC0gTmV3IGNsaWVudCBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMsIHNoYWxsb3dseSBtZXJnZWQgd2l0aCBleGlzdGluZyBjb25maWd1cmF0aW9uXG4gICAqL1xuICB3aXRoQ29uZmlnKG5ld0NvbmZpZykge1xuICAgIGNvbnN0IHRoaXNDb25maWcgPSB0aGlzLmNvbmZpZygpO1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVNhbml0eUNsaWVudCh0aGlzLiNodHRwUmVxdWVzdCwge1xuICAgICAgLi4udGhpc0NvbmZpZyxcbiAgICAgIC4uLm5ld0NvbmZpZyxcbiAgICAgIHN0ZWdhOiB7XG4gICAgICAgIC4uLnRoaXNDb25maWcuc3RlZ2EgfHwge30sXG4gICAgICAgIC4uLnR5cGVvZiBuZXdDb25maWc/LnN0ZWdhID09IFwiYm9vbGVhblwiID8geyBlbmFibGVkOiBuZXdDb25maWcuc3RlZ2EgfSA6IG5ld0NvbmZpZz8uc3RlZ2EgfHwge31cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmZXRjaChxdWVyeSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9mZXRjaChcbiAgICAgIHRoaXMsXG4gICAgICB0aGlzLiNodHRwUmVxdWVzdCxcbiAgICAgIHRoaXMuI2NsaWVudENvbmZpZy5zdGVnYSxcbiAgICAgIHF1ZXJ5LFxuICAgICAgcGFyYW1zLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgc2luZ2xlIGRvY3VtZW50IHdpdGggdGhlIGdpdmVuIElELlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBEb2N1bWVudCBJRCB0byBmZXRjaFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9uc1xuICAgKi9cbiAgZ2V0RG9jdW1lbnQoaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2dldERvY3VtZW50KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBpZCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIG11bHRpcGxlIGRvY3VtZW50cyBpbiBvbmUgcmVxdWVzdC5cbiAgICogU2hvdWxkIGJlIHVzZWQgc3BhcmluZ2x5IC0gcGVyZm9ybWluZyBhIHF1ZXJ5IGlzIHVzdWFsbHkgYSBiZXR0ZXIgb3B0aW9uLlxuICAgKiBUaGUgb3JkZXIvcG9zaXRpb24gb2YgZG9jdW1lbnRzIGlzIHByZXNlcnZlZCBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgSURzLlxuICAgKiBJZiBhbnkgb2YgdGhlIGRvY3VtZW50cyBhcmUgbWlzc2luZywgdGhleSB3aWxsIGJlIHJlcGxhY2VkIGJ5IGEgYG51bGxgIGVudHJ5IGluIHRoZSByZXR1cm5lZCBhcnJheVxuICAgKlxuICAgKiBAcGFyYW0gaWRzIC0gRG9jdW1lbnQgSURzIHRvIGZldGNoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqL1xuICBnZXREb2N1bWVudHMoaWRzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9nZXREb2N1bWVudHModGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIGlkcywgb3B0aW9ucyk7XG4gIH1cbiAgY3JlYXRlKGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9jcmVhdGUodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIGRvY3VtZW50LCBcImNyZWF0ZVwiLCBvcHRpb25zKTtcbiAgfVxuICBjcmVhdGVJZk5vdEV4aXN0cyhkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfY3JlYXRlSWZOb3RFeGlzdHModGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIGRvY3VtZW50LCBvcHRpb25zKTtcbiAgfVxuICBjcmVhdGVPclJlcGxhY2UoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2NyZWF0ZU9yUmVwbGFjZSh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgZG9jdW1lbnQsIG9wdGlvbnMpO1xuICB9XG4gIGRlbGV0ZShzZWxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2RlbGV0ZSh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgc2VsZWN0aW9uLCBvcHRpb25zKTtcbiAgfVxuICBtdXRhdGUob3BlcmF0aW9ucywgb3B0aW9ucykge1xuICAgIHJldHVybiBfbXV0YXRlKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBvcGVyYXRpb25zLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGJ1aWxkYWJsZSBwYXRjaCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdGlvbiAtIERvY3VtZW50IElELCBhbiBhcnJheSBvZiBkb2N1bWVudCBJRHMsIG9yIGFuIG9iamVjdCB3aXRoIGBxdWVyeWAgYW5kIG9wdGlvbmFsIGBwYXJhbXNgLCBkZWZpbmluZyB3aGljaCBkb2N1bWVudChzKSB0byBwYXRjaFxuICAgKiBAcGFyYW0gb3BlcmF0aW9ucyAtIE9wdGlvbmFsIG9iamVjdCBvZiBwYXRjaCBvcGVyYXRpb25zIHRvIGluaXRpYWxpemUgdGhlIHBhdGNoIGluc3RhbmNlIHdpdGhcbiAgICogQHJldHVybnMgUGF0Y2ggaW5zdGFuY2UgLSBjYWxsIGAuY29tbWl0KClgIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbnMgZGVmaW5lZFxuICAgKi9cbiAgcGF0Y2goc2VsZWN0aW9uLCBvcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlUGF0Y2goc2VsZWN0aW9uLCBvcGVyYXRpb25zLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHRyYW5zYWN0aW9uIG9mIG11dGF0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9ucyAtIE9wdGlvbmFsIGFycmF5IG9mIG11dGF0aW9uIG9wZXJhdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgdHJhbnNhY3Rpb24gaW5zdGFuY2Ugd2l0aFxuICAgKi9cbiAgdHJhbnNhY3Rpb24ob3BlcmF0aW9ucykge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVRyYW5zYWN0aW9uKG9wZXJhdGlvbnMsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFjdGlvbiBvcGVyYXRpb25zIGFnYWluc3QgdGhlIGNvbmZpZ3VyZWQgZGF0YXNldFxuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9ucyAtIEFjdGlvbiBvcGVyYXRpb24ocykgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFjdGlvbiBvcHRpb25zXG4gICAqL1xuICBhY3Rpb24ob3BlcmF0aW9ucywgb3B0aW9ucykge1xuICAgIHJldHVybiBfYWN0aW9uKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBvcGVyYXRpb25zLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBhbiBIVFRQIHJlcXVlc3QgYWdhaW5zdCB0aGUgU2FuaXR5IEFQSVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9uc1xuICAgKi9cbiAgcmVxdWVzdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9yZXF1ZXN0KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgU2FuaXR5IEFQSSBVUkwgZm9yIHRoZSBVUkkgcHJvdmlkZWRcbiAgICpcbiAgICogQHBhcmFtIHVyaSAtIFVSSS9wYXRoIHRvIGJ1aWxkIFVSTCBmb3JcbiAgICogQHBhcmFtIGNhblVzZUNkbiAtIFdoZXRoZXIgb3Igbm90IHRvIGFsbG93IHVzaW5nIHRoZSBBUEkgQ0ROIGZvciB0aGlzIHJvdXRlXG4gICAqL1xuICBnZXRVcmwodXJpLCBjYW5Vc2VDZG4pIHtcbiAgICByZXR1cm4gX2dldFVybCh0aGlzLCB1cmksIGNhblVzZUNkbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIFNhbml0eSBBUEkgVVJMIGZvciB0aGUgZGF0YSBvcGVyYXRpb24gYW5kIHBhdGggcHJvdmlkZWRcbiAgICpcbiAgICogQHBhcmFtIG9wZXJhdGlvbiAtIERhdGEgb3BlcmF0aW9uIChlZyBgcXVlcnlgLCBgbXV0YXRlYCwgYGxpc3RlbmAgb3Igc2ltaWxhcilcbiAgICogQHBhcmFtIHBhdGggLSBQYXRoIHRvIGFwcGVuZCBhZnRlciB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBnZXREYXRhVXJsKG9wZXJhdGlvbiwgcGF0aCkge1xuICAgIHJldHVybiBfZ2V0RGF0YVVybCh0aGlzLCBvcGVyYXRpb24sIHBhdGgpO1xuICB9XG59XG5jbGFzcyBTYW5pdHlDbGllbnQge1xuICBhc3NldHM7XG4gIGRhdGFzZXRzO1xuICBsaXZlO1xuICBwcm9qZWN0cztcbiAgdXNlcnM7XG4gIC8qKlxuICAgKiBPYnNlcnZhYmxlIHZlcnNpb24gb2YgdGhlIFNhbml0eSBjbGllbnQsIHdpdGggdGhlIHNhbWUgY29uZmlndXJhdGlvbiBhcyB0aGUgcHJvbWlzZS1iYXNlZCBvbmVcbiAgICovXG4gIG9ic2VydmFibGU7XG4gIC8qKlxuICAgKiBQcml2YXRlIHByb3BlcnRpZXNcbiAgICovXG4gICNjbGllbnRDb25maWc7XG4gICNodHRwUmVxdWVzdDtcbiAgLyoqXG4gICAqIEluc3RhbmNlIHByb3BlcnRpZXNcbiAgICovXG4gIGxpc3RlbiA9IF9saXN0ZW47XG4gIGNvbnN0cnVjdG9yKGh0dHBSZXF1ZXN0LCBjb25maWcgPSBkZWZhdWx0Q29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcoY29uZmlnKSwgdGhpcy4jaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdCwgdGhpcy5hc3NldHMgPSBuZXcgQXNzZXRzQ2xpZW50KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0KSwgdGhpcy5kYXRhc2V0cyA9IG5ldyBEYXRhc2V0c0NsaWVudCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCksIHRoaXMubGl2ZSA9IG5ldyBMaXZlQ2xpZW50KHRoaXMpLCB0aGlzLnByb2plY3RzID0gbmV3IFByb2plY3RzQ2xpZW50KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0KSwgdGhpcy51c2VycyA9IG5ldyBVc2Vyc0NsaWVudCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCksIHRoaXMub2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlU2FuaXR5Q2xpZW50KGh0dHBSZXF1ZXN0LCBjb25maWcpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZSB0aGUgY2xpZW50IC0gcmV0dXJucyBhIG5ldyBpbnN0YW5jZVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBTYW5pdHlDbGllbnQodGhpcy4jaHR0cFJlcXVlc3QsIHRoaXMuY29uZmlnKCkpO1xuICB9XG4gIGNvbmZpZyhuZXdDb25maWcpIHtcbiAgICBpZiAobmV3Q29uZmlnID09PSB2b2lkIDApXG4gICAgICByZXR1cm4geyAuLi50aGlzLiNjbGllbnRDb25maWcgfTtcbiAgICBpZiAodGhpcy4jY2xpZW50Q29uZmlnICYmIHRoaXMuI2NsaWVudENvbmZpZy5hbGxvd1JlY29uZmlndXJlID09PSAhMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeGlzdGluZyBjbGllbnQgaW5zdGFuY2UgY2Fubm90IGJlIHJlY29uZmlndXJlZCAtIHVzZSBgd2l0aENvbmZpZyhuZXdDb25maWcpYCB0byByZXR1cm4gYSBuZXcgY2xpZW50XCJcbiAgICAgICk7XG4gICAgcmV0dXJuIHRoaXMub2JzZXJ2YWJsZSAmJiB0aGlzLm9ic2VydmFibGUuY29uZmlnKG5ld0NvbmZpZyksIHRoaXMuI2NsaWVudENvbmZpZyA9IGluaXRDb25maWcobmV3Q29uZmlnLCB0aGlzLiNjbGllbnRDb25maWcgfHwge30pLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZSB0aGUgY2xpZW50IHdpdGggYSBuZXcgKHBhcnRpYWwpIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBuZXdDb25maWcgLSBOZXcgY2xpZW50IGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcywgc2hhbGxvd2x5IG1lcmdlZCB3aXRoIGV4aXN0aW5nIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIHdpdGhDb25maWcobmV3Q29uZmlnKSB7XG4gICAgY29uc3QgdGhpc0NvbmZpZyA9IHRoaXMuY29uZmlnKCk7XG4gICAgcmV0dXJuIG5ldyBTYW5pdHlDbGllbnQodGhpcy4jaHR0cFJlcXVlc3QsIHtcbiAgICAgIC4uLnRoaXNDb25maWcsXG4gICAgICAuLi5uZXdDb25maWcsXG4gICAgICBzdGVnYToge1xuICAgICAgICAuLi50aGlzQ29uZmlnLnN0ZWdhIHx8IHt9LFxuICAgICAgICAuLi50eXBlb2YgbmV3Q29uZmlnPy5zdGVnYSA9PSBcImJvb2xlYW5cIiA/IHsgZW5hYmxlZDogbmV3Q29uZmlnLnN0ZWdhIH0gOiBuZXdDb25maWc/LnN0ZWdhIHx8IHt9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZmV0Y2gocXVlcnksIHBhcmFtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX2ZldGNoKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLiNodHRwUmVxdWVzdCxcbiAgICAgICAgdGhpcy4jY2xpZW50Q29uZmlnLnN0ZWdhLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBvcHRpb25zXG4gICAgICApXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBzaW5nbGUgZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIERvY3VtZW50IElEIHRvIGZldGNoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqL1xuICBnZXREb2N1bWVudChpZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9nZXREb2N1bWVudCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgaWQsIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggbXVsdGlwbGUgZG9jdW1lbnRzIGluIG9uZSByZXF1ZXN0LlxuICAgKiBTaG91bGQgYmUgdXNlZCBzcGFyaW5nbHkgLSBwZXJmb3JtaW5nIGEgcXVlcnkgaXMgdXN1YWxseSBhIGJldHRlciBvcHRpb24uXG4gICAqIFRoZSBvcmRlci9wb3NpdGlvbiBvZiBkb2N1bWVudHMgaXMgcHJlc2VydmVkIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBhcnJheSBvZiBJRHMuXG4gICAqIElmIGFueSBvZiB0aGUgZG9jdW1lbnRzIGFyZSBtaXNzaW5nLCB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgYnkgYSBgbnVsbGAgZW50cnkgaW4gdGhlIHJldHVybmVkIGFycmF5XG4gICAqXG4gICAqIEBwYXJhbSBpZHMgLSBEb2N1bWVudCBJRHMgdG8gZmV0Y2hcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnNcbiAgICovXG4gIGdldERvY3VtZW50cyhpZHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfZ2V0RG9jdW1lbnRzKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBpZHMsIG9wdGlvbnMpKTtcbiAgfVxuICBjcmVhdGUoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIF9jcmVhdGUodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIGRvY3VtZW50LCBcImNyZWF0ZVwiLCBvcHRpb25zKVxuICAgICk7XG4gIH1cbiAgY3JlYXRlSWZOb3RFeGlzdHMoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIF9jcmVhdGVJZk5vdEV4aXN0cyh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgZG9jdW1lbnQsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICBjcmVhdGVPclJlcGxhY2UoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIF9jcmVhdGVPclJlcGxhY2UodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIGRvY3VtZW50LCBvcHRpb25zKVxuICAgICk7XG4gIH1cbiAgZGVsZXRlKHNlbGVjdGlvbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9kZWxldGUodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIHNlbGVjdGlvbiwgb3B0aW9ucykpO1xuICB9XG4gIG11dGF0ZShvcGVyYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX211dGF0ZSh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgb3BlcmF0aW9ucywgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYnVpbGRhYmxlIHBhdGNoIG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybVxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gRG9jdW1lbnQgSUQsIGFuIGFycmF5IG9mIGRvY3VtZW50IElEcywgb3IgYW4gb2JqZWN0IHdpdGggYHF1ZXJ5YCBhbmQgb3B0aW9uYWwgYHBhcmFtc2AsIGRlZmluaW5nIHdoaWNoIGRvY3VtZW50KHMpIHRvIHBhdGNoXG4gICAqIEBwYXJhbSBvcGVyYXRpb25zIC0gT3B0aW9uYWwgb2JqZWN0IG9mIHBhdGNoIG9wZXJhdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgcGF0Y2ggaW5zdGFuY2Ugd2l0aFxuICAgKiBAcmV0dXJucyBQYXRjaCBpbnN0YW5jZSAtIGNhbGwgYC5jb21taXQoKWAgdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9ucyBkZWZpbmVkXG4gICAqL1xuICBwYXRjaChkb2N1bWVudElkLCBvcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQYXRjaChkb2N1bWVudElkLCBvcGVyYXRpb25zLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHRyYW5zYWN0aW9uIG9mIG11dGF0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9ucyAtIE9wdGlvbmFsIGFycmF5IG9mIG11dGF0aW9uIG9wZXJhdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgdHJhbnNhY3Rpb24gaW5zdGFuY2Ugd2l0aFxuICAgKi9cbiAgdHJhbnNhY3Rpb24ob3BlcmF0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24ob3BlcmF0aW9ucywgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm0gYWN0aW9uIG9wZXJhdGlvbnMgYWdhaW5zdCB0aGUgY29uZmlndXJlZCBkYXRhc2V0XG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHJlc3VsdFxuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9ucyAtIEFjdGlvbiBvcGVyYXRpb24ocykgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFjdGlvbiBvcHRpb25zXG4gICAqL1xuICBhY3Rpb24ob3BlcmF0aW9ucywgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9hY3Rpb24odGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIG9wZXJhdGlvbnMsIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBhIHJlcXVlc3QgYWdhaW5zdCB0aGUgU2FuaXR5IEFQSVxuICAgKiBOT1RFOiBPbmx5IHVzZSB0aGlzIGZvciBTYW5pdHkgQVBJIGVuZHBvaW50cywgbm90IGZvciB5b3VyIG93biBBUElzIVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgcmVzcG9uc2UgYm9keVxuICAgKi9cbiAgcmVxdWVzdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX3JlcXVlc3QodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBhbiBIVFRQIHJlcXVlc3QgYSBgL2RhdGFgIHN1Yi1lbmRwb2ludFxuICAgKiBOT1RFOiBDb25zaWRlcmVkIGludGVybmFsLCB0aHVzIG1hcmtlZCBhcyBkZXByZWNhdGVkLiBVc2UgYHJlcXVlc3RgIGluc3RlYWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIC0gVXNlIGByZXF1ZXN0KClgIG9yIHlvdXIgb3duIEhUVFAgbGlicmFyeSBpbnN0ZWFkXG4gICAqIEBwYXJhbSBlbmRwb2ludCAtIEVuZHBvaW50IHRvIGhpdCAobXV0YXRlLCBxdWVyeSBldGMpXG4gICAqIEBwYXJhbSBib2R5IC0gUmVxdWVzdCBib2R5XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGF0YVJlcXVlc3QoZW5kcG9pbnQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfZGF0YVJlcXVlc3QodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIGVuZHBvaW50LCBib2R5LCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIFNhbml0eSBBUEkgVVJMIGZvciB0aGUgVVJJIHByb3ZpZGVkXG4gICAqXG4gICAqIEBwYXJhbSB1cmkgLSBVUkkvcGF0aCB0byBidWlsZCBVUkwgZm9yXG4gICAqIEBwYXJhbSBjYW5Vc2VDZG4gLSBXaGV0aGVyIG9yIG5vdCB0byBhbGxvdyB1c2luZyB0aGUgQVBJIENETiBmb3IgdGhpcyByb3V0ZVxuICAgKi9cbiAgZ2V0VXJsKHVyaSwgY2FuVXNlQ2RuKSB7XG4gICAgcmV0dXJuIF9nZXRVcmwodGhpcywgdXJpLCBjYW5Vc2VDZG4pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBTYW5pdHkgQVBJIFVSTCBmb3IgdGhlIGRhdGEgb3BlcmF0aW9uIGFuZCBwYXRoIHByb3ZpZGVkXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gLSBEYXRhIG9wZXJhdGlvbiAoZWcgYHF1ZXJ5YCwgYG11dGF0ZWAsIGBsaXN0ZW5gIG9yIHNpbWlsYXIpXG4gICAqIEBwYXJhbSBwYXRoIC0gUGF0aCB0byBhcHBlbmQgYWZ0ZXIgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgZ2V0RGF0YVVybChvcGVyYXRpb24sIHBhdGgpIHtcbiAgICByZXR1cm4gX2dldERhdGFVcmwodGhpcywgb3BlcmF0aW9uLCBwYXRoKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lQ3JlYXRlQ2xpZW50RXhwb3J0cyhlbnZNaWRkbGV3YXJlMiwgQ2xhc3NDb25zdHJ1Y3Rvcikge1xuICBjb25zdCBkZWZhdWx0UmVxdWVzdGVyID0gZGVmaW5lSHR0cFJlcXVlc3QoZW52TWlkZGxld2FyZTIpO1xuICByZXR1cm4geyByZXF1ZXN0ZXI6IGRlZmF1bHRSZXF1ZXN0ZXIsIGNyZWF0ZUNsaWVudDogKGNvbmZpZykgPT4gbmV3IENsYXNzQ29uc3RydWN0b3IoXG4gICAgKG9wdGlvbnMsIHJlcXVlc3RlcjIpID0+IChyZXF1ZXN0ZXIyIHx8IGRlZmF1bHRSZXF1ZXN0ZXIpKHtcbiAgICAgIG1heFJlZGlyZWN0czogMCxcbiAgICAgIG1heFJldHJpZXM6IGNvbmZpZy5tYXhSZXRyaWVzLFxuICAgICAgcmV0cnlEZWxheTogY29uZmlnLnJldHJ5RGVsYXksXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSksXG4gICAgY29uZmlnXG4gICkgfTtcbn1cbmZ1bmN0aW9uIGRlZmluZURlcHJlY2F0ZWRDcmVhdGVDbGllbnQoY3JlYXRlQ2xpZW50Mikge1xuICByZXR1cm4gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgcmV0dXJuIHByaW50Tm9EZWZhdWx0RXhwb3J0KCksIGNyZWF0ZUNsaWVudDIoY29uZmlnKTtcbiAgfTtcbn1cbnZhciBlbnZNaWRkbGV3YXJlID0gW107XG5jb25zdCBleHAgPSBkZWZpbmVDcmVhdGVDbGllbnRFeHBvcnRzKGVudk1pZGRsZXdhcmUsIFNhbml0eUNsaWVudCksIHJlcXVlc3RlciA9IGV4cC5yZXF1ZXN0ZXIsIGNyZWF0ZUNsaWVudCA9IGV4cC5jcmVhdGVDbGllbnQsIGRlcHJlY2F0ZWRDcmVhdGVDbGllbnQgPSBkZWZpbmVEZXByZWNhdGVkQ3JlYXRlQ2xpZW50KGNyZWF0ZUNsaWVudCk7XG5leHBvcnQge1xuICBCYXNlUGF0Y2gsXG4gIEJhc2VUcmFuc2FjdGlvbixcbiAgQ2xpZW50RXJyb3IsXG4gIENvcnNPcmlnaW5FcnJvcixcbiAgT2JzZXJ2YWJsZVBhdGNoLFxuICBPYnNlcnZhYmxlU2FuaXR5Q2xpZW50LFxuICBPYnNlcnZhYmxlVHJhbnNhY3Rpb24sXG4gIFBhdGNoLFxuICBTYW5pdHlDbGllbnQsXG4gIFNlcnZlckVycm9yLFxuICBUcmFuc2FjdGlvbixcbiAgY3JlYXRlQ2xpZW50LFxuICBkZXByZWNhdGVkQ3JlYXRlQ2xpZW50IGFzIGRlZmF1bHQsXG4gIHJlcXVlc3RlcixcbiAgYWRhcHRlciBhcyB1bnN0YWJsZV9fYWRhcHRlcixcbiAgZW52aXJvbm1lbnQgYXMgdW5zdGFibGVfX2Vudmlyb25tZW50LFxuICB2YWxpZGF0ZUFwaVBlcnNwZWN0aXZlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguYnJvd3Nlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@sanity/client/dist/index.browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@sanity/client/dist/index.browser.js":
/*!***********************************************************!*\
  !*** ./node_modules/@sanity/client/dist/index.browser.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePatch: () => (/* binding */ BasePatch),\n/* harmony export */   BaseTransaction: () => (/* binding */ BaseTransaction),\n/* harmony export */   ClientError: () => (/* binding */ ClientError),\n/* harmony export */   CorsOriginError: () => (/* binding */ CorsOriginError),\n/* harmony export */   ObservablePatch: () => (/* binding */ ObservablePatch),\n/* harmony export */   ObservableSanityClient: () => (/* binding */ ObservableSanityClient),\n/* harmony export */   ObservableTransaction: () => (/* binding */ ObservableTransaction),\n/* harmony export */   Patch: () => (/* binding */ Patch),\n/* harmony export */   SanityClient: () => (/* binding */ SanityClient),\n/* harmony export */   ServerError: () => (/* binding */ ServerError),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   \"default\": () => (/* binding */ deprecatedCreateClient),\n/* harmony export */   requester: () => (/* binding */ requester),\n/* harmony export */   unstable__adapter: () => (/* reexport safe */ get_it__WEBPACK_IMPORTED_MODULE_0__.adapter),\n/* harmony export */   unstable__environment: () => (/* reexport safe */ get_it__WEBPACK_IMPORTED_MODULE_0__.environment),\n/* harmony export */   validateApiPerspective: () => (/* binding */ validateApiPerspective)\n/* harmony export */ });\n/* harmony import */ var get_it__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! get-it */ \"(rsc)/./node_modules/get-it/dist/index.react-server.js\");\n/* harmony import */ var get_it_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! get-it/middleware */ \"(rsc)/./node_modules/get-it/dist/middleware.browser.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \"(rsc)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ \"(rsc)/./node_modules/rxjs/dist/esm5/internal/observable/from.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ \"(rsc)/./node_modules/rxjs/dist/esm5/internal/lastValueFrom.js\");\n/* harmony import */ var _chunks_es_stegaClean_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_chunks-es/stegaClean.js */ \"(rsc)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ \"(rsc)/./node_modules/rxjs/dist/cjs/operators/index.js\");\n\n\n\n\n\n\nclass ClientError extends Error {\n  response;\n  statusCode = 400;\n  responseBody;\n  details;\n  constructor(res) {\n    const props = extractErrorProps(res);\n    super(props.message), Object.assign(this, props);\n  }\n}\nclass ServerError extends Error {\n  response;\n  statusCode = 500;\n  responseBody;\n  details;\n  constructor(res) {\n    const props = extractErrorProps(res);\n    super(props.message), Object.assign(this, props);\n  }\n}\nfunction extractErrorProps(res) {\n  const body = res.body, props = {\n    response: res,\n    statusCode: res.statusCode,\n    responseBody: stringifyBody(body, res),\n    message: \"\",\n    details: void 0\n  };\n  if (body.error && body.message)\n    return props.message = `${body.error} - ${body.message}`, props;\n  if (isMutationError(body) || isActionError(body)) {\n    const allItems = body.error.items || [], items = allItems.slice(0, 5).map((item) => item.error?.description).filter(Boolean);\n    let itemsStr = items.length ? `:\n- ${items.join(`\n- `)}` : \"\";\n    return allItems.length > 5 && (itemsStr += `\n...and ${allItems.length - 5} more`), props.message = `${body.error.description}${itemsStr}`, props.details = body.error, props;\n  }\n  return body.error && body.error.description ? (props.message = body.error.description, props.details = body.error, props) : (props.message = body.error || body.message || httpErrorMessage(res), props);\n}\nfunction isMutationError(body) {\n  return isPlainObject(body) && isPlainObject(body.error) && body.error.type === \"mutationError\" && typeof body.error.description == \"string\";\n}\nfunction isActionError(body) {\n  return isPlainObject(body) && isPlainObject(body.error) && body.error.type === \"actionError\" && typeof body.error.description == \"string\";\n}\nfunction isPlainObject(obj) {\n  return typeof obj == \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction httpErrorMessage(res) {\n  const statusMessage = res.statusMessage ? ` ${res.statusMessage}` : \"\";\n  return `${res.method}-request to ${res.url} resulted in HTTP ${res.statusCode}${statusMessage}`;\n}\nfunction stringifyBody(body, res) {\n  return (res.headers[\"content-type\"] || \"\").toLowerCase().indexOf(\"application/json\") !== -1 ? JSON.stringify(body, null, 2) : body;\n}\nclass CorsOriginError extends Error {\n  projectId;\n  addOriginUrl;\n  constructor({ projectId: projectId2 }) {\n    super(\"CorsOriginError\"), this.name = \"CorsOriginError\", this.projectId = projectId2;\n    const url = new URL(`https://sanity.io/manage/project/${projectId2}/api`);\n    if (typeof location < \"u\") {\n      const { origin } = location;\n      url.searchParams.set(\"cors\", \"add\"), url.searchParams.set(\"origin\", origin), this.addOriginUrl = url, this.message = `The current origin is not allowed to connect to the Live Content API. Add it here: ${url}`;\n    } else\n      this.message = `The current origin is not allowed to connect to the Live Content API. Change your configuration here: ${url}`;\n  }\n}\nconst httpError = {\n  onResponse: (res) => {\n    if (res.statusCode >= 500)\n      throw new ServerError(res);\n    if (res.statusCode >= 400)\n      throw new ClientError(res);\n    return res;\n  }\n}, printWarnings = {\n  onResponse: (res) => {\n    const warn = res.headers[\"x-sanity-warning\"];\n    return (Array.isArray(warn) ? warn : [warn]).filter(Boolean).forEach((msg) => console.warn(msg)), res;\n  }\n};\nfunction defineHttpRequest(envMiddleware2) {\n  return (0,get_it__WEBPACK_IMPORTED_MODULE_0__.getIt)([\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.retry)({ shouldRetry }),\n    ...envMiddleware2,\n    printWarnings,\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.jsonRequest)(),\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.jsonResponse)(),\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.progress)(),\n    httpError,\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.observable)({ implementation: rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable })\n  ]);\n}\nfunction shouldRetry(err, attempt, options) {\n  if (options.maxRetries === 0)\n    return !1;\n  const isSafe = options.method === \"GET\" || options.method === \"HEAD\", isQuery = (options.uri || options.url).startsWith(\"/data/query\"), isRetriableResponse = err.response && (err.response.statusCode === 429 || err.response.statusCode === 502 || err.response.statusCode === 503);\n  return (isSafe || isQuery) && isRetriableResponse ? !0 : get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.retry.shouldRetry(err, attempt, options);\n}\nconst BASE_URL = \"https://www.sanity.io/help/\";\nfunction generateHelpUrl(slug) {\n  return BASE_URL + slug;\n}\nconst VALID_ASSET_TYPES = [\"image\", \"file\"], VALID_INSERT_LOCATIONS = [\"before\", \"after\", \"replace\"], dataset = (name) => {\n  if (!/^(~[a-z0-9]{1}[-\\w]{0,63}|[a-z0-9]{1}[-\\w]{0,63})$/.test(name))\n    throw new Error(\n      \"Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters\"\n    );\n}, projectId = (id) => {\n  if (!/^[-a-z0-9]+$/i.test(id))\n    throw new Error(\"`projectId` can only contain only a-z, 0-9 and dashes\");\n}, validateAssetType = (type) => {\n  if (VALID_ASSET_TYPES.indexOf(type) === -1)\n    throw new Error(`Invalid asset type: ${type}. Must be one of ${VALID_ASSET_TYPES.join(\", \")}`);\n}, validateObject = (op, val) => {\n  if (val === null || typeof val != \"object\" || Array.isArray(val))\n    throw new Error(`${op}() takes an object of properties`);\n}, validateDocumentId = (op, id) => {\n  if (typeof id != \"string\" || !/^[a-z0-9_][a-z0-9_.-]{0,127}$/i.test(id) || id.includes(\"..\"))\n    throw new Error(`${op}(): \"${id}\" is not a valid document ID`);\n}, requireDocumentId = (op, doc) => {\n  if (!doc._id)\n    throw new Error(`${op}() requires that the document contains an ID (\"_id\" property)`);\n  validateDocumentId(op, doc._id);\n}, validateInsert = (at, selector, items) => {\n  const signature = \"insert(at, selector, items)\";\n  if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {\n    const valid = VALID_INSERT_LOCATIONS.map((loc) => `\"${loc}\"`).join(\", \");\n    throw new Error(`${signature} takes an \"at\"-argument which is one of: ${valid}`);\n  }\n  if (typeof selector != \"string\")\n    throw new Error(`${signature} takes a \"selector\"-argument which must be a string`);\n  if (!Array.isArray(items))\n    throw new Error(`${signature} takes an \"items\"-argument which must be an array`);\n}, hasDataset = (config) => {\n  if (!config.dataset)\n    throw new Error(\"`dataset` must be provided to perform queries\");\n  return config.dataset || \"\";\n}, requestTag = (tag) => {\n  if (typeof tag != \"string\" || !/^[a-z0-9._-]{1,75}$/i.test(tag))\n    throw new Error(\n      \"Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.\"\n    );\n  return tag;\n};\nfunction once(fn) {\n  let didCall = !1, returnValue;\n  return (...args) => (didCall || (returnValue = fn(...args), didCall = !0), returnValue);\n}\nconst createWarningPrinter = (message) => (\n  // eslint-disable-next-line no-console\n  once((...args) => console.warn(message.join(\" \"), ...args))\n), printCdnAndWithCredentialsWarning = createWarningPrinter([\n  \"Because you set `withCredentials` to true, we will override your `useCdn`\",\n  \"setting to be false since (cookie-based) credentials are never set on the CDN\"\n]), printCdnWarning = createWarningPrinter([\n  \"Since you haven't set a value for `useCdn`, we will deliver content using our\",\n  \"global, edge-cached API-CDN. If you wish to have content delivered faster, set\",\n  \"`useCdn: false` to use the Live API. Note: You may incur higher costs using the live API.\"\n]), printCdnPreviewDraftsWarning = createWarningPrinter([\n  \"The Sanity client is configured with the `perspective` set to `previewDrafts`, which doesn't support the API-CDN.\",\n  \"The Live API will be used instead. Set `useCdn: false` in your configuration to hide this warning.\"\n]), printBrowserTokenWarning = createWarningPrinter([\n  \"You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.\",\n  `See ${generateHelpUrl(\n    \"js-client-browser-token\"\n  )} for more information and how to hide this warning.`\n]), printNoApiVersionSpecifiedWarning = createWarningPrinter([\n  \"Using the Sanity client without specifying an API version is deprecated.\",\n  `See ${generateHelpUrl(\"js-client-api-version\")}`\n]), printNoDefaultExport = createWarningPrinter([\n  \"The default export of @sanity/client has been deprecated. Use the named export `createClient` instead.\"\n]), defaultCdnHost = \"apicdn.sanity.io\", defaultConfig = {\n  apiHost: \"https://api.sanity.io\",\n  apiVersion: \"1\",\n  useProjectHostname: !0,\n  stega: { enabled: !1 }\n}, LOCALHOSTS = [\"localhost\", \"127.0.0.1\", \"0.0.0.0\"], isLocal = (host) => LOCALHOSTS.indexOf(host) !== -1;\nfunction validateApiVersion(apiVersion) {\n  if (apiVersion === \"1\" || apiVersion === \"X\")\n    return;\n  const apiDate = new Date(apiVersion);\n  if (!(/^\\d{4}-\\d{2}-\\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0))\n    throw new Error(\"Invalid API version string, expected `1` or date in format `YYYY-MM-DD`\");\n}\nfunction validateApiPerspective(perspective) {\n  if (Array.isArray(perspective)) {\n    for (const perspectiveValue of perspective)\n      if (perspectiveValue !== \"published\" && perspectiveValue !== \"drafts\" && !(typeof perspectiveValue == \"string\" && perspectiveValue.startsWith(\"r\") && perspectiveValue !== \"raw\"))\n        throw new TypeError(\n          \"Invalid API perspective value, expected `published`, `drafts` or a valid release identifier string\"\n        );\n    return;\n  }\n  switch (perspective) {\n    case \"previewDrafts\":\n    case \"drafts\":\n    case \"published\":\n    case \"raw\":\n      return;\n    default:\n      throw new TypeError(\n        \"Invalid API perspective string, expected `published`, `previewDrafts` or `raw`\"\n      );\n  }\n}\nconst initConfig = (config, prevConfig) => {\n  const specifiedConfig = {\n    ...prevConfig,\n    ...config,\n    stega: {\n      ...typeof prevConfig.stega == \"boolean\" ? { enabled: prevConfig.stega } : prevConfig.stega || defaultConfig.stega,\n      ...typeof config.stega == \"boolean\" ? { enabled: config.stega } : config.stega || {}\n    }\n  };\n  specifiedConfig.apiVersion || printNoApiVersionSpecifiedWarning();\n  const newConfig = {\n    ...defaultConfig,\n    ...specifiedConfig\n  }, projectBased = newConfig.useProjectHostname;\n  if (typeof Promise > \"u\") {\n    const helpUrl = generateHelpUrl(\"js-client-promise-polyfill\");\n    throw new Error(`No native Promise-implementation found, polyfill needed - see ${helpUrl}`);\n  }\n  if (projectBased && !newConfig.projectId)\n    throw new Error(\"Configuration must contain `projectId`\");\n  if (typeof newConfig.perspective < \"u\" && validateApiPerspective(newConfig.perspective), \"encodeSourceMap\" in newConfig)\n    throw new Error(\n      \"It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMap' is not supported in '@sanity/client'. Did you mean 'stega.enabled'?\"\n    );\n  if (\"encodeSourceMapAtPath\" in newConfig)\n    throw new Error(\n      \"It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMapAtPath' is not supported in '@sanity/client'. Did you mean 'stega.filter'?\"\n    );\n  if (typeof newConfig.stega.enabled != \"boolean\")\n    throw new Error(`stega.enabled must be a boolean, received ${newConfig.stega.enabled}`);\n  if (newConfig.stega.enabled && newConfig.stega.studioUrl === void 0)\n    throw new Error(\"stega.studioUrl must be defined when stega.enabled is true\");\n  if (newConfig.stega.enabled && typeof newConfig.stega.studioUrl != \"string\" && typeof newConfig.stega.studioUrl != \"function\")\n    throw new Error(\n      `stega.studioUrl must be a string or a function, received ${newConfig.stega.studioUrl}`\n    );\n  const isBrowser = typeof window < \"u\" && window.location && window.location.hostname, isLocalhost = isBrowser && isLocal(window.location.hostname);\n  isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== !0 ? printBrowserTokenWarning() : typeof newConfig.useCdn > \"u\" && printCdnWarning(), projectBased && projectId(newConfig.projectId), newConfig.dataset && dataset(newConfig.dataset), \"requestTagPrefix\" in newConfig && (newConfig.requestTagPrefix = newConfig.requestTagPrefix ? requestTag(newConfig.requestTagPrefix).replace(/\\.+$/, \"\") : void 0), newConfig.apiVersion = `${newConfig.apiVersion}`.replace(/^v/, \"\"), newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost, newConfig.useCdn === !0 && newConfig.withCredentials && printCdnAndWithCredentialsWarning(), newConfig.useCdn = newConfig.useCdn !== !1 && !newConfig.withCredentials, validateApiVersion(newConfig.apiVersion);\n  const hostParts = newConfig.apiHost.split(\"://\", 2), protocol = hostParts[0], host = hostParts[1], cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;\n  return newConfig.useProjectHostname ? (newConfig.url = `${protocol}://${newConfig.projectId}.${host}/v${newConfig.apiVersion}`, newConfig.cdnUrl = `${protocol}://${newConfig.projectId}.${cdnHost}/v${newConfig.apiVersion}`) : (newConfig.url = `${newConfig.apiHost}/v${newConfig.apiVersion}`, newConfig.cdnUrl = newConfig.url), newConfig;\n};\nfunction getSelection(sel) {\n  if (typeof sel == \"string\")\n    return { id: sel };\n  if (Array.isArray(sel))\n    return { query: \"*[_id in $ids]\", params: { ids: sel } };\n  if (typeof sel == \"object\" && sel !== null && \"query\" in sel && typeof sel.query == \"string\")\n    return \"params\" in sel && typeof sel.params == \"object\" && sel.params !== null ? { query: sel.query, params: sel.params } : { query: sel.query };\n  const selectionOpts = [\n    \"* Document ID (<docId>)\",\n    \"* Array of document IDs\",\n    \"* Object containing `query`\"\n  ].join(`\n`);\n  throw new Error(`Unknown selection - must be one of:\n\n${selectionOpts}`);\n}\nclass BasePatch {\n  selection;\n  operations;\n  constructor(selection, operations = {}) {\n    this.selection = selection, this.operations = operations;\n  }\n  /**\n   * Sets the given attributes to the document. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */\n  set(attrs) {\n    return this._assign(\"set\", attrs);\n  }\n  /**\n   * Sets the given attributes to the document if they are not currently set. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */\n  setIfMissing(attrs) {\n    return this._assign(\"setIfMissing\", attrs);\n  }\n  /**\n   * Performs a \"diff-match-patch\" operation on the string attributes provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to perform operation on. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"dmp\"\\}\n   */\n  diffMatchPatch(attrs) {\n    return validateObject(\"diffMatchPatch\", attrs), this._assign(\"diffMatchPatch\", attrs);\n  }\n  /**\n   * Unsets the attribute paths provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attribute paths to unset.\n   */\n  unset(attrs) {\n    if (!Array.isArray(attrs))\n      throw new Error(\"unset(attrs) takes an array of attributes to unset, non-array given\");\n    return this.operations = Object.assign({}, this.operations, { unset: attrs }), this;\n  }\n  /**\n   * Increment a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to increment, values representing the number to increment by.\n   */\n  inc(attrs) {\n    return this._assign(\"inc\", attrs);\n  }\n  /**\n   * Decrement a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to decrement, values representing the number to decrement by.\n   */\n  dec(attrs) {\n    return this._assign(\"dec\", attrs);\n  }\n  /**\n   * Provides methods for modifying arrays, by inserting, appending and replacing elements via a JSONPath expression.\n   *\n   * @param at - Location to insert at, relative to the given selector, or 'replace' the matched path\n   * @param selector - JSONPath expression, eg `comments[-1]` or `blocks[_key==\"abc123\"]`\n   * @param items - Array of items to insert/replace\n   */\n  insert(at, selector, items) {\n    return validateInsert(at, selector, items), this._assign(\"insert\", { [at]: selector, items });\n  }\n  /**\n   * Append the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to append to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to append to the array\n   */\n  append(selector, items) {\n    return this.insert(\"after\", `${selector}[-1]`, items);\n  }\n  /**\n   * Prepend the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to prepend to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to prepend to the array\n   */\n  prepend(selector, items) {\n    return this.insert(\"before\", `${selector}[0]`, items);\n  }\n  /**\n   * Change the contents of an array by removing existing elements and/or adding new elements.\n   *\n   * @param selector - Attribute or JSONPath expression for array\n   * @param start - Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.x\n   * @param deleteCount - An integer indicating the number of old array elements to remove.\n   * @param items - The elements to add to the array, beginning at the start index. If you don't specify any elements, splice() will only remove elements from the array.\n   */\n  splice(selector, start, deleteCount, items) {\n    const delAll = typeof deleteCount > \"u\" || deleteCount === -1, startIndex = start < 0 ? start - 1 : start, delCount = delAll ? -1 : Math.max(0, start + deleteCount), delRange = startIndex < 0 && delCount >= 0 ? \"\" : delCount, rangeSelector = `${selector}[${startIndex}:${delRange}]`;\n    return this.insert(\"replace\", rangeSelector, items || []);\n  }\n  /**\n   * Adds a revision clause, preventing the document from being patched if the `_rev` property does not match the given value\n   *\n   * @param rev - Revision to lock the patch to\n   */\n  ifRevisionId(rev) {\n    return this.operations.ifRevisionID = rev, this;\n  }\n  /**\n   * Return a plain JSON representation of the patch\n   */\n  serialize() {\n    return { ...getSelection(this.selection), ...this.operations };\n  }\n  /**\n   * Return a plain JSON representation of the patch\n   */\n  toJSON() {\n    return this.serialize();\n  }\n  /**\n   * Clears the patch of all operations\n   */\n  reset() {\n    return this.operations = {}, this;\n  }\n  _assign(op, props, merge = !0) {\n    return validateObject(op, props), this.operations = Object.assign({}, this.operations, {\n      [op]: Object.assign({}, merge && this.operations[op] || {}, props)\n    }), this;\n  }\n  _set(op, props) {\n    return this._assign(op, props, !1);\n  }\n}\nclass ObservablePatch extends BasePatch {\n  #client;\n  constructor(selection, operations, client) {\n    super(selection, operations), this.#client = client;\n  }\n  /**\n   * Clones the patch\n   */\n  clone() {\n    return new ObservablePatch(this.selection, { ...this.operations }, this.#client);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method\"\n      );\n    const returnFirst = typeof this.selection == \"string\", opts = Object.assign({ returnFirst, returnDocuments: !0 }, options);\n    return this.#client.mutate({ patch: this.serialize() }, opts);\n  }\n}\nclass Patch extends BasePatch {\n  #client;\n  constructor(selection, operations, client) {\n    super(selection, operations), this.#client = client;\n  }\n  /**\n   * Clones the patch\n   */\n  clone() {\n    return new Patch(this.selection, { ...this.operations }, this.#client);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method\"\n      );\n    const returnFirst = typeof this.selection == \"string\", opts = Object.assign({ returnFirst, returnDocuments: !0 }, options);\n    return this.#client.mutate({ patch: this.serialize() }, opts);\n  }\n}\nconst defaultMutateOptions = { returnDocuments: !1 };\nclass BaseTransaction {\n  operations;\n  trxId;\n  constructor(operations = [], transactionId) {\n    this.operations = operations, this.trxId = transactionId;\n  }\n  /**\n   * Creates a new Sanity document. If `_id` is provided and already exists, the mutation will fail. If no `_id` is given, one will automatically be generated by the database.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create. Requires a `_type` property.\n   */\n  create(doc) {\n    return validateObject(\"create\", doc), this._add({ create: doc });\n  }\n  /**\n   * Creates a new Sanity document. If a document with the same `_id` already exists, the create operation will be ignored.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create if it does not already exist. Requires `_id` and `_type` properties.\n   */\n  createIfNotExists(doc) {\n    const op = \"createIfNotExists\";\n    return validateObject(op, doc), requireDocumentId(op, doc), this._add({ [op]: doc });\n  }\n  /**\n   * Creates a new Sanity document, or replaces an existing one if the same `_id` is already used.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create or replace. Requires `_id` and `_type` properties.\n   */\n  createOrReplace(doc) {\n    const op = \"createOrReplace\";\n    return validateObject(op, doc), requireDocumentId(op, doc), this._add({ [op]: doc });\n  }\n  /**\n   * Deletes the document with the given document ID\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param documentId - Document ID to delete\n   */\n  delete(documentId) {\n    return validateDocumentId(\"delete\", documentId), this._add({ delete: { id: documentId } });\n  }\n  transactionId(id) {\n    return id ? (this.trxId = id, this) : this.trxId;\n  }\n  /**\n   * Return a plain JSON representation of the transaction\n   */\n  serialize() {\n    return [...this.operations];\n  }\n  /**\n   * Return a plain JSON representation of the transaction\n   */\n  toJSON() {\n    return this.serialize();\n  }\n  /**\n   * Clears the transaction of all operations\n   */\n  reset() {\n    return this.operations = [], this;\n  }\n  _add(mut) {\n    return this.operations.push(mut), this;\n  }\n}\nclass Transaction extends BaseTransaction {\n  #client;\n  constructor(operations, client, transactionId) {\n    super(operations, transactionId), this.#client = client;\n  }\n  /**\n   * Clones the transaction\n   */\n  clone() {\n    return new Transaction([...this.operations], this.#client, this.trxId);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method\"\n      );\n    return this.#client.mutate(\n      this.serialize(),\n      Object.assign({ transactionId: this.trxId }, defaultMutateOptions, options || {})\n    );\n  }\n  patch(patchOrDocumentId, patchOps) {\n    const isBuilder = typeof patchOps == \"function\";\n    if (typeof patchOrDocumentId != \"string\" && patchOrDocumentId instanceof Patch)\n      return this._add({ patch: patchOrDocumentId.serialize() });\n    if (isBuilder) {\n      const patch = patchOps(new Patch(patchOrDocumentId, {}, this.#client));\n      if (!(patch instanceof Patch))\n        throw new Error(\"function passed to `patch()` must return the patch\");\n      return this._add({ patch: patch.serialize() });\n    }\n    return this._add({ patch: { id: patchOrDocumentId, ...patchOps } });\n  }\n}\nclass ObservableTransaction extends BaseTransaction {\n  #client;\n  constructor(operations, client, transactionId) {\n    super(operations, transactionId), this.#client = client;\n  }\n  /**\n   * Clones the transaction\n   */\n  clone() {\n    return new ObservableTransaction([...this.operations], this.#client, this.trxId);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method\"\n      );\n    return this.#client.mutate(\n      this.serialize(),\n      Object.assign({ transactionId: this.trxId }, defaultMutateOptions, options || {})\n    );\n  }\n  patch(patchOrDocumentId, patchOps) {\n    const isBuilder = typeof patchOps == \"function\";\n    if (typeof patchOrDocumentId != \"string\" && patchOrDocumentId instanceof ObservablePatch)\n      return this._add({ patch: patchOrDocumentId.serialize() });\n    if (isBuilder) {\n      const patch = patchOps(new ObservablePatch(patchOrDocumentId, {}, this.#client));\n      if (!(patch instanceof ObservablePatch))\n        throw new Error(\"function passed to `patch()` must return the patch\");\n      return this._add({ patch: patch.serialize() });\n    }\n    return this._add({ patch: { id: patchOrDocumentId, ...patchOps } });\n  }\n}\nconst projectHeader = \"X-Sanity-Project-ID\";\nfunction requestOptions(config, overrides = {}) {\n  const headers = {}, token = overrides.token || config.token;\n  token && (headers.Authorization = `Bearer ${token}`), !overrides.useGlobalApi && !config.useProjectHostname && config.projectId && (headers[projectHeader] = config.projectId);\n  const withCredentials = !!(typeof overrides.withCredentials > \"u\" ? config.token || config.withCredentials : overrides.withCredentials), timeout = typeof overrides.timeout > \"u\" ? config.timeout : overrides.timeout;\n  return Object.assign({}, overrides, {\n    headers: Object.assign({}, headers, overrides.headers || {}),\n    timeout: typeof timeout > \"u\" ? 5 * 60 * 1e3 : timeout,\n    proxy: overrides.proxy || config.proxy,\n    json: !0,\n    withCredentials,\n    fetch: typeof overrides.fetch == \"object\" && typeof config.fetch == \"object\" ? { ...config.fetch, ...overrides.fetch } : overrides.fetch || config.fetch\n  });\n}\nconst encodeQueryString = ({\n  query,\n  params = {},\n  options = {}\n}) => {\n  const searchParams = new URLSearchParams(), { tag, includeMutations, returnQuery, ...opts } = options;\n  tag && searchParams.append(\"tag\", tag), searchParams.append(\"query\", query);\n  for (const [key, value] of Object.entries(params))\n    searchParams.append(`$${key}`, JSON.stringify(value));\n  for (const [key, value] of Object.entries(opts))\n    value && searchParams.append(key, `${value}`);\n  return returnQuery === !1 && searchParams.append(\"returnQuery\", \"false\"), includeMutations === !1 && searchParams.append(\"includeMutations\", \"false\"), `?${searchParams}`;\n}, excludeFalsey = (param, defValue) => param === !1 ? void 0 : typeof param > \"u\" ? defValue : param, getMutationQuery = (options = {}) => ({\n  dryRun: options.dryRun,\n  returnIds: !0,\n  returnDocuments: excludeFalsey(options.returnDocuments, !0),\n  visibility: options.visibility || \"sync\",\n  autoGenerateArrayKeys: options.autoGenerateArrayKeys,\n  skipCrossDatasetReferenceValidation: options.skipCrossDatasetReferenceValidation\n}), isResponse = (event) => event.type === \"response\", getBody = (event) => event.body, indexBy = (docs, attr) => docs.reduce((indexed, doc) => (indexed[attr(doc)] = doc, indexed), /* @__PURE__ */ Object.create(null)), getQuerySizeLimit = 11264;\nfunction _fetch(client, httpRequest, _stega, query, _params = {}, options = {}) {\n  const stega = \"stega\" in options ? {\n    ..._stega || {},\n    ...typeof options.stega == \"boolean\" ? { enabled: options.stega } : options.stega || {}\n  } : _stega, params = stega.enabled ? (0,_chunks_es_stegaClean_js__WEBPACK_IMPORTED_MODULE_3__.stegaClean)(_params) : _params, mapResponse = options.filterResponse === !1 ? (res) => res : (res) => res.result, { cache, next, ...opts } = {\n    // Opt out of setting a `signal` on an internal `fetch` if one isn't provided.\n    // This is necessary in React Server Components to avoid opting out of Request Memoization.\n    useAbortSignal: typeof options.signal < \"u\",\n    // Set `resultSourceMap' when stega is enabled, as it's required for encoding.\n    resultSourceMap: stega.enabled ? \"withKeyArraySelector\" : options.resultSourceMap,\n    ...options,\n    // Default to not returning the query, unless `filterResponse` is `false`,\n    // or `returnQuery` is explicitly set. `true` is the default in Content Lake, so skip if truthy\n    returnQuery: options.filterResponse === !1 && options.returnQuery !== !1\n  }, reqOpts = typeof cache < \"u\" || typeof next < \"u\" ? { ...opts, fetch: { cache, next } } : opts, $request = _dataRequest(client, httpRequest, \"query\", { query, params }, reqOpts);\n  return stega.enabled ? $request.pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.combineLatestWith)(\n      (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.from)(\n        __webpack_require__.e(/*! import() */ \"vendor-chunks/@sanity\").then(__webpack_require__.bind(__webpack_require__, /*! ./_chunks-es/stegaEncodeSourceMap.js */ \"(rsc)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\")).then(function(n) {\n          return n.stegaEncodeSourceMap$1;\n        }).then(\n          ({ stegaEncodeSourceMap }) => stegaEncodeSourceMap\n        )\n      )\n    ),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(\n      ([res, stegaEncodeSourceMap]) => {\n        const result = stegaEncodeSourceMap(res.result, res.resultSourceMap, stega);\n        return mapResponse({ ...res, result });\n      }\n    )\n  ) : $request.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(mapResponse));\n}\nfunction _getDocument(client, httpRequest, id, opts = {}) {\n  const options = {\n    uri: _getDataUrl(client, \"doc\", id),\n    json: !0,\n    tag: opts.tag,\n    signal: opts.signal\n  };\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((event) => event.body.documents && event.body.documents[0])\n  );\n}\nfunction _getDocuments(client, httpRequest, ids, opts = {}) {\n  const options = {\n    uri: _getDataUrl(client, \"doc\", ids.join(\",\")),\n    json: !0,\n    tag: opts.tag,\n    signal: opts.signal\n  };\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((event) => {\n      const indexed = indexBy(event.body.documents || [], (doc) => doc._id);\n      return ids.map((id) => indexed[id] || null);\n    })\n  );\n}\nfunction _createIfNotExists(client, httpRequest, doc, options) {\n  return requireDocumentId(\"createIfNotExists\", doc), _create(client, httpRequest, doc, \"createIfNotExists\", options);\n}\nfunction _createOrReplace(client, httpRequest, doc, options) {\n  return requireDocumentId(\"createOrReplace\", doc), _create(client, httpRequest, doc, \"createOrReplace\", options);\n}\nfunction _delete(client, httpRequest, selection, options) {\n  return _dataRequest(\n    client,\n    httpRequest,\n    \"mutate\",\n    { mutations: [{ delete: getSelection(selection) }] },\n    options\n  );\n}\nfunction _mutate(client, httpRequest, mutations, options) {\n  let mut;\n  mutations instanceof Patch || mutations instanceof ObservablePatch ? mut = { patch: mutations.serialize() } : mutations instanceof Transaction || mutations instanceof ObservableTransaction ? mut = mutations.serialize() : mut = mutations;\n  const muts = Array.isArray(mut) ? mut : [mut], transactionId = options && options.transactionId || void 0;\n  return _dataRequest(client, httpRequest, \"mutate\", { mutations: muts, transactionId }, options);\n}\nfunction _action(client, httpRequest, actions, options) {\n  const acts = Array.isArray(actions) ? actions : [actions], transactionId = options && options.transactionId || void 0, skipCrossDatasetReferenceValidation = options && options.skipCrossDatasetReferenceValidation || void 0, dryRun = options && options.dryRun || void 0;\n  return _dataRequest(\n    client,\n    httpRequest,\n    \"actions\",\n    { actions: acts, transactionId, skipCrossDatasetReferenceValidation, dryRun },\n    options\n  );\n}\nfunction _dataRequest(client, httpRequest, endpoint, body, options = {}) {\n  const isMutation = endpoint === \"mutate\", isAction = endpoint === \"actions\", isQuery = endpoint === \"query\", strQuery = isMutation || isAction ? \"\" : encodeQueryString(body), useGet = !isMutation && !isAction && strQuery.length < getQuerySizeLimit, stringQuery = useGet ? strQuery : \"\", returnFirst = options.returnFirst, { timeout, token, tag, headers, returnQuery, lastLiveEventId, cacheMode } = options, uri = _getDataUrl(client, endpoint, stringQuery), reqOptions = {\n    method: useGet ? \"GET\" : \"POST\",\n    uri,\n    json: !0,\n    body: useGet ? void 0 : body,\n    query: isMutation && getMutationQuery(options),\n    timeout,\n    headers,\n    token,\n    tag,\n    returnQuery,\n    perspective: options.perspective,\n    resultSourceMap: options.resultSourceMap,\n    lastLiveEventId: Array.isArray(lastLiveEventId) ? lastLiveEventId[0] : lastLiveEventId,\n    cacheMode,\n    canUseCdn: isQuery,\n    signal: options.signal,\n    fetch: options.fetch,\n    useAbortSignal: options.useAbortSignal,\n    useCdn: options.useCdn\n  };\n  return _requestObservable(client, httpRequest, reqOptions).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(getBody),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((res) => {\n      if (!isMutation)\n        return res;\n      const results = res.results || [];\n      if (options.returnDocuments)\n        return returnFirst ? results[0] && results[0].document : results.map((mut) => mut.document);\n      const key = returnFirst ? \"documentId\" : \"documentIds\", ids = returnFirst ? results[0] && results[0].id : results.map((mut) => mut.id);\n      return {\n        transactionId: res.transactionId,\n        results,\n        [key]: ids\n      };\n    })\n  );\n}\nfunction _create(client, httpRequest, doc, op, options = {}) {\n  const mutation = { [op]: doc }, opts = Object.assign({ returnFirst: !0, returnDocuments: !0 }, options);\n  return _dataRequest(client, httpRequest, \"mutate\", { mutations: [mutation] }, opts);\n}\nfunction _requestObservable(client, httpRequest, options) {\n  const uri = options.url || options.uri, config = client.config(), canUseCdn = typeof options.canUseCdn > \"u\" ? [\"GET\", \"HEAD\"].indexOf(options.method || \"GET\") >= 0 && uri.indexOf(\"/data/\") === 0 : options.canUseCdn;\n  let useCdn = (options.useCdn ?? config.useCdn) && canUseCdn;\n  const tag = options.tag && config.requestTagPrefix ? [config.requestTagPrefix, options.tag].join(\".\") : options.tag || config.requestTagPrefix;\n  if (tag && options.tag !== null && (options.query = { tag: requestTag(tag), ...options.query }), [\"GET\", \"HEAD\", \"POST\"].indexOf(options.method || \"GET\") >= 0 && uri.indexOf(\"/data/query/\") === 0) {\n    const resultSourceMap = options.resultSourceMap ?? config.resultSourceMap;\n    resultSourceMap !== void 0 && resultSourceMap !== !1 && (options.query = { resultSourceMap, ...options.query });\n    const perspectiveOption = options.perspective || config.perspective;\n    typeof perspectiveOption < \"u\" && (validateApiPerspective(perspectiveOption), options.query = {\n      perspective: Array.isArray(perspectiveOption) ? perspectiveOption.join(\",\") : perspectiveOption,\n      ...options.query\n    }, perspectiveOption === \"previewDrafts\" && useCdn && (useCdn = !1, printCdnPreviewDraftsWarning())), options.lastLiveEventId && (options.query = { ...options.query, lastLiveEventId: options.lastLiveEventId }), options.returnQuery === !1 && (options.query = { returnQuery: \"false\", ...options.query }), useCdn && options.cacheMode == \"noStale\" && (options.query = { cacheMode: \"noStale\", ...options.query });\n  }\n  const reqOptions = requestOptions(\n    config,\n    Object.assign({}, options, {\n      url: _getUrl(client, uri, useCdn)\n    })\n  ), request = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable(\n    (subscriber) => httpRequest(reqOptions, config.requester).subscribe(subscriber)\n  );\n  return options.signal ? request.pipe(_withAbortSignal(options.signal)) : request;\n}\nfunction _request(client, httpRequest, options) {\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)((event) => event.type === \"response\"),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((event) => event.body)\n  );\n}\nfunction _getDataUrl(client, operation, path) {\n  const config = client.config(), catalog = hasDataset(config), baseUri = `/${operation}/${catalog}`;\n  return `/data${path ? `${baseUri}/${path}` : baseUri}`.replace(/\\/($|\\?)/, \"$1\");\n}\nfunction _getUrl(client, uri, canUseCdn = !1) {\n  const { url, cdnUrl } = client.config();\n  return `${canUseCdn ? cdnUrl : url}/${uri.replace(/^\\//, \"\")}`;\n}\nfunction _withAbortSignal(signal) {\n  return (input) => new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => {\n    const abort = () => observer.error(_createAbortError(signal));\n    if (signal && signal.aborted) {\n      abort();\n      return;\n    }\n    const subscription = input.subscribe(observer);\n    return signal.addEventListener(\"abort\", abort), () => {\n      signal.removeEventListener(\"abort\", abort), subscription.unsubscribe();\n    };\n  });\n}\nconst isDomExceptionSupported = !!globalThis.DOMException;\nfunction _createAbortError(signal) {\n  if (isDomExceptionSupported)\n    return new DOMException(signal?.reason ?? \"The operation was aborted.\", \"AbortError\");\n  const error = new Error(signal?.reason ?? \"The operation was aborted.\");\n  return error.name = \"AbortError\", error;\n}\nclass ObservableAssetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  upload(assetType, body, options) {\n    return _upload(this.#client, this.#httpRequest, assetType, body, options);\n  }\n}\nclass AssetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  upload(assetType, body, options) {\n    const observable2 = _upload(this.#client, this.#httpRequest, assetType, body, options);\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      observable2.pipe(\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)((event) => event.type === \"response\"),\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(\n          (event) => event.body.document\n        )\n      )\n    );\n  }\n}\nfunction _upload(client, httpRequest, assetType, body, opts = {}) {\n  validateAssetType(assetType);\n  let meta = opts.extract || void 0;\n  meta && !meta.length && (meta = [\"none\"]);\n  const dataset2 = hasDataset(client.config()), assetEndpoint = assetType === \"image\" ? \"images\" : \"files\", options = optionsFromFile(opts, body), { tag, label, title, description, creditLine, filename, source } = options, query = {\n    label,\n    title,\n    description,\n    filename,\n    meta,\n    creditLine\n  };\n  return source && (query.sourceId = source.id, query.sourceName = source.name, query.sourceUrl = source.url), _requestObservable(client, httpRequest, {\n    tag,\n    method: \"POST\",\n    timeout: options.timeout || 0,\n    uri: `/assets/${assetEndpoint}/${dataset2}`,\n    headers: options.contentType ? { \"Content-Type\": options.contentType } : {},\n    query,\n    body\n  });\n}\nfunction optionsFromFile(opts, file) {\n  return typeof File > \"u\" || !(file instanceof File) ? opts : Object.assign(\n    {\n      filename: opts.preserveFilename === !1 ? void 0 : file.name,\n      contentType: file.type\n    },\n    opts\n  );\n}\nvar defaults = (obj, defaults2) => Object.keys(defaults2).concat(Object.keys(obj)).reduce((target, prop) => (target[prop] = typeof obj[prop] > \"u\" ? defaults2[prop] : obj[prop], target), {});\nconst pick = (obj, props) => props.reduce((selection, prop) => (typeof obj[prop] > \"u\" || (selection[prop] = obj[prop]), selection), {}), MAX_URL_LENGTH = 14800, possibleOptions = [\n  \"includePreviousRevision\",\n  \"includeResult\",\n  \"includeMutations\",\n  \"visibility\",\n  \"effectFormat\",\n  \"tag\"\n], defaultOptions = {\n  includeResult: !0\n};\nfunction _listen(query, params, opts = {}) {\n  const { url, token, withCredentials, requestTagPrefix } = this.config(), tag = opts.tag && requestTagPrefix ? [requestTagPrefix, opts.tag].join(\".\") : opts.tag, options = { ...defaults(opts, defaultOptions), tag }, listenOpts = pick(options, possibleOptions), qs = encodeQueryString({ query, params, options: { tag, ...listenOpts } }), uri = `${url}${_getDataUrl(this, \"listen\", qs)}`;\n  if (uri.length > MAX_URL_LENGTH)\n    return new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => observer.error(new Error(\"Query too large for listener\")));\n  const listenFor = options.events ? options.events : [\"mutation\"], shouldEmitReconnect = listenFor.indexOf(\"reconnect\") !== -1, esOptions = {};\n  return (token || withCredentials) && (esOptions.withCredentials = !0), token && (esOptions.headers = {\n    Authorization: `Bearer ${token}`\n  }), new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => {\n    let es, reconnectTimer, stopped = !1, unsubscribed = !1;\n    open();\n    function onError() {\n      stopped || (emitReconnect(), !stopped && es.readyState === es.CLOSED && (unsubscribe(), clearTimeout(reconnectTimer), reconnectTimer = setTimeout(open, 100)));\n    }\n    function onChannelError(err) {\n      observer.error(cooerceError(err));\n    }\n    function onMessage(evt) {\n      const event = parseEvent$1(evt);\n      return event instanceof Error ? observer.error(event) : observer.next(event);\n    }\n    function onDisconnect() {\n      stopped = !0, unsubscribe(), observer.complete();\n    }\n    function unsubscribe() {\n      es && (es.removeEventListener(\"error\", onError), es.removeEventListener(\"channelError\", onChannelError), es.removeEventListener(\"disconnect\", onDisconnect), listenFor.forEach((type) => es.removeEventListener(type, onMessage)), es.close());\n    }\n    function emitReconnect() {\n      shouldEmitReconnect && observer.next({ type: \"reconnect\" });\n    }\n    async function getEventSource() {\n      const { default: EventSource2 } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@sanity\"), __webpack_require__.e(\"vendor-chunks/eventsource\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! @sanity/eventsource */ \"(rsc)/./node_modules/@sanity/eventsource/node.js\", 19));\n      if (unsubscribed)\n        return;\n      const evs = new EventSource2(uri, esOptions);\n      return evs.addEventListener(\"error\", onError), evs.addEventListener(\"channelError\", onChannelError), evs.addEventListener(\"disconnect\", onDisconnect), listenFor.forEach((type) => evs.addEventListener(type, onMessage)), evs;\n    }\n    function open() {\n      getEventSource().then((eventSource) => {\n        eventSource && (es = eventSource, unsubscribed && unsubscribe());\n      }).catch((reason) => {\n        observer.error(reason), stop();\n      });\n    }\n    function stop() {\n      stopped = !0, unsubscribe(), unsubscribed = !0;\n    }\n    return stop;\n  });\n}\nfunction parseEvent$1(event) {\n  try {\n    const data = event.data && JSON.parse(event.data) || {};\n    return Object.assign({ type: event.type }, data);\n  } catch (err) {\n    return err;\n  }\n}\nfunction cooerceError(err) {\n  if (err instanceof Error)\n    return err;\n  const evt = parseEvent$1(err);\n  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));\n}\nfunction extractErrorMessage(err) {\n  return err.error ? err.error.description ? err.error.description : typeof err.error == \"string\" ? err.error : JSON.stringify(err.error, null, 2) : err.message || \"Unknown listener error\";\n}\nconst requiredApiVersion = \"2021-03-26\";\nclass LiveClient {\n  #client;\n  constructor(client) {\n    this.#client = client;\n  }\n  /**\n   * Requires `apiVersion` to be `2021-03-26` or later.\n   */\n  events({\n    includeDrafts = !1,\n    tag: _tag\n  } = {}) {\n    const {\n      projectId: projectId2,\n      apiVersion: _apiVersion,\n      token,\n      withCredentials,\n      requestTagPrefix\n    } = this.#client.config(), apiVersion = _apiVersion.replace(/^v/, \"\");\n    if (apiVersion !== \"X\" && apiVersion < requiredApiVersion)\n      throw new Error(\n        `The live events API requires API version ${requiredApiVersion} or later. The current API version is ${apiVersion}. Please update your API version to use this feature.`\n      );\n    if (includeDrafts && !token && !withCredentials)\n      throw new Error(\n        \"The live events API requires a token or withCredentials when 'includeDrafts: true'. Please update your client configuration. The token should have the lowest possible access role.\"\n      );\n    if (includeDrafts && apiVersion !== \"X\")\n      throw new Error(\n        \"The live events API requires API version X when 'includeDrafts: true'. This API is experimental and may change or even be removed.\"\n      );\n    const path = _getDataUrl(this.#client, \"live/events\"), url = new URL(this.#client.getUrl(path, !1)), tag = _tag && requestTagPrefix ? [requestTagPrefix, _tag].join(\".\") : _tag;\n    tag && url.searchParams.set(\"tag\", tag), includeDrafts && url.searchParams.set(\"includeDrafts\", \"true\");\n    const listenFor = [\"restart\", \"message\", \"welcome\", \"reconnect\"], esOptions = {};\n    return includeDrafts && token && (esOptions.headers = {\n      Authorization: `Bearer ${token}`\n    }), includeDrafts && withCredentials && (esOptions.withCredentials = !0), new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => {\n      let es, reconnectTimer, stopped = !1, unsubscribed = !1;\n      open();\n      function onError(evt) {\n        if (!stopped) {\n          if (\"data\" in evt) {\n            const event = parseEvent(evt);\n            observer.error(new Error(event.message, { cause: event }));\n          }\n          es.readyState === es.CLOSED && (unsubscribe(), clearTimeout(reconnectTimer), reconnectTimer = setTimeout(open, 100));\n        }\n      }\n      function onMessage(evt) {\n        const event = parseEvent(evt);\n        return event instanceof Error ? observer.error(event) : observer.next(event);\n      }\n      function unsubscribe() {\n        if (es) {\n          es.removeEventListener(\"error\", onError);\n          for (const type of listenFor)\n            es.removeEventListener(type, onMessage);\n          es.close();\n        }\n      }\n      async function getEventSource() {\n        const EventSourceImplementation = typeof EventSource > \"u\" || esOptions.headers || esOptions.withCredentials ? (await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@sanity\"), __webpack_require__.e(\"vendor-chunks/eventsource\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! @sanity/eventsource */ \"(rsc)/./node_modules/@sanity/eventsource/node.js\", 19))).default : EventSource;\n        if (unsubscribed)\n          return;\n        try {\n          if (await fetch(url, {\n            method: \"OPTIONS\",\n            mode: \"cors\",\n            credentials: esOptions.withCredentials ? \"include\" : \"omit\",\n            headers: esOptions.headers\n          }), unsubscribed)\n            return;\n        } catch {\n          throw new CorsOriginError({ projectId: projectId2 });\n        }\n        const evs = new EventSourceImplementation(url.toString(), esOptions);\n        evs.addEventListener(\"error\", onError);\n        for (const type of listenFor)\n          evs.addEventListener(type, onMessage);\n        return evs;\n      }\n      function open() {\n        getEventSource().then((eventSource) => {\n          eventSource && (es = eventSource, unsubscribed && unsubscribe());\n        }).catch((reason) => {\n          observer.error(reason), stop();\n        });\n      }\n      function stop() {\n        stopped = !0, unsubscribe(), unsubscribed = !0;\n      }\n      return stop;\n    });\n  }\n}\nfunction parseEvent(event) {\n  try {\n    const data = event.data && JSON.parse(event.data) || {};\n    return { type: event.type, id: event.lastEventId, ...data };\n  } catch (err) {\n    return err;\n  }\n}\nclass ObservableDatasetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */\n  create(name, options) {\n    return _modify(this.#client, this.#httpRequest, \"PUT\", name, options);\n  }\n  /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */\n  edit(name, options) {\n    return _modify(this.#client, this.#httpRequest, \"PATCH\", name, options);\n  }\n  /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */\n  delete(name) {\n    return _modify(this.#client, this.#httpRequest, \"DELETE\", name);\n  }\n  /**\n   * Fetch a list of datasets for the configured project\n   */\n  list() {\n    return _request(this.#client, this.#httpRequest, {\n      uri: \"/datasets\",\n      tag: null\n    });\n  }\n}\nclass DatasetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */\n  create(name, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _modify(this.#client, this.#httpRequest, \"PUT\", name, options)\n    );\n  }\n  /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */\n  edit(name, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _modify(this.#client, this.#httpRequest, \"PATCH\", name, options)\n    );\n  }\n  /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */\n  delete(name) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_modify(this.#client, this.#httpRequest, \"DELETE\", name));\n  }\n  /**\n   * Fetch a list of datasets for the configured project\n   */\n  list() {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _request(this.#client, this.#httpRequest, { uri: \"/datasets\", tag: null })\n    );\n  }\n}\nfunction _modify(client, httpRequest, method, name, options) {\n  return dataset(name), _request(client, httpRequest, {\n    method,\n    uri: `/datasets/${name}`,\n    body: options,\n    tag: null\n  });\n}\nclass ObservableProjectsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  list(options) {\n    const uri = options?.includeMembers === !1 ? \"/projects?includeMembers=false\" : \"/projects\";\n    return _request(this.#client, this.#httpRequest, { uri });\n  }\n  /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */\n  getById(projectId2) {\n    return _request(this.#client, this.#httpRequest, { uri: `/projects/${projectId2}` });\n  }\n}\nclass ProjectsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  list(options) {\n    const uri = options?.includeMembers === !1 ? \"/projects?includeMembers=false\" : \"/projects\";\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_request(this.#client, this.#httpRequest, { uri }));\n  }\n  /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */\n  getById(projectId2) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _request(this.#client, this.#httpRequest, { uri: `/projects/${projectId2}` })\n    );\n  }\n}\nclass ObservableUsersClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */\n  getById(id) {\n    return _request(\n      this.#client,\n      this.#httpRequest,\n      { uri: `/users/${id}` }\n    );\n  }\n}\nclass UsersClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */\n  getById(id) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _request(this.#client, this.#httpRequest, {\n        uri: `/users/${id}`\n      })\n    );\n  }\n}\nclass ObservableSanityClient {\n  assets;\n  datasets;\n  live;\n  projects;\n  users;\n  /**\n   * Private properties\n   */\n  #clientConfig;\n  #httpRequest;\n  /**\n   * Instance properties\n   */\n  listen = _listen;\n  constructor(httpRequest, config = defaultConfig) {\n    this.config(config), this.#httpRequest = httpRequest, this.assets = new ObservableAssetsClient(this, this.#httpRequest), this.datasets = new ObservableDatasetsClient(this, this.#httpRequest), this.live = new LiveClient(this), this.projects = new ObservableProjectsClient(this, this.#httpRequest), this.users = new ObservableUsersClient(this, this.#httpRequest);\n  }\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone() {\n    return new ObservableSanityClient(this.#httpRequest, this.config());\n  }\n  config(newConfig) {\n    if (newConfig === void 0)\n      return { ...this.#clientConfig };\n    if (this.#clientConfig && this.#clientConfig.allowReconfigure === !1)\n      throw new Error(\n        \"Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client\"\n      );\n    return this.#clientConfig = initConfig(newConfig, this.#clientConfig || {}), this;\n  }\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig) {\n    const thisConfig = this.config();\n    return new ObservableSanityClient(this.#httpRequest, {\n      ...thisConfig,\n      ...newConfig,\n      stega: {\n        ...thisConfig.stega || {},\n        ...typeof newConfig?.stega == \"boolean\" ? { enabled: newConfig.stega } : newConfig?.stega || {}\n      }\n    });\n  }\n  fetch(query, params, options) {\n    return _fetch(\n      this,\n      this.#httpRequest,\n      this.#clientConfig.stega,\n      query,\n      params,\n      options\n    );\n  }\n  /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */\n  getDocument(id, options) {\n    return _getDocument(this, this.#httpRequest, id, options);\n  }\n  /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */\n  getDocuments(ids, options) {\n    return _getDocuments(this, this.#httpRequest, ids, options);\n  }\n  create(document, options) {\n    return _create(this, this.#httpRequest, document, \"create\", options);\n  }\n  createIfNotExists(document, options) {\n    return _createIfNotExists(this, this.#httpRequest, document, options);\n  }\n  createOrReplace(document, options) {\n    return _createOrReplace(this, this.#httpRequest, document, options);\n  }\n  delete(selection, options) {\n    return _delete(this, this.#httpRequest, selection, options);\n  }\n  mutate(operations, options) {\n    return _mutate(this, this.#httpRequest, operations, options);\n  }\n  /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   * @returns Patch instance - call `.commit()` to perform the operations defined\n   */\n  patch(selection, operations) {\n    return new ObservablePatch(selection, operations, this);\n  }\n  /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */\n  transaction(operations) {\n    return new ObservableTransaction(operations, this);\n  }\n  /**\n   * Perform action operations against the configured dataset\n   *\n   * @param operations - Action operation(s) to execute\n   * @param options - Action options\n   */\n  action(operations, options) {\n    return _action(this, this.#httpRequest, operations, options);\n  }\n  /**\n   * Perform an HTTP request against the Sanity API\n   *\n   * @param options - Request options\n   */\n  request(options) {\n    return _request(this, this.#httpRequest, options);\n  }\n  /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */\n  getUrl(uri, canUseCdn) {\n    return _getUrl(this, uri, canUseCdn);\n  }\n  /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */\n  getDataUrl(operation, path) {\n    return _getDataUrl(this, operation, path);\n  }\n}\nclass SanityClient {\n  assets;\n  datasets;\n  live;\n  projects;\n  users;\n  /**\n   * Observable version of the Sanity client, with the same configuration as the promise-based one\n   */\n  observable;\n  /**\n   * Private properties\n   */\n  #clientConfig;\n  #httpRequest;\n  /**\n   * Instance properties\n   */\n  listen = _listen;\n  constructor(httpRequest, config = defaultConfig) {\n    this.config(config), this.#httpRequest = httpRequest, this.assets = new AssetsClient(this, this.#httpRequest), this.datasets = new DatasetsClient(this, this.#httpRequest), this.live = new LiveClient(this), this.projects = new ProjectsClient(this, this.#httpRequest), this.users = new UsersClient(this, this.#httpRequest), this.observable = new ObservableSanityClient(httpRequest, config);\n  }\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone() {\n    return new SanityClient(this.#httpRequest, this.config());\n  }\n  config(newConfig) {\n    if (newConfig === void 0)\n      return { ...this.#clientConfig };\n    if (this.#clientConfig && this.#clientConfig.allowReconfigure === !1)\n      throw new Error(\n        \"Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client\"\n      );\n    return this.observable && this.observable.config(newConfig), this.#clientConfig = initConfig(newConfig, this.#clientConfig || {}), this;\n  }\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig) {\n    const thisConfig = this.config();\n    return new SanityClient(this.#httpRequest, {\n      ...thisConfig,\n      ...newConfig,\n      stega: {\n        ...thisConfig.stega || {},\n        ...typeof newConfig?.stega == \"boolean\" ? { enabled: newConfig.stega } : newConfig?.stega || {}\n      }\n    });\n  }\n  fetch(query, params, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _fetch(\n        this,\n        this.#httpRequest,\n        this.#clientConfig.stega,\n        query,\n        params,\n        options\n      )\n    );\n  }\n  /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */\n  getDocument(id, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_getDocument(this, this.#httpRequest, id, options));\n  }\n  /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */\n  getDocuments(ids, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_getDocuments(this, this.#httpRequest, ids, options));\n  }\n  create(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _create(this, this.#httpRequest, document, \"create\", options)\n    );\n  }\n  createIfNotExists(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _createIfNotExists(this, this.#httpRequest, document, options)\n    );\n  }\n  createOrReplace(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _createOrReplace(this, this.#httpRequest, document, options)\n    );\n  }\n  delete(selection, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_delete(this, this.#httpRequest, selection, options));\n  }\n  mutate(operations, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_mutate(this, this.#httpRequest, operations, options));\n  }\n  /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   * @returns Patch instance - call `.commit()` to perform the operations defined\n   */\n  patch(documentId, operations) {\n    return new Patch(documentId, operations, this);\n  }\n  /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */\n  transaction(operations) {\n    return new Transaction(operations, this);\n  }\n  /**\n   * Perform action operations against the configured dataset\n   * Returns a promise that resolves to the transaction result\n   *\n   * @param operations - Action operation(s) to execute\n   * @param options - Action options\n   */\n  action(operations, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_action(this, this.#httpRequest, operations, options));\n  }\n  /**\n   * Perform a request against the Sanity API\n   * NOTE: Only use this for Sanity API endpoints, not for your own APIs!\n   *\n   * @param options - Request options\n   * @returns Promise resolving to the response body\n   */\n  request(options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_request(this, this.#httpRequest, options));\n  }\n  /**\n   * Perform an HTTP request a `/data` sub-endpoint\n   * NOTE: Considered internal, thus marked as deprecated. Use `request` instead.\n   *\n   * @deprecated - Use `request()` or your own HTTP library instead\n   * @param endpoint - Endpoint to hit (mutate, query etc)\n   * @param body - Request body\n   * @param options - Request options\n   * @internal\n   */\n  dataRequest(endpoint, body, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_dataRequest(this, this.#httpRequest, endpoint, body, options));\n  }\n  /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */\n  getUrl(uri, canUseCdn) {\n    return _getUrl(this, uri, canUseCdn);\n  }\n  /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */\n  getDataUrl(operation, path) {\n    return _getDataUrl(this, operation, path);\n  }\n}\nfunction defineCreateClientExports(envMiddleware2, ClassConstructor) {\n  const defaultRequester = defineHttpRequest(envMiddleware2);\n  return { requester: defaultRequester, createClient: (config) => new ClassConstructor(\n    (options, requester2) => (requester2 || defaultRequester)({\n      maxRedirects: 0,\n      maxRetries: config.maxRetries,\n      retryDelay: config.retryDelay,\n      ...options\n    }),\n    config\n  ) };\n}\nfunction defineDeprecatedCreateClient(createClient2) {\n  return function(config) {\n    return printNoDefaultExport(), createClient2(config);\n  };\n}\nvar envMiddleware = [];\nconst exp = defineCreateClientExports(envMiddleware, SanityClient), requester = exp.requester, createClient = exp.createClient, deprecatedCreateClient = defineDeprecatedCreateClient(createClient);\n\n//# sourceMappingURL=index.browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9pbmRleC5icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNlO0FBQzZDO0FBQ3BDO0FBQ0M7QUFDUTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVksSUFBSSxhQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixLQUFLO0FBQ0w7QUFDQSxTQUFTLHFCQUFxQiwyQkFBMkIsdUJBQXVCLEVBQUUsU0FBUztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrQkFBa0I7QUFDbEUsWUFBWSxXQUFXLGNBQWMsU0FBUyxtQkFBbUIsZUFBZSxFQUFFLGNBQWM7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0EsNERBQTRELFdBQVc7QUFDdkU7QUFDQSxjQUFjLFNBQVM7QUFDdkIsaU5BQWlOLElBQUk7QUFDck4sTUFBTTtBQUNOLDhIQUE4SCxJQUFJO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkNBQUs7QUFDZCxJQUFJLHdEQUFLLEdBQUcsYUFBYTtBQUN6QjtBQUNBO0FBQ0EsSUFBSSw4REFBVztBQUNmLElBQUksK0RBQVk7QUFDaEIsSUFBSSwyREFBUTtBQUNaO0FBQ0EsSUFBSSw2REFBVSxH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QTtBQUNBO0FBQ0EsV0FBVyxtREFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1EQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFtQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3ljX2RpcmVjdG9yeS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L2luZGV4LmJyb3dzZXIuanM/NWYwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRJdCB9IGZyb20gXCJnZXQtaXRcIjtcbmltcG9ydCB7IGFkYXB0ZXIsIGVudmlyb25tZW50IH0gZnJvbSBcImdldC1pdFwiO1xuaW1wb3J0IHsgcmV0cnksIGpzb25SZXF1ZXN0LCBqc29uUmVzcG9uc2UsIHByb2dyZXNzLCBvYnNlcnZhYmxlIH0gZnJvbSBcImdldC1pdC9taWRkbGV3YXJlXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBmcm9tLCBsYXN0VmFsdWVGcm9tIH0gZnJvbSBcInJ4anNcIjtcbmltcG9ydCB7IHN0ZWdhQ2xlYW4gfSBmcm9tIFwiLi9fY2h1bmtzLWVzL3N0ZWdhQ2xlYW4uanNcIjtcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3RXaXRoLCBtYXAsIGZpbHRlciB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xuY2xhc3MgQ2xpZW50RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHJlc3BvbnNlO1xuICBzdGF0dXNDb2RlID0gNDAwO1xuICByZXNwb25zZUJvZHk7XG4gIGRldGFpbHM7XG4gIGNvbnN0cnVjdG9yKHJlcykge1xuICAgIGNvbnN0IHByb3BzID0gZXh0cmFjdEVycm9yUHJvcHMocmVzKTtcbiAgICBzdXBlcihwcm9wcy5tZXNzYWdlKSwgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wcyk7XG4gIH1cbn1cbmNsYXNzIFNlcnZlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZXNwb25zZTtcbiAgc3RhdHVzQ29kZSA9IDUwMDtcbiAgcmVzcG9uc2VCb2R5O1xuICBkZXRhaWxzO1xuICBjb25zdHJ1Y3RvcihyZXMpIHtcbiAgICBjb25zdCBwcm9wcyA9IGV4dHJhY3RFcnJvclByb3BzKHJlcyk7XG4gICAgc3VwZXIocHJvcHMubWVzc2FnZSksIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcHMpO1xuICB9XG59XG5mdW5jdGlvbiBleHRyYWN0RXJyb3JQcm9wcyhyZXMpIHtcbiAgY29uc3QgYm9keSA9IHJlcy5ib2R5LCBwcm9wcyA9IHtcbiAgICByZXNwb25zZTogcmVzLFxuICAgIHN0YXR1c0NvZGU6IHJlcy5zdGF0dXNDb2RlLFxuICAgIHJlc3BvbnNlQm9keTogc3RyaW5naWZ5Qm9keShib2R5LCByZXMpLFxuICAgIG1lc3NhZ2U6IFwiXCIsXG4gICAgZGV0YWlsczogdm9pZCAwXG4gIH07XG4gIGlmIChib2R5LmVycm9yICYmIGJvZHkubWVzc2FnZSlcbiAgICByZXR1cm4gcHJvcHMubWVzc2FnZSA9IGAke2JvZHkuZXJyb3J9IC0gJHtib2R5Lm1lc3NhZ2V9YCwgcHJvcHM7XG4gIGlmIChpc011dGF0aW9uRXJyb3IoYm9keSkgfHwgaXNBY3Rpb25FcnJvcihib2R5KSkge1xuICAgIGNvbnN0IGFsbEl0ZW1zID0gYm9keS5lcnJvci5pdGVtcyB8fCBbXSwgaXRlbXMgPSBhbGxJdGVtcy5zbGljZSgwLCA1KS5tYXAoKGl0ZW0pID0+IGl0ZW0uZXJyb3I/LmRlc2NyaXB0aW9uKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgbGV0IGl0ZW1zU3RyID0gaXRlbXMubGVuZ3RoID8gYDpcbi0gJHtpdGVtcy5qb2luKGBcbi0gYCl9YCA6IFwiXCI7XG4gICAgcmV0dXJuIGFsbEl0ZW1zLmxlbmd0aCA+IDUgJiYgKGl0ZW1zU3RyICs9IGBcbi4uLmFuZCAke2FsbEl0ZW1zLmxlbmd0aCAtIDV9IG1vcmVgKSwgcHJvcHMubWVzc2FnZSA9IGAke2JvZHkuZXJyb3IuZGVzY3JpcHRpb259JHtpdGVtc1N0cn1gLCBwcm9wcy5kZXRhaWxzID0gYm9keS5lcnJvciwgcHJvcHM7XG4gIH1cbiAgcmV0dXJuIGJvZHkuZXJyb3IgJiYgYm9keS5lcnJvci5kZXNjcmlwdGlvbiA/IChwcm9wcy5tZXNzYWdlID0gYm9keS5lcnJvci5kZXNjcmlwdGlvbiwgcHJvcHMuZGV0YWlscyA9IGJvZHkuZXJyb3IsIHByb3BzKSA6IChwcm9wcy5tZXNzYWdlID0gYm9keS5lcnJvciB8fCBib2R5Lm1lc3NhZ2UgfHwgaHR0cEVycm9yTWVzc2FnZShyZXMpLCBwcm9wcyk7XG59XG5mdW5jdGlvbiBpc011dGF0aW9uRXJyb3IoYm9keSkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChib2R5KSAmJiBpc1BsYWluT2JqZWN0KGJvZHkuZXJyb3IpICYmIGJvZHkuZXJyb3IudHlwZSA9PT0gXCJtdXRhdGlvbkVycm9yXCIgJiYgdHlwZW9mIGJvZHkuZXJyb3IuZGVzY3JpcHRpb24gPT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzQWN0aW9uRXJyb3IoYm9keSkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChib2R5KSAmJiBpc1BsYWluT2JqZWN0KGJvZHkuZXJyb3IpICYmIGJvZHkuZXJyb3IudHlwZSA9PT0gXCJhY3Rpb25FcnJvclwiICYmIHR5cGVvZiBib2R5LmVycm9yLmRlc2NyaXB0aW9uID09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PSBcIm9iamVjdFwiICYmIG9iaiAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShvYmopO1xufVxuZnVuY3Rpb24gaHR0cEVycm9yTWVzc2FnZShyZXMpIHtcbiAgY29uc3Qgc3RhdHVzTWVzc2FnZSA9IHJlcy5zdGF0dXNNZXNzYWdlID8gYCAke3Jlcy5zdGF0dXNNZXNzYWdlfWAgOiBcIlwiO1xuICByZXR1cm4gYCR7cmVzLm1ldGhvZH0tcmVxdWVzdCB0byAke3Jlcy51cmx9IHJlc3VsdGVkIGluIEhUVFAgJHtyZXMuc3RhdHVzQ29kZX0ke3N0YXR1c01lc3NhZ2V9YDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUJvZHkoYm9keSwgcmVzKSB7XG4gIHJldHVybiAocmVzLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSAhPT0gLTEgPyBKU09OLnN0cmluZ2lmeShib2R5LCBudWxsLCAyKSA6IGJvZHk7XG59XG5jbGFzcyBDb3JzT3JpZ2luRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHByb2plY3RJZDtcbiAgYWRkT3JpZ2luVXJsO1xuICBjb25zdHJ1Y3Rvcih7IHByb2plY3RJZDogcHJvamVjdElkMiB9KSB7XG4gICAgc3VwZXIoXCJDb3JzT3JpZ2luRXJyb3JcIiksIHRoaXMubmFtZSA9IFwiQ29yc09yaWdpbkVycm9yXCIsIHRoaXMucHJvamVjdElkID0gcHJvamVjdElkMjtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGBodHRwczovL3Nhbml0eS5pby9tYW5hZ2UvcHJvamVjdC8ke3Byb2plY3RJZDJ9L2FwaWApO1xuICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPCBcInVcIikge1xuICAgICAgY29uc3QgeyBvcmlnaW4gfSA9IGxvY2F0aW9uO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJjb3JzXCIsIFwiYWRkXCIpLCB1cmwuc2VhcmNoUGFyYW1zLnNldChcIm9yaWdpblwiLCBvcmlnaW4pLCB0aGlzLmFkZE9yaWdpblVybCA9IHVybCwgdGhpcy5tZXNzYWdlID0gYFRoZSBjdXJyZW50IG9yaWdpbiBpcyBub3QgYWxsb3dlZCB0byBjb25uZWN0IHRvIHRoZSBMaXZlIENvbnRlbnQgQVBJLiBBZGQgaXQgaGVyZTogJHt1cmx9YDtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMubWVzc2FnZSA9IGBUaGUgY3VycmVudCBvcmlnaW4gaXMgbm90IGFsbG93ZWQgdG8gY29ubmVjdCB0byB0aGUgTGl2ZSBDb250ZW50IEFQSS4gQ2hhbmdlIHlvdXIgY29uZmlndXJhdGlvbiBoZXJlOiAke3VybH1gO1xuICB9XG59XG5jb25zdCBodHRwRXJyb3IgPSB7XG4gIG9uUmVzcG9uc2U6IChyZXMpID0+IHtcbiAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gNTAwKVxuICAgICAgdGhyb3cgbmV3IFNlcnZlckVycm9yKHJlcyk7XG4gICAgaWYgKHJlcy5zdGF0dXNDb2RlID49IDQwMClcbiAgICAgIHRocm93IG5ldyBDbGllbnRFcnJvcihyZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbn0sIHByaW50V2FybmluZ3MgPSB7XG4gIG9uUmVzcG9uc2U6IChyZXMpID0+IHtcbiAgICBjb25zdCB3YXJuID0gcmVzLmhlYWRlcnNbXCJ4LXNhbml0eS13YXJuaW5nXCJdO1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh3YXJuKSA/IHdhcm4gOiBbd2Fybl0pLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKChtc2cpID0+IGNvbnNvbGUud2Fybihtc2cpKSwgcmVzO1xuICB9XG59O1xuZnVuY3Rpb24gZGVmaW5lSHR0cFJlcXVlc3QoZW52TWlkZGxld2FyZTIpIHtcbiAgcmV0dXJuIGdldEl0KFtcbiAgICByZXRyeSh7IHNob3VsZFJldHJ5IH0pLFxuICAgIC4uLmVudk1pZGRsZXdhcmUyLFxuICAgIHByaW50V2FybmluZ3MsXG4gICAganNvblJlcXVlc3QoKSxcbiAgICBqc29uUmVzcG9uc2UoKSxcbiAgICBwcm9ncmVzcygpLFxuICAgIGh0dHBFcnJvcixcbiAgICBvYnNlcnZhYmxlKHsgaW1wbGVtZW50YXRpb246IE9ic2VydmFibGUgfSlcbiAgXSk7XG59XG5mdW5jdGlvbiBzaG91bGRSZXRyeShlcnIsIGF0dGVtcHQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMubWF4UmV0cmllcyA9PT0gMClcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IGlzU2FmZSA9IG9wdGlvbnMubWV0aG9kID09PSBcIkdFVFwiIHx8IG9wdGlvbnMubWV0aG9kID09PSBcIkhFQURcIiwgaXNRdWVyeSA9IChvcHRpb25zLnVyaSB8fCBvcHRpb25zLnVybCkuc3RhcnRzV2l0aChcIi9kYXRhL3F1ZXJ5XCIpLCBpc1JldHJpYWJsZVJlc3BvbnNlID0gZXJyLnJlc3BvbnNlICYmIChlcnIucmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDI5IHx8IGVyci5yZXNwb25zZS5zdGF0dXNDb2RlID09PSA1MDIgfHwgZXJyLnJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDUwMyk7XG4gIHJldHVybiAoaXNTYWZlIHx8IGlzUXVlcnkpICYmIGlzUmV0cmlhYmxlUmVzcG9uc2UgPyAhMCA6IHJldHJ5LnNob3VsZFJldHJ5KGVyciwgYXR0ZW1wdCwgb3B0aW9ucyk7XG59XG5jb25zdCBCQVNFX1VSTCA9IFwiaHR0cHM6Ly93d3cuc2FuaXR5LmlvL2hlbHAvXCI7XG5mdW5jdGlvbiBnZW5lcmF0ZUhlbHBVcmwoc2x1Zykge1xuICByZXR1cm4gQkFTRV9VUkwgKyBzbHVnO1xufVxuY29uc3QgVkFMSURfQVNTRVRfVFlQRVMgPSBbXCJpbWFnZVwiLCBcImZpbGVcIl0sIFZBTElEX0lOU0VSVF9MT0NBVElPTlMgPSBbXCJiZWZvcmVcIiwgXCJhZnRlclwiLCBcInJlcGxhY2VcIl0sIGRhdGFzZXQgPSAobmFtZSkgPT4ge1xuICBpZiAoIS9eKH5bYS16MC05XXsxfVstXFx3XXswLDYzfXxbYS16MC05XXsxfVstXFx3XXswLDYzfSkkLy50ZXN0KG5hbWUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiRGF0YXNldHMgY2FuIG9ubHkgY29udGFpbiBsb3dlcmNhc2UgY2hhcmFjdGVycywgbnVtYmVycywgdW5kZXJzY29yZXMgYW5kIGRhc2hlcywgYW5kIHN0YXJ0IHdpdGggdGlsZGUsIGFuZCBiZSBtYXhpbXVtIDY0IGNoYXJhY3RlcnNcIlxuICAgICk7XG59LCBwcm9qZWN0SWQgPSAoaWQpID0+IHtcbiAgaWYgKCEvXlstYS16MC05XSskL2kudGVzdChpZCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYHByb2plY3RJZGAgY2FuIG9ubHkgY29udGFpbiBvbmx5IGEteiwgMC05IGFuZCBkYXNoZXNcIik7XG59LCB2YWxpZGF0ZUFzc2V0VHlwZSA9ICh0eXBlKSA9PiB7XG4gIGlmIChWQUxJRF9BU1NFVF9UWVBFUy5pbmRleE9mKHR5cGUpID09PSAtMSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXNzZXQgdHlwZTogJHt0eXBlfS4gTXVzdCBiZSBvbmUgb2YgJHtWQUxJRF9BU1NFVF9UWVBFUy5qb2luKFwiLCBcIil9YCk7XG59LCB2YWxpZGF0ZU9iamVjdCA9IChvcCwgdmFsKSA9PiB7XG4gIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCAhPSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkodmFsKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3B9KCkgdGFrZXMgYW4gb2JqZWN0IG9mIHByb3BlcnRpZXNgKTtcbn0sIHZhbGlkYXRlRG9jdW1lbnRJZCA9IChvcCwgaWQpID0+IHtcbiAgaWYgKHR5cGVvZiBpZCAhPSBcInN0cmluZ1wiIHx8ICEvXlthLXowLTlfXVthLXowLTlfLi1dezAsMTI3fSQvaS50ZXN0KGlkKSB8fCBpZC5pbmNsdWRlcyhcIi4uXCIpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtvcH0oKTogXCIke2lkfVwiIGlzIG5vdCBhIHZhbGlkIGRvY3VtZW50IElEYCk7XG59LCByZXF1aXJlRG9jdW1lbnRJZCA9IChvcCwgZG9jKSA9PiB7XG4gIGlmICghZG9jLl9pZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3B9KCkgcmVxdWlyZXMgdGhhdCB0aGUgZG9jdW1lbnQgY29udGFpbnMgYW4gSUQgKFwiX2lkXCIgcHJvcGVydHkpYCk7XG4gIHZhbGlkYXRlRG9jdW1lbnRJZChvcCwgZG9jLl9pZCk7XG59LCB2YWxpZGF0ZUluc2VydCA9IChhdCwgc2VsZWN0b3IsIGl0ZW1zKSA9PiB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IFwiaW5zZXJ0KGF0LCBzZWxlY3RvciwgaXRlbXMpXCI7XG4gIGlmIChWQUxJRF9JTlNFUlRfTE9DQVRJT05TLmluZGV4T2YoYXQpID09PSAtMSkge1xuICAgIGNvbnN0IHZhbGlkID0gVkFMSURfSU5TRVJUX0xPQ0FUSU9OUy5tYXAoKGxvYykgPT4gYFwiJHtsb2N9XCJgKS5qb2luKFwiLCBcIik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3NpZ25hdHVyZX0gdGFrZXMgYW4gXCJhdFwiLWFyZ3VtZW50IHdoaWNoIGlzIG9uZSBvZjogJHt2YWxpZH1gKTtcbiAgfVxuICBpZiAodHlwZW9mIHNlbGVjdG9yICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3NpZ25hdHVyZX0gdGFrZXMgYSBcInNlbGVjdG9yXCItYXJndW1lbnQgd2hpY2ggbXVzdCBiZSBhIHN0cmluZ2ApO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzaWduYXR1cmV9IHRha2VzIGFuIFwiaXRlbXNcIi1hcmd1bWVudCB3aGljaCBtdXN0IGJlIGFuIGFycmF5YCk7XG59LCBoYXNEYXRhc2V0ID0gKGNvbmZpZykgPT4ge1xuICBpZiAoIWNvbmZpZy5kYXRhc2V0KVxuICAgIHRocm93IG5ldyBFcnJvcihcImBkYXRhc2V0YCBtdXN0IGJlIHByb3ZpZGVkIHRvIHBlcmZvcm0gcXVlcmllc1wiKTtcbiAgcmV0dXJuIGNvbmZpZy5kYXRhc2V0IHx8IFwiXCI7XG59LCByZXF1ZXN0VGFnID0gKHRhZykgPT4ge1xuICBpZiAodHlwZW9mIHRhZyAhPSBcInN0cmluZ1wiIHx8ICEvXlthLXowLTkuXy1dezEsNzV9JC9pLnRlc3QodGFnKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRhZyBjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLCB1bmRlcnNjb3JlcywgZGFzaGVzIGFuZCBkb3RzLCBhbmQgYmUgYmV0d2VlbiBvbmUgYW5kIDc1IGNoYXJhY3RlcnMgbG9uZy5cIlxuICAgICk7XG4gIHJldHVybiB0YWc7XG59O1xuZnVuY3Rpb24gb25jZShmbikge1xuICBsZXQgZGlkQ2FsbCA9ICExLCByZXR1cm5WYWx1ZTtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiAoZGlkQ2FsbCB8fCAocmV0dXJuVmFsdWUgPSBmbiguLi5hcmdzKSwgZGlkQ2FsbCA9ICEwKSwgcmV0dXJuVmFsdWUpO1xufVxuY29uc3QgY3JlYXRlV2FybmluZ1ByaW50ZXIgPSAobWVzc2FnZSkgPT4gKFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBvbmNlKCguLi5hcmdzKSA9PiBjb25zb2xlLndhcm4obWVzc2FnZS5qb2luKFwiIFwiKSwgLi4uYXJncykpXG4pLCBwcmludENkbkFuZFdpdGhDcmVkZW50aWFsc1dhcm5pbmcgPSBjcmVhdGVXYXJuaW5nUHJpbnRlcihbXG4gIFwiQmVjYXVzZSB5b3Ugc2V0IGB3aXRoQ3JlZGVudGlhbHNgIHRvIHRydWUsIHdlIHdpbGwgb3ZlcnJpZGUgeW91ciBgdXNlQ2RuYFwiLFxuICBcInNldHRpbmcgdG8gYmUgZmFsc2Ugc2luY2UgKGNvb2tpZS1iYXNlZCkgY3JlZGVudGlhbHMgYXJlIG5ldmVyIHNldCBvbiB0aGUgQ0ROXCJcbl0pLCBwcmludENkbldhcm5pbmcgPSBjcmVhdGVXYXJuaW5nUHJpbnRlcihbXG4gIFwiU2luY2UgeW91IGhhdmVuJ3Qgc2V0IGEgdmFsdWUgZm9yIGB1c2VDZG5gLCB3ZSB3aWxsIGRlbGl2ZXIgY29udGVudCB1c2luZyBvdXJcIixcbiAgXCJnbG9iYWwsIGVkZ2UtY2FjaGVkIEFQSS1DRE4uIElmIHlvdSB3aXNoIHRvIGhhdmUgY29udGVudCBkZWxpdmVyZWQgZmFzdGVyLCBzZXRcIixcbiAgXCJgdXNlQ2RuOiBmYWxzZWAgdG8gdXNlIHRoZSBMaXZlIEFQSS4gTm90ZTogWW91IG1heSBpbmN1ciBoaWdoZXIgY29zdHMgdXNpbmcgdGhlIGxpdmUgQVBJLlwiXG5dKSwgcHJpbnRDZG5QcmV2aWV3RHJhZnRzV2FybmluZyA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFtcbiAgXCJUaGUgU2FuaXR5IGNsaWVudCBpcyBjb25maWd1cmVkIHdpdGggdGhlIGBwZXJzcGVjdGl2ZWAgc2V0IHRvIGBwcmV2aWV3RHJhZnRzYCwgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHRoZSBBUEktQ0ROLlwiLFxuICBcIlRoZSBMaXZlIEFQSSB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gU2V0IGB1c2VDZG46IGZhbHNlYCBpbiB5b3VyIGNvbmZpZ3VyYXRpb24gdG8gaGlkZSB0aGlzIHdhcm5pbmcuXCJcbl0pLCBwcmludEJyb3dzZXJUb2tlbldhcm5pbmcgPSBjcmVhdGVXYXJuaW5nUHJpbnRlcihbXG4gIFwiWW91IGhhdmUgY29uZmlndXJlZCBTYW5pdHkgY2xpZW50IHRvIHVzZSBhIHRva2VuIGluIHRoZSBicm93c2VyLiBUaGlzIG1heSBjYXVzZSB1bmludGVudGlvbmFsIHNlY3VyaXR5IGlzc3Vlcy5cIixcbiAgYFNlZSAke2dlbmVyYXRlSGVscFVybChcbiAgICBcImpzLWNsaWVudC1icm93c2VyLXRva2VuXCJcbiAgKX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGhvdyB0byBoaWRlIHRoaXMgd2FybmluZy5gXG5dKSwgcHJpbnROb0FwaVZlcnNpb25TcGVjaWZpZWRXYXJuaW5nID0gY3JlYXRlV2FybmluZ1ByaW50ZXIoW1xuICBcIlVzaW5nIHRoZSBTYW5pdHkgY2xpZW50IHdpdGhvdXQgc3BlY2lmeWluZyBhbiBBUEkgdmVyc2lvbiBpcyBkZXByZWNhdGVkLlwiLFxuICBgU2VlICR7Z2VuZXJhdGVIZWxwVXJsKFwianMtY2xpZW50LWFwaS12ZXJzaW9uXCIpfWBcbl0pLCBwcmludE5vRGVmYXVsdEV4cG9ydCA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFtcbiAgXCJUaGUgZGVmYXVsdCBleHBvcnQgb2YgQHNhbml0eS9jbGllbnQgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIHRoZSBuYW1lZCBleHBvcnQgYGNyZWF0ZUNsaWVudGAgaW5zdGVhZC5cIlxuXSksIGRlZmF1bHRDZG5Ib3N0ID0gXCJhcGljZG4uc2FuaXR5LmlvXCIsIGRlZmF1bHRDb25maWcgPSB7XG4gIGFwaUhvc3Q6IFwiaHR0cHM6Ly9hcGkuc2FuaXR5LmlvXCIsXG4gIGFwaVZlcnNpb246IFwiMVwiLFxuICB1c2VQcm9qZWN0SG9zdG5hbWU6ICEwLFxuICBzdGVnYTogeyBlbmFibGVkOiAhMSB9XG59LCBMT0NBTEhPU1RTID0gW1wibG9jYWxob3N0XCIsIFwiMTI3LjAuMC4xXCIsIFwiMC4wLjAuMFwiXSwgaXNMb2NhbCA9IChob3N0KSA9PiBMT0NBTEhPU1RTLmluZGV4T2YoaG9zdCkgIT09IC0xO1xuZnVuY3Rpb24gdmFsaWRhdGVBcGlWZXJzaW9uKGFwaVZlcnNpb24pIHtcbiAgaWYgKGFwaVZlcnNpb24gPT09IFwiMVwiIHx8IGFwaVZlcnNpb24gPT09IFwiWFwiKVxuICAgIHJldHVybjtcbiAgY29uc3QgYXBpRGF0ZSA9IG5ldyBEYXRlKGFwaVZlcnNpb24pO1xuICBpZiAoISgvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9JC8udGVzdChhcGlWZXJzaW9uKSAmJiBhcGlEYXRlIGluc3RhbmNlb2YgRGF0ZSAmJiBhcGlEYXRlLmdldFRpbWUoKSA+IDApKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQVBJIHZlcnNpb24gc3RyaW5nLCBleHBlY3RlZCBgMWAgb3IgZGF0ZSBpbiBmb3JtYXQgYFlZWVktTU0tRERgXCIpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBcGlQZXJzcGVjdGl2ZShwZXJzcGVjdGl2ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwZXJzcGVjdGl2ZSkpIHtcbiAgICBmb3IgKGNvbnN0IHBlcnNwZWN0aXZlVmFsdWUgb2YgcGVyc3BlY3RpdmUpXG4gICAgICBpZiAocGVyc3BlY3RpdmVWYWx1ZSAhPT0gXCJwdWJsaXNoZWRcIiAmJiBwZXJzcGVjdGl2ZVZhbHVlICE9PSBcImRyYWZ0c1wiICYmICEodHlwZW9mIHBlcnNwZWN0aXZlVmFsdWUgPT0gXCJzdHJpbmdcIiAmJiBwZXJzcGVjdGl2ZVZhbHVlLnN0YXJ0c1dpdGgoXCJyXCIpICYmIHBlcnNwZWN0aXZlVmFsdWUgIT09IFwicmF3XCIpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBBUEkgcGVyc3BlY3RpdmUgdmFsdWUsIGV4cGVjdGVkIGBwdWJsaXNoZWRgLCBgZHJhZnRzYCBvciBhIHZhbGlkIHJlbGVhc2UgaWRlbnRpZmllciBzdHJpbmdcIlxuICAgICAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBzd2l0Y2ggKHBlcnNwZWN0aXZlKSB7XG4gICAgY2FzZSBcInByZXZpZXdEcmFmdHNcIjpcbiAgICBjYXNlIFwiZHJhZnRzXCI6XG4gICAgY2FzZSBcInB1Ymxpc2hlZFwiOlxuICAgIGNhc2UgXCJyYXdcIjpcbiAgICAgIHJldHVybjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIEFQSSBwZXJzcGVjdGl2ZSBzdHJpbmcsIGV4cGVjdGVkIGBwdWJsaXNoZWRgLCBgcHJldmlld0RyYWZ0c2Agb3IgYHJhd2BcIlxuICAgICAgKTtcbiAgfVxufVxuY29uc3QgaW5pdENvbmZpZyA9IChjb25maWcsIHByZXZDb25maWcpID0+IHtcbiAgY29uc3Qgc3BlY2lmaWVkQ29uZmlnID0ge1xuICAgIC4uLnByZXZDb25maWcsXG4gICAgLi4uY29uZmlnLFxuICAgIHN0ZWdhOiB7XG4gICAgICAuLi50eXBlb2YgcHJldkNvbmZpZy5zdGVnYSA9PSBcImJvb2xlYW5cIiA/IHsgZW5hYmxlZDogcHJldkNvbmZpZy5zdGVnYSB9IDogcHJldkNvbmZpZy5zdGVnYSB8fCBkZWZhdWx0Q29uZmlnLnN0ZWdhLFxuICAgICAgLi4udHlwZW9mIGNvbmZpZy5zdGVnYSA9PSBcImJvb2xlYW5cIiA/IHsgZW5hYmxlZDogY29uZmlnLnN0ZWdhIH0gOiBjb25maWcuc3RlZ2EgfHwge31cbiAgICB9XG4gIH07XG4gIHNwZWNpZmllZENvbmZpZy5hcGlWZXJzaW9uIHx8IHByaW50Tm9BcGlWZXJzaW9uU3BlY2lmaWVkV2FybmluZygpO1xuICBjb25zdCBuZXdDb25maWcgPSB7XG4gICAgLi4uZGVmYXVsdENvbmZpZyxcbiAgICAuLi5zcGVjaWZpZWRDb25maWdcbiAgfSwgcHJvamVjdEJhc2VkID0gbmV3Q29uZmlnLnVzZVByb2plY3RIb3N0bmFtZTtcbiAgaWYgKHR5cGVvZiBQcm9taXNlID4gXCJ1XCIpIHtcbiAgICBjb25zdCBoZWxwVXJsID0gZ2VuZXJhdGVIZWxwVXJsKFwianMtY2xpZW50LXByb21pc2UtcG9seWZpbGxcIik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBuYXRpdmUgUHJvbWlzZS1pbXBsZW1lbnRhdGlvbiBmb3VuZCwgcG9seWZpbGwgbmVlZGVkIC0gc2VlICR7aGVscFVybH1gKTtcbiAgfVxuICBpZiAocHJvamVjdEJhc2VkICYmICFuZXdDb25maWcucHJvamVjdElkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbmZpZ3VyYXRpb24gbXVzdCBjb250YWluIGBwcm9qZWN0SWRgXCIpO1xuICBpZiAodHlwZW9mIG5ld0NvbmZpZy5wZXJzcGVjdGl2ZSA8IFwidVwiICYmIHZhbGlkYXRlQXBpUGVyc3BlY3RpdmUobmV3Q29uZmlnLnBlcnNwZWN0aXZlKSwgXCJlbmNvZGVTb3VyY2VNYXBcIiBpbiBuZXdDb25maWcpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJdCBsb29rcyBsaWtlIHlvdSdyZSB1c2luZyBvcHRpb25zIG1lYW50IGZvciAnQHNhbml0eS9wcmV2aWV3LWtpdC9jbGllbnQnLiAnZW5jb2RlU291cmNlTWFwJyBpcyBub3Qgc3VwcG9ydGVkIGluICdAc2FuaXR5L2NsaWVudCcuIERpZCB5b3UgbWVhbiAnc3RlZ2EuZW5hYmxlZCc/XCJcbiAgICApO1xuICBpZiAoXCJlbmNvZGVTb3VyY2VNYXBBdFBhdGhcIiBpbiBuZXdDb25maWcpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJdCBsb29rcyBsaWtlIHlvdSdyZSB1c2luZyBvcHRpb25zIG1lYW50IGZvciAnQHNhbml0eS9wcmV2aWV3LWtpdC9jbGllbnQnLiAnZW5jb2RlU291cmNlTWFwQXRQYXRoJyBpcyBub3Qgc3VwcG9ydGVkIGluICdAc2FuaXR5L2NsaWVudCcuIERpZCB5b3UgbWVhbiAnc3RlZ2EuZmlsdGVyJz9cIlxuICAgICk7XG4gIGlmICh0eXBlb2YgbmV3Q29uZmlnLnN0ZWdhLmVuYWJsZWQgIT0gXCJib29sZWFuXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBzdGVnYS5lbmFibGVkIG11c3QgYmUgYSBib29sZWFuLCByZWNlaXZlZCAke25ld0NvbmZpZy5zdGVnYS5lbmFibGVkfWApO1xuICBpZiAobmV3Q29uZmlnLnN0ZWdhLmVuYWJsZWQgJiYgbmV3Q29uZmlnLnN0ZWdhLnN0dWRpb1VybCA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcInN0ZWdhLnN0dWRpb1VybCBtdXN0IGJlIGRlZmluZWQgd2hlbiBzdGVnYS5lbmFibGVkIGlzIHRydWVcIik7XG4gIGlmIChuZXdDb25maWcuc3RlZ2EuZW5hYmxlZCAmJiB0eXBlb2YgbmV3Q29uZmlnLnN0ZWdhLnN0dWRpb1VybCAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBuZXdDb25maWcuc3RlZ2Euc3R1ZGlvVXJsICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgc3RlZ2Euc3R1ZGlvVXJsIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbiwgcmVjZWl2ZWQgJHtuZXdDb25maWcuc3RlZ2Euc3R1ZGlvVXJsfWBcbiAgICApO1xuICBjb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSwgaXNMb2NhbGhvc3QgPSBpc0Jyb3dzZXIgJiYgaXNMb2NhbCh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpO1xuICBpc0Jyb3dzZXIgJiYgaXNMb2NhbGhvc3QgJiYgbmV3Q29uZmlnLnRva2VuICYmIG5ld0NvbmZpZy5pZ25vcmVCcm93c2VyVG9rZW5XYXJuaW5nICE9PSAhMCA/IHByaW50QnJvd3NlclRva2VuV2FybmluZygpIDogdHlwZW9mIG5ld0NvbmZpZy51c2VDZG4gPiBcInVcIiAmJiBwcmludENkbldhcm5pbmcoKSwgcHJvamVjdEJhc2VkICYmIHByb2plY3RJZChuZXdDb25maWcucHJvamVjdElkKSwgbmV3Q29uZmlnLmRhdGFzZXQgJiYgZGF0YXNldChuZXdDb25maWcuZGF0YXNldCksIFwicmVxdWVzdFRhZ1ByZWZpeFwiIGluIG5ld0NvbmZpZyAmJiAobmV3Q29uZmlnLnJlcXVlc3RUYWdQcmVmaXggPSBuZXdDb25maWcucmVxdWVzdFRhZ1ByZWZpeCA/IHJlcXVlc3RUYWcobmV3Q29uZmlnLnJlcXVlc3RUYWdQcmVmaXgpLnJlcGxhY2UoL1xcLiskLywgXCJcIikgOiB2b2lkIDApLCBuZXdDb25maWcuYXBpVmVyc2lvbiA9IGAke25ld0NvbmZpZy5hcGlWZXJzaW9ufWAucmVwbGFjZSgvXnYvLCBcIlwiKSwgbmV3Q29uZmlnLmlzRGVmYXVsdEFwaSA9IG5ld0NvbmZpZy5hcGlIb3N0ID09PSBkZWZhdWx0Q29uZmlnLmFwaUhvc3QsIG5ld0NvbmZpZy51c2VDZG4gPT09ICEwICYmIG5ld0NvbmZpZy53aXRoQ3JlZGVudGlhbHMgJiYgcHJpbnRDZG5BbmRXaXRoQ3JlZGVudGlhbHNXYXJuaW5nKCksIG5ld0NvbmZpZy51c2VDZG4gPSBuZXdDb25maWcudXNlQ2RuICE9PSAhMSAmJiAhbmV3Q29uZmlnLndpdGhDcmVkZW50aWFscywgdmFsaWRhdGVBcGlWZXJzaW9uKG5ld0NvbmZpZy5hcGlWZXJzaW9uKTtcbiAgY29uc3QgaG9zdFBhcnRzID0gbmV3Q29uZmlnLmFwaUhvc3Quc3BsaXQoXCI6Ly9cIiwgMiksIHByb3RvY29sID0gaG9zdFBhcnRzWzBdLCBob3N0ID0gaG9zdFBhcnRzWzFdLCBjZG5Ib3N0ID0gbmV3Q29uZmlnLmlzRGVmYXVsdEFwaSA/IGRlZmF1bHRDZG5Ib3N0IDogaG9zdDtcbiAgcmV0dXJuIG5ld0NvbmZpZy51c2VQcm9qZWN0SG9zdG5hbWUgPyAobmV3Q29uZmlnLnVybCA9IGAke3Byb3RvY29sfTovLyR7bmV3Q29uZmlnLnByb2plY3RJZH0uJHtob3N0fS92JHtuZXdDb25maWcuYXBpVmVyc2lvbn1gLCBuZXdDb25maWcuY2RuVXJsID0gYCR7cHJvdG9jb2x9Oi8vJHtuZXdDb25maWcucHJvamVjdElkfS4ke2Nkbkhvc3R9L3Yke25ld0NvbmZpZy5hcGlWZXJzaW9ufWApIDogKG5ld0NvbmZpZy51cmwgPSBgJHtuZXdDb25maWcuYXBpSG9zdH0vdiR7bmV3Q29uZmlnLmFwaVZlcnNpb259YCwgbmV3Q29uZmlnLmNkblVybCA9IG5ld0NvbmZpZy51cmwpLCBuZXdDb25maWc7XG59O1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKHNlbCkge1xuICBpZiAodHlwZW9mIHNlbCA9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB7IGlkOiBzZWwgfTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VsKSlcbiAgICByZXR1cm4geyBxdWVyeTogXCIqW19pZCBpbiAkaWRzXVwiLCBwYXJhbXM6IHsgaWRzOiBzZWwgfSB9O1xuICBpZiAodHlwZW9mIHNlbCA9PSBcIm9iamVjdFwiICYmIHNlbCAhPT0gbnVsbCAmJiBcInF1ZXJ5XCIgaW4gc2VsICYmIHR5cGVvZiBzZWwucXVlcnkgPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gXCJwYXJhbXNcIiBpbiBzZWwgJiYgdHlwZW9mIHNlbC5wYXJhbXMgPT0gXCJvYmplY3RcIiAmJiBzZWwucGFyYW1zICE9PSBudWxsID8geyBxdWVyeTogc2VsLnF1ZXJ5LCBwYXJhbXM6IHNlbC5wYXJhbXMgfSA6IHsgcXVlcnk6IHNlbC5xdWVyeSB9O1xuICBjb25zdCBzZWxlY3Rpb25PcHRzID0gW1xuICAgIFwiKiBEb2N1bWVudCBJRCAoPGRvY0lkPilcIixcbiAgICBcIiogQXJyYXkgb2YgZG9jdW1lbnQgSURzXCIsXG4gICAgXCIqIE9iamVjdCBjb250YWluaW5nIGBxdWVyeWBcIlxuICBdLmpvaW4oYFxuYCk7XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzZWxlY3Rpb24gLSBtdXN0IGJlIG9uZSBvZjpcblxuJHtzZWxlY3Rpb25PcHRzfWApO1xufVxuY2xhc3MgQmFzZVBhdGNoIHtcbiAgc2VsZWN0aW9uO1xuICBvcGVyYXRpb25zO1xuICBjb25zdHJ1Y3RvcihzZWxlY3Rpb24sIG9wZXJhdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uLCB0aGlzLm9wZXJhdGlvbnMgPSBvcGVyYXRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIHRvIHRoZSBkb2N1bWVudC4gRG9lcyBOT1QgbWVyZ2Ugb2JqZWN0cy5cbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCBwYXRjaCwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgLSBBdHRyaWJ1dGVzIHRvIHNldC4gVG8gc2V0IGEgZGVlcCBhdHRyaWJ1dGUsIHVzZSBKU09OTWF0Y2gsIGVnOiBcXHtcIm5lc3RlZC5wcm9wXCI6IFwidmFsdWVcIlxcfVxuICAgKi9cbiAgc2V0KGF0dHJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihcInNldFwiLCBhdHRycyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgdG8gdGhlIGRvY3VtZW50IGlmIHRoZXkgYXJlIG5vdCBjdXJyZW50bHkgc2V0LiBEb2VzIE5PVCBtZXJnZSBvYmplY3RzLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHBhdGNoLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyAtIEF0dHJpYnV0ZXMgdG8gc2V0LiBUbyBzZXQgYSBkZWVwIGF0dHJpYnV0ZSwgdXNlIEpTT05NYXRjaCwgZWc6IFxce1wibmVzdGVkLnByb3BcIjogXCJ2YWx1ZVwiXFx9XG4gICAqL1xuICBzZXRJZk1pc3NpbmcoYXR0cnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYXNzaWduKFwic2V0SWZNaXNzaW5nXCIsIGF0dHJzKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgYSBcImRpZmYtbWF0Y2gtcGF0Y2hcIiBvcGVyYXRpb24gb24gdGhlIHN0cmluZyBhdHRyaWJ1dGVzIHByb3ZpZGVkLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHBhdGNoLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyAtIEF0dHJpYnV0ZXMgdG8gcGVyZm9ybSBvcGVyYXRpb24gb24uIFRvIHNldCBhIGRlZXAgYXR0cmlidXRlLCB1c2UgSlNPTk1hdGNoLCBlZzogXFx7XCJuZXN0ZWQucHJvcFwiOiBcImRtcFwiXFx9XG4gICAqL1xuICBkaWZmTWF0Y2hQYXRjaChhdHRycykge1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChcImRpZmZNYXRjaFBhdGNoXCIsIGF0dHJzKSwgdGhpcy5fYXNzaWduKFwiZGlmZk1hdGNoUGF0Y2hcIiwgYXR0cnMpO1xuICB9XG4gIC8qKlxuICAgKiBVbnNldHMgdGhlIGF0dHJpYnV0ZSBwYXRocyBwcm92aWRlZC5cbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCBwYXRjaCwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgLSBBdHRyaWJ1dGUgcGF0aHMgdG8gdW5zZXQuXG4gICAqL1xuICB1bnNldChhdHRycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhdHRycykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnNldChhdHRycykgdGFrZXMgYW4gYXJyYXkgb2YgYXR0cmlidXRlcyB0byB1bnNldCwgbm9uLWFycmF5IGdpdmVuXCIpO1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wZXJhdGlvbnMsIHsgdW5zZXQ6IGF0dHJzIH0pLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgYSBudW1lcmljIHZhbHVlLiBFYWNoIGVudHJ5IGluIHRoZSBhcmd1bWVudCBpcyBlaXRoZXIgYW4gYXR0cmlidXRlIG9yIGEgSlNPTiBwYXRoLiBUaGUgdmFsdWUgbWF5IGJlIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS4gVGhlIG9wZXJhdGlvbiB3aWxsIGZhaWwgaWYgdGFyZ2V0IHZhbHVlIGlzIG5vdCBhIG51bWVyaWMgdmFsdWUsIG9yIGRvZXNuJ3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyAtIE9iamVjdCBvZiBhdHRyaWJ1dGUgcGF0aHMgdG8gaW5jcmVtZW50LCB2YWx1ZXMgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgdG8gaW5jcmVtZW50IGJ5LlxuICAgKi9cbiAgaW5jKGF0dHJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihcImluY1wiLCBhdHRycyk7XG4gIH1cbiAgLyoqXG4gICAqIERlY3JlbWVudCBhIG51bWVyaWMgdmFsdWUuIEVhY2ggZW50cnkgaW4gdGhlIGFyZ3VtZW50IGlzIGVpdGhlciBhbiBhdHRyaWJ1dGUgb3IgYSBKU09OIHBhdGguIFRoZSB2YWx1ZSBtYXkgYmUgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLiBUaGUgb3BlcmF0aW9uIHdpbGwgZmFpbCBpZiB0YXJnZXQgdmFsdWUgaXMgbm90IGEgbnVtZXJpYyB2YWx1ZSwgb3IgZG9lc24ndCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIC0gT2JqZWN0IG9mIGF0dHJpYnV0ZSBwYXRocyB0byBkZWNyZW1lbnQsIHZhbHVlcyByZXByZXNlbnRpbmcgdGhlIG51bWJlciB0byBkZWNyZW1lbnQgYnkuXG4gICAqL1xuICBkZWMoYXR0cnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYXNzaWduKFwiZGVjXCIsIGF0dHJzKTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgbWV0aG9kcyBmb3IgbW9kaWZ5aW5nIGFycmF5cywgYnkgaW5zZXJ0aW5nLCBhcHBlbmRpbmcgYW5kIHJlcGxhY2luZyBlbGVtZW50cyB2aWEgYSBKU09OUGF0aCBleHByZXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYXQgLSBMb2NhdGlvbiB0byBpbnNlcnQgYXQsIHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBzZWxlY3Rvciwgb3IgJ3JlcGxhY2UnIHRoZSBtYXRjaGVkIHBhdGhcbiAgICogQHBhcmFtIHNlbGVjdG9yIC0gSlNPTlBhdGggZXhwcmVzc2lvbiwgZWcgYGNvbW1lbnRzWy0xXWAgb3IgYGJsb2Nrc1tfa2V5PT1cImFiYzEyM1wiXWBcbiAgICogQHBhcmFtIGl0ZW1zIC0gQXJyYXkgb2YgaXRlbXMgdG8gaW5zZXJ0L3JlcGxhY2VcbiAgICovXG4gIGluc2VydChhdCwgc2VsZWN0b3IsIGl0ZW1zKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlSW5zZXJ0KGF0LCBzZWxlY3RvciwgaXRlbXMpLCB0aGlzLl9hc3NpZ24oXCJpbnNlcnRcIiwgeyBbYXRdOiBzZWxlY3RvciwgaXRlbXMgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZCB0aGUgZ2l2ZW4gaXRlbXMgdG8gdGhlIGFycmF5IGF0IHRoZSBnaXZlbiBKU09OUGF0aFxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgLSBBdHRyaWJ1dGUvcGF0aCB0byBhcHBlbmQgdG8sIGVnIGBjb21tZW50c2Agb3IgYHBlcnNvbi5ob2JiaWVzYFxuICAgKiBAcGFyYW0gaXRlbXMgLSBBcnJheSBvZiBpdGVtcyB0byBhcHBlbmQgdG8gdGhlIGFycmF5XG4gICAqL1xuICBhcHBlbmQoc2VsZWN0b3IsIGl0ZW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KFwiYWZ0ZXJcIiwgYCR7c2VsZWN0b3J9Wy0xXWAsIGl0ZW1zKTtcbiAgfVxuICAvKipcbiAgICogUHJlcGVuZCB0aGUgZ2l2ZW4gaXRlbXMgdG8gdGhlIGFycmF5IGF0IHRoZSBnaXZlbiBKU09OUGF0aFxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgLSBBdHRyaWJ1dGUvcGF0aCB0byBwcmVwZW5kIHRvLCBlZyBgY29tbWVudHNgIG9yIGBwZXJzb24uaG9iYmllc2BcbiAgICogQHBhcmFtIGl0ZW1zIC0gQXJyYXkgb2YgaXRlbXMgdG8gcHJlcGVuZCB0byB0aGUgYXJyYXlcbiAgICovXG4gIHByZXBlbmQoc2VsZWN0b3IsIGl0ZW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KFwiYmVmb3JlXCIsIGAke3NlbGVjdG9yfVswXWAsIGl0ZW1zKTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBjb250ZW50cyBvZiBhbiBhcnJheSBieSByZW1vdmluZyBleGlzdGluZyBlbGVtZW50cyBhbmQvb3IgYWRkaW5nIG5ldyBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdG9yIC0gQXR0cmlidXRlIG9yIEpTT05QYXRoIGV4cHJlc3Npb24gZm9yIGFycmF5XG4gICAqIEBwYXJhbSBzdGFydCAtIEluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IGNoYW5naW5nIHRoZSBhcnJheSAod2l0aCBvcmlnaW4gMCkuIElmIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSwgYWN0dWFsIHN0YXJ0aW5nIGluZGV4IHdpbGwgYmUgc2V0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LiBJZiBuZWdhdGl2ZSwgd2lsbCBiZWdpbiB0aGF0IG1hbnkgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheSAod2l0aCBvcmlnaW4gLTEpIGFuZCB3aWxsIGJlIHNldCB0byAwIGlmIGFic29sdXRlIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS54XG4gICAqIEBwYXJhbSBkZWxldGVDb3VudCAtIEFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgbnVtYmVyIG9mIG9sZCBhcnJheSBlbGVtZW50cyB0byByZW1vdmUuXG4gICAqIEBwYXJhbSBpdGVtcyAtIFRoZSBlbGVtZW50cyB0byBhZGQgdG8gdGhlIGFycmF5LCBiZWdpbm5pbmcgYXQgdGhlIHN0YXJ0IGluZGV4LiBJZiB5b3UgZG9uJ3Qgc3BlY2lmeSBhbnkgZWxlbWVudHMsIHNwbGljZSgpIHdpbGwgb25seSByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYXJyYXkuXG4gICAqL1xuICBzcGxpY2Uoc2VsZWN0b3IsIHN0YXJ0LCBkZWxldGVDb3VudCwgaXRlbXMpIHtcbiAgICBjb25zdCBkZWxBbGwgPSB0eXBlb2YgZGVsZXRlQ291bnQgPiBcInVcIiB8fCBkZWxldGVDb3VudCA9PT0gLTEsIHN0YXJ0SW5kZXggPSBzdGFydCA8IDAgPyBzdGFydCAtIDEgOiBzdGFydCwgZGVsQ291bnQgPSBkZWxBbGwgPyAtMSA6IE1hdGgubWF4KDAsIHN0YXJ0ICsgZGVsZXRlQ291bnQpLCBkZWxSYW5nZSA9IHN0YXJ0SW5kZXggPCAwICYmIGRlbENvdW50ID49IDAgPyBcIlwiIDogZGVsQ291bnQsIHJhbmdlU2VsZWN0b3IgPSBgJHtzZWxlY3Rvcn1bJHtzdGFydEluZGV4fToke2RlbFJhbmdlfV1gO1xuICAgIHJldHVybiB0aGlzLmluc2VydChcInJlcGxhY2VcIiwgcmFuZ2VTZWxlY3RvciwgaXRlbXMgfHwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcmV2aXNpb24gY2xhdXNlLCBwcmV2ZW50aW5nIHRoZSBkb2N1bWVudCBmcm9tIGJlaW5nIHBhdGNoZWQgaWYgdGhlIGBfcmV2YCBwcm9wZXJ0eSBkb2VzIG5vdCBtYXRjaCB0aGUgZ2l2ZW4gdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHJldiAtIFJldmlzaW9uIHRvIGxvY2sgdGhlIHBhdGNoIHRvXG4gICAqL1xuICBpZlJldmlzaW9uSWQocmV2KSB7XG4gICAgcmV0dXJuIHRoaXMub3BlcmF0aW9ucy5pZlJldmlzaW9uSUQgPSByZXYsIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIHBsYWluIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHBhdGNoXG4gICAqL1xuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHsgLi4uZ2V0U2VsZWN0aW9uKHRoaXMuc2VsZWN0aW9uKSwgLi4udGhpcy5vcGVyYXRpb25zIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIHBsYWluIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHBhdGNoXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgcGF0Y2ggb2YgYWxsIG9wZXJhdGlvbnNcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnMgPSB7fSwgdGhpcztcbiAgfVxuICBfYXNzaWduKG9wLCBwcm9wcywgbWVyZ2UgPSAhMCkge1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChvcCwgcHJvcHMpLCB0aGlzLm9wZXJhdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wZXJhdGlvbnMsIHtcbiAgICAgIFtvcF06IE9iamVjdC5hc3NpZ24oe30sIG1lcmdlICYmIHRoaXMub3BlcmF0aW9uc1tvcF0gfHwge30sIHByb3BzKVxuICAgIH0pLCB0aGlzO1xuICB9XG4gIF9zZXQob3AsIHByb3BzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihvcCwgcHJvcHMsICExKTtcbiAgfVxufVxuY2xhc3MgT2JzZXJ2YWJsZVBhdGNoIGV4dGVuZHMgQmFzZVBhdGNoIHtcbiAgI2NsaWVudDtcbiAgY29uc3RydWN0b3Ioc2VsZWN0aW9uLCBvcGVyYXRpb25zLCBjbGllbnQpIHtcbiAgICBzdXBlcihzZWxlY3Rpb24sIG9wZXJhdGlvbnMpLCB0aGlzLiNjbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgcGF0Y2hcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVBhdGNoKHRoaXMuc2VsZWN0aW9uLCB7IC4uLnRoaXMub3BlcmF0aW9ucyB9LCB0aGlzLiNjbGllbnQpO1xuICB9XG4gIGNvbW1pdChvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLiNjbGllbnQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiTm8gYGNsaWVudGAgcGFzc2VkIHRvIHBhdGNoLCBlaXRoZXIgcHJvdmlkZSBvbmUgb3IgcGFzcyB0aGUgcGF0Y2ggdG8gYSBjbGllbnRzIGBtdXRhdGUoKWAgbWV0aG9kXCJcbiAgICAgICk7XG4gICAgY29uc3QgcmV0dXJuRmlyc3QgPSB0eXBlb2YgdGhpcy5zZWxlY3Rpb24gPT0gXCJzdHJpbmdcIiwgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyByZXR1cm5GaXJzdCwgcmV0dXJuRG9jdW1lbnRzOiAhMCB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy4jY2xpZW50Lm11dGF0ZSh7IHBhdGNoOiB0aGlzLnNlcmlhbGl6ZSgpIH0sIG9wdHMpO1xuICB9XG59XG5jbGFzcyBQYXRjaCBleHRlbmRzIEJhc2VQYXRjaCB7XG4gICNjbGllbnQ7XG4gIGNvbnN0cnVjdG9yKHNlbGVjdGlvbiwgb3BlcmF0aW9ucywgY2xpZW50KSB7XG4gICAgc3VwZXIoc2VsZWN0aW9uLCBvcGVyYXRpb25zKSwgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHBhdGNoXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFBhdGNoKHRoaXMuc2VsZWN0aW9uLCB7IC4uLnRoaXMub3BlcmF0aW9ucyB9LCB0aGlzLiNjbGllbnQpO1xuICB9XG4gIGNvbW1pdChvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLiNjbGllbnQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiTm8gYGNsaWVudGAgcGFzc2VkIHRvIHBhdGNoLCBlaXRoZXIgcHJvdmlkZSBvbmUgb3IgcGFzcyB0aGUgcGF0Y2ggdG8gYSBjbGllbnRzIGBtdXRhdGUoKWAgbWV0aG9kXCJcbiAgICAgICk7XG4gICAgY29uc3QgcmV0dXJuRmlyc3QgPSB0eXBlb2YgdGhpcy5zZWxlY3Rpb24gPT0gXCJzdHJpbmdcIiwgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyByZXR1cm5GaXJzdCwgcmV0dXJuRG9jdW1lbnRzOiAhMCB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy4jY2xpZW50Lm11dGF0ZSh7IHBhdGNoOiB0aGlzLnNlcmlhbGl6ZSgpIH0sIG9wdHMpO1xuICB9XG59XG5jb25zdCBkZWZhdWx0TXV0YXRlT3B0aW9ucyA9IHsgcmV0dXJuRG9jdW1lbnRzOiAhMSB9O1xuY2xhc3MgQmFzZVRyYW5zYWN0aW9uIHtcbiAgb3BlcmF0aW9ucztcbiAgdHJ4SWQ7XG4gIGNvbnN0cnVjdG9yKG9wZXJhdGlvbnMgPSBbXSwgdHJhbnNhY3Rpb25JZCkge1xuICAgIHRoaXMub3BlcmF0aW9ucyA9IG9wZXJhdGlvbnMsIHRoaXMudHJ4SWQgPSB0cmFuc2FjdGlvbklkO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNhbml0eSBkb2N1bWVudC4gSWYgYF9pZGAgaXMgcHJvdmlkZWQgYW5kIGFscmVhZHkgZXhpc3RzLCB0aGUgbXV0YXRpb24gd2lsbCBmYWlsLiBJZiBubyBgX2lkYCBpcyBnaXZlbiwgb25lIHdpbGwgYXV0b21hdGljYWxseSBiZSBnZW5lcmF0ZWQgYnkgdGhlIGRhdGFiYXNlLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBkb2MgLSBEb2N1bWVudCB0byBjcmVhdGUuIFJlcXVpcmVzIGEgYF90eXBlYCBwcm9wZXJ0eS5cbiAgICovXG4gIGNyZWF0ZShkb2MpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoXCJjcmVhdGVcIiwgZG9jKSwgdGhpcy5fYWRkKHsgY3JlYXRlOiBkb2MgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU2FuaXR5IGRvY3VtZW50LiBJZiBhIGRvY3VtZW50IHdpdGggdGhlIHNhbWUgYF9pZGAgYWxyZWFkeSBleGlzdHMsIHRoZSBjcmVhdGUgb3BlcmF0aW9uIHdpbGwgYmUgaWdub3JlZC5cbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gZG9jIC0gRG9jdW1lbnQgdG8gY3JlYXRlIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuIFJlcXVpcmVzIGBfaWRgIGFuZCBgX3R5cGVgIHByb3BlcnRpZXMuXG4gICAqL1xuICBjcmVhdGVJZk5vdEV4aXN0cyhkb2MpIHtcbiAgICBjb25zdCBvcCA9IFwiY3JlYXRlSWZOb3RFeGlzdHNcIjtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qob3AsIGRvYyksIHJlcXVpcmVEb2N1bWVudElkKG9wLCBkb2MpLCB0aGlzLl9hZGQoeyBbb3BdOiBkb2MgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU2FuaXR5IGRvY3VtZW50LCBvciByZXBsYWNlcyBhbiBleGlzdGluZyBvbmUgaWYgdGhlIHNhbWUgYF9pZGAgaXMgYWxyZWFkeSB1c2VkLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBkb2MgLSBEb2N1bWVudCB0byBjcmVhdGUgb3IgcmVwbGFjZS4gUmVxdWlyZXMgYF9pZGAgYW5kIGBfdHlwZWAgcHJvcGVydGllcy5cbiAgICovXG4gIGNyZWF0ZU9yUmVwbGFjZShkb2MpIHtcbiAgICBjb25zdCBvcCA9IFwiY3JlYXRlT3JSZXBsYWNlXCI7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KG9wLCBkb2MpLCByZXF1aXJlRG9jdW1lbnRJZChvcCwgZG9jKSwgdGhpcy5fYWRkKHsgW29wXTogZG9jIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSBkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBkb2N1bWVudCBJRFxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBkb2N1bWVudElkIC0gRG9jdW1lbnQgSUQgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoZG9jdW1lbnRJZCkge1xuICAgIHJldHVybiB2YWxpZGF0ZURvY3VtZW50SWQoXCJkZWxldGVcIiwgZG9jdW1lbnRJZCksIHRoaXMuX2FkZCh7IGRlbGV0ZTogeyBpZDogZG9jdW1lbnRJZCB9IH0pO1xuICB9XG4gIHRyYW5zYWN0aW9uSWQoaWQpIHtcbiAgICByZXR1cm4gaWQgPyAodGhpcy50cnhJZCA9IGlkLCB0aGlzKSA6IHRoaXMudHJ4SWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIHBsYWluIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLm9wZXJhdGlvbnNdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwbGFpbiBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIHRyYW5zYWN0aW9uIG9mIGFsbCBvcGVyYXRpb25zXG4gICAqL1xuICByZXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zID0gW10sIHRoaXM7XG4gIH1cbiAgX2FkZChtdXQpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zLnB1c2gobXV0KSwgdGhpcztcbiAgfVxufVxuY2xhc3MgVHJhbnNhY3Rpb24gZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb24ge1xuICAjY2xpZW50O1xuICBjb25zdHJ1Y3RvcihvcGVyYXRpb25zLCBjbGllbnQsIHRyYW5zYWN0aW9uSWQpIHtcbiAgICBzdXBlcihvcGVyYXRpb25zLCB0cmFuc2FjdGlvbklkKSwgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKFsuLi50aGlzLm9wZXJhdGlvbnNdLCB0aGlzLiNjbGllbnQsIHRoaXMudHJ4SWQpO1xuICB9XG4gIGNvbW1pdChvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLiNjbGllbnQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiTm8gYGNsaWVudGAgcGFzc2VkIHRvIHRyYW5zYWN0aW9uLCBlaXRoZXIgcHJvdmlkZSBvbmUgb3IgcGFzcyB0aGUgdHJhbnNhY3Rpb24gdG8gYSBjbGllbnRzIGBtdXRhdGUoKWAgbWV0aG9kXCJcbiAgICAgICk7XG4gICAgcmV0dXJuIHRoaXMuI2NsaWVudC5tdXRhdGUoXG4gICAgICB0aGlzLnNlcmlhbGl6ZSgpLFxuICAgICAgT2JqZWN0LmFzc2lnbih7IHRyYW5zYWN0aW9uSWQ6IHRoaXMudHJ4SWQgfSwgZGVmYXVsdE11dGF0ZU9wdGlvbnMsIG9wdGlvbnMgfHwge30pXG4gICAgKTtcbiAgfVxuICBwYXRjaChwYXRjaE9yRG9jdW1lbnRJZCwgcGF0Y2hPcHMpIHtcbiAgICBjb25zdCBpc0J1aWxkZXIgPSB0eXBlb2YgcGF0Y2hPcHMgPT0gXCJmdW5jdGlvblwiO1xuICAgIGlmICh0eXBlb2YgcGF0Y2hPckRvY3VtZW50SWQgIT0gXCJzdHJpbmdcIiAmJiBwYXRjaE9yRG9jdW1lbnRJZCBpbnN0YW5jZW9mIFBhdGNoKVxuICAgICAgcmV0dXJuIHRoaXMuX2FkZCh7IHBhdGNoOiBwYXRjaE9yRG9jdW1lbnRJZC5zZXJpYWxpemUoKSB9KTtcbiAgICBpZiAoaXNCdWlsZGVyKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IHBhdGNoT3BzKG5ldyBQYXRjaChwYXRjaE9yRG9jdW1lbnRJZCwge30sIHRoaXMuI2NsaWVudCkpO1xuICAgICAgaWYgKCEocGF0Y2ggaW5zdGFuY2VvZiBQYXRjaCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZ1bmN0aW9uIHBhc3NlZCB0byBgcGF0Y2goKWAgbXVzdCByZXR1cm4gdGhlIHBhdGNoXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZCh7IHBhdGNoOiBwYXRjaC5zZXJpYWxpemUoKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FkZCh7IHBhdGNoOiB7IGlkOiBwYXRjaE9yRG9jdW1lbnRJZCwgLi4ucGF0Y2hPcHMgfSB9KTtcbiAgfVxufVxuY2xhc3MgT2JzZXJ2YWJsZVRyYW5zYWN0aW9uIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uIHtcbiAgI2NsaWVudDtcbiAgY29uc3RydWN0b3Iob3BlcmF0aW9ucywgY2xpZW50LCB0cmFuc2FjdGlvbklkKSB7XG4gICAgc3VwZXIob3BlcmF0aW9ucywgdHJhbnNhY3Rpb25JZCksIHRoaXMuI2NsaWVudCA9IGNsaWVudDtcbiAgfVxuICAvKipcbiAgICogQ2xvbmVzIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlVHJhbnNhY3Rpb24oWy4uLnRoaXMub3BlcmF0aW9uc10sIHRoaXMuI2NsaWVudCwgdGhpcy50cnhJZCk7XG4gIH1cbiAgY29tbWl0KG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuI2NsaWVudClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJObyBgY2xpZW50YCBwYXNzZWQgdG8gdHJhbnNhY3Rpb24sIGVpdGhlciBwcm92aWRlIG9uZSBvciBwYXNzIHRoZSB0cmFuc2FjdGlvbiB0byBhIGNsaWVudHMgYG11dGF0ZSgpYCBtZXRob2RcIlxuICAgICAgKTtcbiAgICByZXR1cm4gdGhpcy4jY2xpZW50Lm11dGF0ZShcbiAgICAgIHRoaXMuc2VyaWFsaXplKCksXG4gICAgICBPYmplY3QuYXNzaWduKHsgdHJhbnNhY3Rpb25JZDogdGhpcy50cnhJZCB9LCBkZWZhdWx0TXV0YXRlT3B0aW9ucywgb3B0aW9ucyB8fCB7fSlcbiAgICApO1xuICB9XG4gIHBhdGNoKHBhdGNoT3JEb2N1bWVudElkLCBwYXRjaE9wcykge1xuICAgIGNvbnN0IGlzQnVpbGRlciA9IHR5cGVvZiBwYXRjaE9wcyA9PSBcImZ1bmN0aW9uXCI7XG4gICAgaWYgKHR5cGVvZiBwYXRjaE9yRG9jdW1lbnRJZCAhPSBcInN0cmluZ1wiICYmIHBhdGNoT3JEb2N1bWVudElkIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVBhdGNoKVxuICAgICAgcmV0dXJuIHRoaXMuX2FkZCh7IHBhdGNoOiBwYXRjaE9yRG9jdW1lbnRJZC5zZXJpYWxpemUoKSB9KTtcbiAgICBpZiAoaXNCdWlsZGVyKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IHBhdGNoT3BzKG5ldyBPYnNlcnZhYmxlUGF0Y2gocGF0Y2hPckRvY3VtZW50SWQsIHt9LCB0aGlzLiNjbGllbnQpKTtcbiAgICAgIGlmICghKHBhdGNoIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVBhdGNoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZnVuY3Rpb24gcGFzc2VkIHRvIGBwYXRjaCgpYCBtdXN0IHJldHVybiB0aGUgcGF0Y2hcIik7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkKHsgcGF0Y2g6IHBhdGNoLnNlcmlhbGl6ZSgpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkKHsgcGF0Y2g6IHsgaWQ6IHBhdGNoT3JEb2N1bWVudElkLCAuLi5wYXRjaE9wcyB9IH0pO1xuICB9XG59XG5jb25zdCBwcm9qZWN0SGVhZGVyID0gXCJYLVNhbml0eS1Qcm9qZWN0LUlEXCI7XG5mdW5jdGlvbiByZXF1ZXN0T3B0aW9ucyhjb25maWcsIG92ZXJyaWRlcyA9IHt9KSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fSwgdG9rZW4gPSBvdmVycmlkZXMudG9rZW4gfHwgY29uZmlnLnRva2VuO1xuICB0b2tlbiAmJiAoaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWApLCAhb3ZlcnJpZGVzLnVzZUdsb2JhbEFwaSAmJiAhY29uZmlnLnVzZVByb2plY3RIb3N0bmFtZSAmJiBjb25maWcucHJvamVjdElkICYmIChoZWFkZXJzW3Byb2plY3RIZWFkZXJdID0gY29uZmlnLnByb2plY3RJZCk7XG4gIGNvbnN0IHdpdGhDcmVkZW50aWFscyA9ICEhKHR5cGVvZiBvdmVycmlkZXMud2l0aENyZWRlbnRpYWxzID4gXCJ1XCIgPyBjb25maWcudG9rZW4gfHwgY29uZmlnLndpdGhDcmVkZW50aWFscyA6IG92ZXJyaWRlcy53aXRoQ3JlZGVudGlhbHMpLCB0aW1lb3V0ID0gdHlwZW9mIG92ZXJyaWRlcy50aW1lb3V0ID4gXCJ1XCIgPyBjb25maWcudGltZW91dCA6IG92ZXJyaWRlcy50aW1lb3V0O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGVzLCB7XG4gICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgaGVhZGVycywgb3ZlcnJpZGVzLmhlYWRlcnMgfHwge30pLFxuICAgIHRpbWVvdXQ6IHR5cGVvZiB0aW1lb3V0ID4gXCJ1XCIgPyA1ICogNjAgKiAxZTMgOiB0aW1lb3V0LFxuICAgIHByb3h5OiBvdmVycmlkZXMucHJveHkgfHwgY29uZmlnLnByb3h5LFxuICAgIGpzb246ICEwLFxuICAgIHdpdGhDcmVkZW50aWFscyxcbiAgICBmZXRjaDogdHlwZW9mIG92ZXJyaWRlcy5mZXRjaCA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjb25maWcuZmV0Y2ggPT0gXCJvYmplY3RcIiA/IHsgLi4uY29uZmlnLmZldGNoLCAuLi5vdmVycmlkZXMuZmV0Y2ggfSA6IG92ZXJyaWRlcy5mZXRjaCB8fCBjb25maWcuZmV0Y2hcbiAgfSk7XG59XG5jb25zdCBlbmNvZGVRdWVyeVN0cmluZyA9ICh7XG4gIHF1ZXJ5LFxuICBwYXJhbXMgPSB7fSxcbiAgb3B0aW9ucyA9IHt9XG59KSA9PiB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKSwgeyB0YWcsIGluY2x1ZGVNdXRhdGlvbnMsIHJldHVyblF1ZXJ5LCAuLi5vcHRzIH0gPSBvcHRpb25zO1xuICB0YWcgJiYgc2VhcmNoUGFyYW1zLmFwcGVuZChcInRhZ1wiLCB0YWcpLCBzZWFyY2hQYXJhbXMuYXBwZW5kKFwicXVlcnlcIiwgcXVlcnkpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKVxuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoYCQke2tleX1gLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRzKSlcbiAgICB2YWx1ZSAmJiBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgYCR7dmFsdWV9YCk7XG4gIHJldHVybiByZXR1cm5RdWVyeSA9PT0gITEgJiYgc2VhcmNoUGFyYW1zLmFwcGVuZChcInJldHVyblF1ZXJ5XCIsIFwiZmFsc2VcIiksIGluY2x1ZGVNdXRhdGlvbnMgPT09ICExICYmIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmNsdWRlTXV0YXRpb25zXCIsIFwiZmFsc2VcIiksIGA/JHtzZWFyY2hQYXJhbXN9YDtcbn0sIGV4Y2x1ZGVGYWxzZXkgPSAocGFyYW0sIGRlZlZhbHVlKSA9PiBwYXJhbSA9PT0gITEgPyB2b2lkIDAgOiB0eXBlb2YgcGFyYW0gPiBcInVcIiA/IGRlZlZhbHVlIDogcGFyYW0sIGdldE11dGF0aW9uUXVlcnkgPSAob3B0aW9ucyA9IHt9KSA9PiAoe1xuICBkcnlSdW46IG9wdGlvbnMuZHJ5UnVuLFxuICByZXR1cm5JZHM6ICEwLFxuICByZXR1cm5Eb2N1bWVudHM6IGV4Y2x1ZGVGYWxzZXkob3B0aW9ucy5yZXR1cm5Eb2N1bWVudHMsICEwKSxcbiAgdmlzaWJpbGl0eTogb3B0aW9ucy52aXNpYmlsaXR5IHx8IFwic3luY1wiLFxuICBhdXRvR2VuZXJhdGVBcnJheUtleXM6IG9wdGlvbnMuYXV0b0dlbmVyYXRlQXJyYXlLZXlzLFxuICBza2lwQ3Jvc3NEYXRhc2V0UmVmZXJlbmNlVmFsaWRhdGlvbjogb3B0aW9ucy5za2lwQ3Jvc3NEYXRhc2V0UmVmZXJlbmNlVmFsaWRhdGlvblxufSksIGlzUmVzcG9uc2UgPSAoZXZlbnQpID0+IGV2ZW50LnR5cGUgPT09IFwicmVzcG9uc2VcIiwgZ2V0Qm9keSA9IChldmVudCkgPT4gZXZlbnQuYm9keSwgaW5kZXhCeSA9IChkb2NzLCBhdHRyKSA9PiBkb2NzLnJlZHVjZSgoaW5kZXhlZCwgZG9jKSA9PiAoaW5kZXhlZFthdHRyKGRvYyldID0gZG9jLCBpbmRleGVkKSwgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpLCBnZXRRdWVyeVNpemVMaW1pdCA9IDExMjY0O1xuZnVuY3Rpb24gX2ZldGNoKGNsaWVudCwgaHR0cFJlcXVlc3QsIF9zdGVnYSwgcXVlcnksIF9wYXJhbXMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHN0ZWdhID0gXCJzdGVnYVwiIGluIG9wdGlvbnMgPyB7XG4gICAgLi4uX3N0ZWdhIHx8IHt9LFxuICAgIC4uLnR5cGVvZiBvcHRpb25zLnN0ZWdhID09IFwiYm9vbGVhblwiID8geyBlbmFibGVkOiBvcHRpb25zLnN0ZWdhIH0gOiBvcHRpb25zLnN0ZWdhIHx8IHt9XG4gIH0gOiBfc3RlZ2EsIHBhcmFtcyA9IHN0ZWdhLmVuYWJsZWQgPyBzdGVnYUNsZWFuKF9wYXJhbXMpIDogX3BhcmFtcywgbWFwUmVzcG9uc2UgPSBvcHRpb25zLmZpbHRlclJlc3BvbnNlID09PSAhMSA/IChyZXMpID0+IHJlcyA6IChyZXMpID0+IHJlcy5yZXN1bHQsIHsgY2FjaGUsIG5leHQsIC4uLm9wdHMgfSA9IHtcbiAgICAvLyBPcHQgb3V0IG9mIHNldHRpbmcgYSBgc2lnbmFsYCBvbiBhbiBpbnRlcm5hbCBgZmV0Y2hgIGlmIG9uZSBpc24ndCBwcm92aWRlZC5cbiAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBpbiBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50cyB0byBhdm9pZCBvcHRpbmcgb3V0IG9mIFJlcXVlc3QgTWVtb2l6YXRpb24uXG4gICAgdXNlQWJvcnRTaWduYWw6IHR5cGVvZiBvcHRpb25zLnNpZ25hbCA8IFwidVwiLFxuICAgIC8vIFNldCBgcmVzdWx0U291cmNlTWFwJyB3aGVuIHN0ZWdhIGlzIGVuYWJsZWQsIGFzIGl0J3MgcmVxdWlyZWQgZm9yIGVuY29kaW5nLlxuICAgIHJlc3VsdFNvdXJjZU1hcDogc3RlZ2EuZW5hYmxlZCA/IFwid2l0aEtleUFycmF5U2VsZWN0b3JcIiA6IG9wdGlvbnMucmVzdWx0U291cmNlTWFwLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgLy8gRGVmYXVsdCB0byBub3QgcmV0dXJuaW5nIHRoZSBxdWVyeSwgdW5sZXNzIGBmaWx0ZXJSZXNwb25zZWAgaXMgYGZhbHNlYCxcbiAgICAvLyBvciBgcmV0dXJuUXVlcnlgIGlzIGV4cGxpY2l0bHkgc2V0LiBgdHJ1ZWAgaXMgdGhlIGRlZmF1bHQgaW4gQ29udGVudCBMYWtlLCBzbyBza2lwIGlmIHRydXRoeVxuICAgIHJldHVyblF1ZXJ5OiBvcHRpb25zLmZpbHRlclJlc3BvbnNlID09PSAhMSAmJiBvcHRpb25zLnJldHVyblF1ZXJ5ICE9PSAhMVxuICB9LCByZXFPcHRzID0gdHlwZW9mIGNhY2hlIDwgXCJ1XCIgfHwgdHlwZW9mIG5leHQgPCBcInVcIiA/IHsgLi4ub3B0cywgZmV0Y2g6IHsgY2FjaGUsIG5leHQgfSB9IDogb3B0cywgJHJlcXVlc3QgPSBfZGF0YVJlcXVlc3QoY2xpZW50LCBodHRwUmVxdWVzdCwgXCJxdWVyeVwiLCB7IHF1ZXJ5LCBwYXJhbXMgfSwgcmVxT3B0cyk7XG4gIHJldHVybiBzdGVnYS5lbmFibGVkID8gJHJlcXVlc3QucGlwZShcbiAgICBjb21iaW5lTGF0ZXN0V2l0aChcbiAgICAgIGZyb20oXG4gICAgICAgIGltcG9ydChcIi4vX2NodW5rcy1lcy9zdGVnYUVuY29kZVNvdXJjZU1hcC5qc1wiKS50aGVuKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbi5zdGVnYUVuY29kZVNvdXJjZU1hcCQxO1xuICAgICAgICB9KS50aGVuKFxuICAgICAgICAgICh7IHN0ZWdhRW5jb2RlU291cmNlTWFwIH0pID0+IHN0ZWdhRW5jb2RlU291cmNlTWFwXG4gICAgICAgIClcbiAgICAgIClcbiAgICApLFxuICAgIG1hcChcbiAgICAgIChbcmVzLCBzdGVnYUVuY29kZVNvdXJjZU1hcF0pID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3RlZ2FFbmNvZGVTb3VyY2VNYXAocmVzLnJlc3VsdCwgcmVzLnJlc3VsdFNvdXJjZU1hcCwgc3RlZ2EpO1xuICAgICAgICByZXR1cm4gbWFwUmVzcG9uc2UoeyAuLi5yZXMsIHJlc3VsdCB9KTtcbiAgICAgIH1cbiAgICApXG4gICkgOiAkcmVxdWVzdC5waXBlKG1hcChtYXBSZXNwb25zZSkpO1xufVxuZnVuY3Rpb24gX2dldERvY3VtZW50KGNsaWVudCwgaHR0cFJlcXVlc3QsIGlkLCBvcHRzID0ge30pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICB1cmk6IF9nZXREYXRhVXJsKGNsaWVudCwgXCJkb2NcIiwgaWQpLFxuICAgIGpzb246ICEwLFxuICAgIHRhZzogb3B0cy50YWcsXG4gICAgc2lnbmFsOiBvcHRzLnNpZ25hbFxuICB9O1xuICByZXR1cm4gX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIG9wdGlvbnMpLnBpcGUoXG4gICAgZmlsdGVyKGlzUmVzcG9uc2UpLFxuICAgIG1hcCgoZXZlbnQpID0+IGV2ZW50LmJvZHkuZG9jdW1lbnRzICYmIGV2ZW50LmJvZHkuZG9jdW1lbnRzWzBdKVxuICApO1xufVxuZnVuY3Rpb24gX2dldERvY3VtZW50cyhjbGllbnQsIGh0dHBSZXF1ZXN0LCBpZHMsIG9wdHMgPSB7fSkge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIHVyaTogX2dldERhdGFVcmwoY2xpZW50LCBcImRvY1wiLCBpZHMuam9pbihcIixcIikpLFxuICAgIGpzb246ICEwLFxuICAgIHRhZzogb3B0cy50YWcsXG4gICAgc2lnbmFsOiBvcHRzLnNpZ25hbFxuICB9O1xuICByZXR1cm4gX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIG9wdGlvbnMpLnBpcGUoXG4gICAgZmlsdGVyKGlzUmVzcG9uc2UpLFxuICAgIG1hcCgoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ZWQgPSBpbmRleEJ5KGV2ZW50LmJvZHkuZG9jdW1lbnRzIHx8IFtdLCAoZG9jKSA9PiBkb2MuX2lkKTtcbiAgICAgIHJldHVybiBpZHMubWFwKChpZCkgPT4gaW5kZXhlZFtpZF0gfHwgbnVsbCk7XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVJZk5vdEV4aXN0cyhjbGllbnQsIGh0dHBSZXF1ZXN0LCBkb2MsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlcXVpcmVEb2N1bWVudElkKFwiY3JlYXRlSWZOb3RFeGlzdHNcIiwgZG9jKSwgX2NyZWF0ZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBkb2MsIFwiY3JlYXRlSWZOb3RFeGlzdHNcIiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBfY3JlYXRlT3JSZXBsYWNlKGNsaWVudCwgaHR0cFJlcXVlc3QsIGRvYywgb3B0aW9ucykge1xuICByZXR1cm4gcmVxdWlyZURvY3VtZW50SWQoXCJjcmVhdGVPclJlcGxhY2VcIiwgZG9jKSwgX2NyZWF0ZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBkb2MsIFwiY3JlYXRlT3JSZXBsYWNlXCIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gX2RlbGV0ZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBzZWxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9kYXRhUmVxdWVzdChcbiAgICBjbGllbnQsXG4gICAgaHR0cFJlcXVlc3QsXG4gICAgXCJtdXRhdGVcIixcbiAgICB7IG11dGF0aW9uczogW3sgZGVsZXRlOiBnZXRTZWxlY3Rpb24oc2VsZWN0aW9uKSB9XSB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbmZ1bmN0aW9uIF9tdXRhdGUoY2xpZW50LCBodHRwUmVxdWVzdCwgbXV0YXRpb25zLCBvcHRpb25zKSB7XG4gIGxldCBtdXQ7XG4gIG11dGF0aW9ucyBpbnN0YW5jZW9mIFBhdGNoIHx8IG11dGF0aW9ucyBpbnN0YW5jZW9mIE9ic2VydmFibGVQYXRjaCA/IG11dCA9IHsgcGF0Y2g6IG11dGF0aW9ucy5zZXJpYWxpemUoKSB9IDogbXV0YXRpb25zIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24gfHwgbXV0YXRpb25zIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVRyYW5zYWN0aW9uID8gbXV0ID0gbXV0YXRpb25zLnNlcmlhbGl6ZSgpIDogbXV0ID0gbXV0YXRpb25zO1xuICBjb25zdCBtdXRzID0gQXJyYXkuaXNBcnJheShtdXQpID8gbXV0IDogW211dF0sIHRyYW5zYWN0aW9uSWQgPSBvcHRpb25zICYmIG9wdGlvbnMudHJhbnNhY3Rpb25JZCB8fCB2b2lkIDA7XG4gIHJldHVybiBfZGF0YVJlcXVlc3QoY2xpZW50LCBodHRwUmVxdWVzdCwgXCJtdXRhdGVcIiwgeyBtdXRhdGlvbnM6IG11dHMsIHRyYW5zYWN0aW9uSWQgfSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBfYWN0aW9uKGNsaWVudCwgaHR0cFJlcXVlc3QsIGFjdGlvbnMsIG9wdGlvbnMpIHtcbiAgY29uc3QgYWN0cyA9IEFycmF5LmlzQXJyYXkoYWN0aW9ucykgPyBhY3Rpb25zIDogW2FjdGlvbnNdLCB0cmFuc2FjdGlvbklkID0gb3B0aW9ucyAmJiBvcHRpb25zLnRyYW5zYWN0aW9uSWQgfHwgdm9pZCAwLCBza2lwQ3Jvc3NEYXRhc2V0UmVmZXJlbmNlVmFsaWRhdGlvbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwQ3Jvc3NEYXRhc2V0UmVmZXJlbmNlVmFsaWRhdGlvbiB8fCB2b2lkIDAsIGRyeVJ1biA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kcnlSdW4gfHwgdm9pZCAwO1xuICByZXR1cm4gX2RhdGFSZXF1ZXN0KFxuICAgIGNsaWVudCxcbiAgICBodHRwUmVxdWVzdCxcbiAgICBcImFjdGlvbnNcIixcbiAgICB7IGFjdGlvbnM6IGFjdHMsIHRyYW5zYWN0aW9uSWQsIHNraXBDcm9zc0RhdGFzZXRSZWZlcmVuY2VWYWxpZGF0aW9uLCBkcnlSdW4gfSxcbiAgICBvcHRpb25zXG4gICk7XG59XG5mdW5jdGlvbiBfZGF0YVJlcXVlc3QoY2xpZW50LCBodHRwUmVxdWVzdCwgZW5kcG9pbnQsIGJvZHksIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBpc011dGF0aW9uID0gZW5kcG9pbnQgPT09IFwibXV0YXRlXCIsIGlzQWN0aW9uID0gZW5kcG9pbnQgPT09IFwiYWN0aW9uc1wiLCBpc1F1ZXJ5ID0gZW5kcG9pbnQgPT09IFwicXVlcnlcIiwgc3RyUXVlcnkgPSBpc011dGF0aW9uIHx8IGlzQWN0aW9uID8gXCJcIiA6IGVuY29kZVF1ZXJ5U3RyaW5nKGJvZHkpLCB1c2VHZXQgPSAhaXNNdXRhdGlvbiAmJiAhaXNBY3Rpb24gJiYgc3RyUXVlcnkubGVuZ3RoIDwgZ2V0UXVlcnlTaXplTGltaXQsIHN0cmluZ1F1ZXJ5ID0gdXNlR2V0ID8gc3RyUXVlcnkgOiBcIlwiLCByZXR1cm5GaXJzdCA9IG9wdGlvbnMucmV0dXJuRmlyc3QsIHsgdGltZW91dCwgdG9rZW4sIHRhZywgaGVhZGVycywgcmV0dXJuUXVlcnksIGxhc3RMaXZlRXZlbnRJZCwgY2FjaGVNb2RlIH0gPSBvcHRpb25zLCB1cmkgPSBfZ2V0RGF0YVVybChjbGllbnQsIGVuZHBvaW50LCBzdHJpbmdRdWVyeSksIHJlcU9wdGlvbnMgPSB7XG4gICAgbWV0aG9kOiB1c2VHZXQgPyBcIkdFVFwiIDogXCJQT1NUXCIsXG4gICAgdXJpLFxuICAgIGpzb246ICEwLFxuICAgIGJvZHk6IHVzZUdldCA/IHZvaWQgMCA6IGJvZHksXG4gICAgcXVlcnk6IGlzTXV0YXRpb24gJiYgZ2V0TXV0YXRpb25RdWVyeShvcHRpb25zKSxcbiAgICB0aW1lb3V0LFxuICAgIGhlYWRlcnMsXG4gICAgdG9rZW4sXG4gICAgdGFnLFxuICAgIHJldHVyblF1ZXJ5LFxuICAgIHBlcnNwZWN0aXZlOiBvcHRpb25zLnBlcnNwZWN0aXZlLFxuICAgIHJlc3VsdFNvdXJjZU1hcDogb3B0aW9ucy5yZXN1bHRTb3VyY2VNYXAsXG4gICAgbGFzdExpdmVFdmVudElkOiBBcnJheS5pc0FycmF5KGxhc3RMaXZlRXZlbnRJZCkgPyBsYXN0TGl2ZUV2ZW50SWRbMF0gOiBsYXN0TGl2ZUV2ZW50SWQsXG4gICAgY2FjaGVNb2RlLFxuICAgIGNhblVzZUNkbjogaXNRdWVyeSxcbiAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgIGZldGNoOiBvcHRpb25zLmZldGNoLFxuICAgIHVzZUFib3J0U2lnbmFsOiBvcHRpb25zLnVzZUFib3J0U2lnbmFsLFxuICAgIHVzZUNkbjogb3B0aW9ucy51c2VDZG5cbiAgfTtcbiAgcmV0dXJuIF9yZXF1ZXN0T2JzZXJ2YWJsZShjbGllbnQsIGh0dHBSZXF1ZXN0LCByZXFPcHRpb25zKS5waXBlKFxuICAgIGZpbHRlcihpc1Jlc3BvbnNlKSxcbiAgICBtYXAoZ2V0Qm9keSksXG4gICAgbWFwKChyZXMpID0+IHtcbiAgICAgIGlmICghaXNNdXRhdGlvbilcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSByZXMucmVzdWx0cyB8fCBbXTtcbiAgICAgIGlmIChvcHRpb25zLnJldHVybkRvY3VtZW50cylcbiAgICAgICAgcmV0dXJuIHJldHVybkZpcnN0ID8gcmVzdWx0c1swXSAmJiByZXN1bHRzWzBdLmRvY3VtZW50IDogcmVzdWx0cy5tYXAoKG11dCkgPT4gbXV0LmRvY3VtZW50KTtcbiAgICAgIGNvbnN0IGtleSA9IHJldHVybkZpcnN0ID8gXCJkb2N1bWVudElkXCIgOiBcImRvY3VtZW50SWRzXCIsIGlkcyA9IHJldHVybkZpcnN0ID8gcmVzdWx0c1swXSAmJiByZXN1bHRzWzBdLmlkIDogcmVzdWx0cy5tYXAoKG11dCkgPT4gbXV0LmlkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYW5zYWN0aW9uSWQ6IHJlcy50cmFuc2FjdGlvbklkLFxuICAgICAgICByZXN1bHRzLFxuICAgICAgICBba2V5XTogaWRzXG4gICAgICB9O1xuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiBfY3JlYXRlKGNsaWVudCwgaHR0cFJlcXVlc3QsIGRvYywgb3AsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBtdXRhdGlvbiA9IHsgW29wXTogZG9jIH0sIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgcmV0dXJuRmlyc3Q6ICEwLCByZXR1cm5Eb2N1bWVudHM6ICEwIH0sIG9wdGlvbnMpO1xuICByZXR1cm4gX2RhdGFSZXF1ZXN0KGNsaWVudCwgaHR0cFJlcXVlc3QsIFwibXV0YXRlXCIsIHsgbXV0YXRpb25zOiBbbXV0YXRpb25dIH0sIG9wdHMpO1xufVxuZnVuY3Rpb24gX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgY29uc3QgdXJpID0gb3B0aW9ucy51cmwgfHwgb3B0aW9ucy51cmksIGNvbmZpZyA9IGNsaWVudC5jb25maWcoKSwgY2FuVXNlQ2RuID0gdHlwZW9mIG9wdGlvbnMuY2FuVXNlQ2RuID4gXCJ1XCIgPyBbXCJHRVRcIiwgXCJIRUFEXCJdLmluZGV4T2Yob3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIikgPj0gMCAmJiB1cmkuaW5kZXhPZihcIi9kYXRhL1wiKSA9PT0gMCA6IG9wdGlvbnMuY2FuVXNlQ2RuO1xuICBsZXQgdXNlQ2RuID0gKG9wdGlvbnMudXNlQ2RuID8/IGNvbmZpZy51c2VDZG4pICYmIGNhblVzZUNkbjtcbiAgY29uc3QgdGFnID0gb3B0aW9ucy50YWcgJiYgY29uZmlnLnJlcXVlc3RUYWdQcmVmaXggPyBbY29uZmlnLnJlcXVlc3RUYWdQcmVmaXgsIG9wdGlvbnMudGFnXS5qb2luKFwiLlwiKSA6IG9wdGlvbnMudGFnIHx8IGNvbmZpZy5yZXF1ZXN0VGFnUHJlZml4O1xuICBpZiAodGFnICYmIG9wdGlvbnMudGFnICE9PSBudWxsICYmIChvcHRpb25zLnF1ZXJ5ID0geyB0YWc6IHJlcXVlc3RUYWcodGFnKSwgLi4ub3B0aW9ucy5xdWVyeSB9KSwgW1wiR0VUXCIsIFwiSEVBRFwiLCBcIlBPU1RcIl0uaW5kZXhPZihvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiKSA+PSAwICYmIHVyaS5pbmRleE9mKFwiL2RhdGEvcXVlcnkvXCIpID09PSAwKSB7XG4gICAgY29uc3QgcmVzdWx0U291cmNlTWFwID0gb3B0aW9ucy5yZXN1bHRTb3VyY2VNYXAgPz8gY29uZmlnLnJlc3VsdFNvdXJjZU1hcDtcbiAgICByZXN1bHRTb3VyY2VNYXAgIT09IHZvaWQgMCAmJiByZXN1bHRTb3VyY2VNYXAgIT09ICExICYmIChvcHRpb25zLnF1ZXJ5ID0geyByZXN1bHRTb3VyY2VNYXAsIC4uLm9wdGlvbnMucXVlcnkgfSk7XG4gICAgY29uc3QgcGVyc3BlY3RpdmVPcHRpb24gPSBvcHRpb25zLnBlcnNwZWN0aXZlIHx8IGNvbmZpZy5wZXJzcGVjdGl2ZTtcbiAgICB0eXBlb2YgcGVyc3BlY3RpdmVPcHRpb24gPCBcInVcIiAmJiAodmFsaWRhdGVBcGlQZXJzcGVjdGl2ZShwZXJzcGVjdGl2ZU9wdGlvbiksIG9wdGlvbnMucXVlcnkgPSB7XG4gICAgICBwZXJzcGVjdGl2ZTogQXJyYXkuaXNBcnJheShwZXJzcGVjdGl2ZU9wdGlvbikgPyBwZXJzcGVjdGl2ZU9wdGlvbi5qb2luKFwiLFwiKSA6IHBlcnNwZWN0aXZlT3B0aW9uLFxuICAgICAgLi4ub3B0aW9ucy5xdWVyeVxuICAgIH0sIHBlcnNwZWN0aXZlT3B0aW9uID09PSBcInByZXZpZXdEcmFmdHNcIiAmJiB1c2VDZG4gJiYgKHVzZUNkbiA9ICExLCBwcmludENkblByZXZpZXdEcmFmdHNXYXJuaW5nKCkpKSwgb3B0aW9ucy5sYXN0TGl2ZUV2ZW50SWQgJiYgKG9wdGlvbnMucXVlcnkgPSB7IC4uLm9wdGlvbnMucXVlcnksIGxhc3RMaXZlRXZlbnRJZDogb3B0aW9ucy5sYXN0TGl2ZUV2ZW50SWQgfSksIG9wdGlvbnMucmV0dXJuUXVlcnkgPT09ICExICYmIChvcHRpb25zLnF1ZXJ5ID0geyByZXR1cm5RdWVyeTogXCJmYWxzZVwiLCAuLi5vcHRpb25zLnF1ZXJ5IH0pLCB1c2VDZG4gJiYgb3B0aW9ucy5jYWNoZU1vZGUgPT0gXCJub1N0YWxlXCIgJiYgKG9wdGlvbnMucXVlcnkgPSB7IGNhY2hlTW9kZTogXCJub1N0YWxlXCIsIC4uLm9wdGlvbnMucXVlcnkgfSk7XG4gIH1cbiAgY29uc3QgcmVxT3B0aW9ucyA9IHJlcXVlc3RPcHRpb25zKFxuICAgIGNvbmZpZyxcbiAgICBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICB1cmw6IF9nZXRVcmwoY2xpZW50LCB1cmksIHVzZUNkbilcbiAgICB9KVxuICApLCByZXF1ZXN0ID0gbmV3IE9ic2VydmFibGUoXG4gICAgKHN1YnNjcmliZXIpID0+IGh0dHBSZXF1ZXN0KHJlcU9wdGlvbnMsIGNvbmZpZy5yZXF1ZXN0ZXIpLnN1YnNjcmliZShzdWJzY3JpYmVyKVxuICApO1xuICByZXR1cm4gb3B0aW9ucy5zaWduYWwgPyByZXF1ZXN0LnBpcGUoX3dpdGhBYm9ydFNpZ25hbChvcHRpb25zLnNpZ25hbCkpIDogcmVxdWVzdDtcbn1cbmZ1bmN0aW9uIF9yZXF1ZXN0KGNsaWVudCwgaHR0cFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9yZXF1ZXN0T2JzZXJ2YWJsZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBvcHRpb25zKS5waXBlKFxuICAgIGZpbHRlcigoZXZlbnQpID0+IGV2ZW50LnR5cGUgPT09IFwicmVzcG9uc2VcIiksXG4gICAgbWFwKChldmVudCkgPT4gZXZlbnQuYm9keSlcbiAgKTtcbn1cbmZ1bmN0aW9uIF9nZXREYXRhVXJsKGNsaWVudCwgb3BlcmF0aW9uLCBwYXRoKSB7XG4gIGNvbnN0IGNvbmZpZyA9IGNsaWVudC5jb25maWcoKSwgY2F0YWxvZyA9IGhhc0RhdGFzZXQoY29uZmlnKSwgYmFzZVVyaSA9IGAvJHtvcGVyYXRpb259LyR7Y2F0YWxvZ31gO1xuICByZXR1cm4gYC9kYXRhJHtwYXRoID8gYCR7YmFzZVVyaX0vJHtwYXRofWAgOiBiYXNlVXJpfWAucmVwbGFjZSgvXFwvKCR8XFw/KS8sIFwiJDFcIik7XG59XG5mdW5jdGlvbiBfZ2V0VXJsKGNsaWVudCwgdXJpLCBjYW5Vc2VDZG4gPSAhMSkge1xuICBjb25zdCB7IHVybCwgY2RuVXJsIH0gPSBjbGllbnQuY29uZmlnKCk7XG4gIHJldHVybiBgJHtjYW5Vc2VDZG4gPyBjZG5VcmwgOiB1cmx9LyR7dXJpLnJlcGxhY2UoL15cXC8vLCBcIlwiKX1gO1xufVxuZnVuY3Rpb24gX3dpdGhBYm9ydFNpZ25hbChzaWduYWwpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gICAgY29uc3QgYWJvcnQgPSAoKSA9PiBvYnNlcnZlci5lcnJvcihfY3JlYXRlQWJvcnRFcnJvcihzaWduYWwpKTtcbiAgICBpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBhYm9ydCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBpbnB1dC5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xuICAgIHJldHVybiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0KSwgKCkgPT4ge1xuICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydCksIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0pO1xufVxuY29uc3QgaXNEb21FeGNlcHRpb25TdXBwb3J0ZWQgPSAhIWdsb2JhbFRoaXMuRE9NRXhjZXB0aW9uO1xuZnVuY3Rpb24gX2NyZWF0ZUFib3J0RXJyb3Ioc2lnbmFsKSB7XG4gIGlmIChpc0RvbUV4Y2VwdGlvblN1cHBvcnRlZClcbiAgICByZXR1cm4gbmV3IERPTUV4Y2VwdGlvbihzaWduYWw/LnJlYXNvbiA/PyBcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuXCIsIFwiQWJvcnRFcnJvclwiKTtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3Ioc2lnbmFsPy5yZWFzb24gPz8gXCJUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLlwiKTtcbiAgcmV0dXJuIGVycm9yLm5hbWUgPSBcIkFib3J0RXJyb3JcIiwgZXJyb3I7XG59XG5jbGFzcyBPYnNlcnZhYmxlQXNzZXRzQ2xpZW50IHtcbiAgI2NsaWVudDtcbiAgI2h0dHBSZXF1ZXN0O1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGh0dHBSZXF1ZXN0KSB7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0O1xuICB9XG4gIHVwbG9hZChhc3NldFR5cGUsIGJvZHksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX3VwbG9hZCh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCBhc3NldFR5cGUsIGJvZHksIG9wdGlvbnMpO1xuICB9XG59XG5jbGFzcyBBc3NldHNDbGllbnQge1xuICAjY2xpZW50O1xuICAjaHR0cFJlcXVlc3Q7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG4gIH1cbiAgdXBsb2FkKGFzc2V0VHlwZSwgYm9keSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG9ic2VydmFibGUyID0gX3VwbG9hZCh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCBhc3NldFR5cGUsIGJvZHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgb2JzZXJ2YWJsZTIucGlwZShcbiAgICAgICAgZmlsdGVyKChldmVudCkgPT4gZXZlbnQudHlwZSA9PT0gXCJyZXNwb25zZVwiKSxcbiAgICAgICAgbWFwKFxuICAgICAgICAgIChldmVudCkgPT4gZXZlbnQuYm9keS5kb2N1bWVudFxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gX3VwbG9hZChjbGllbnQsIGh0dHBSZXF1ZXN0LCBhc3NldFR5cGUsIGJvZHksIG9wdHMgPSB7fSkge1xuICB2YWxpZGF0ZUFzc2V0VHlwZShhc3NldFR5cGUpO1xuICBsZXQgbWV0YSA9IG9wdHMuZXh0cmFjdCB8fCB2b2lkIDA7XG4gIG1ldGEgJiYgIW1ldGEubGVuZ3RoICYmIChtZXRhID0gW1wibm9uZVwiXSk7XG4gIGNvbnN0IGRhdGFzZXQyID0gaGFzRGF0YXNldChjbGllbnQuY29uZmlnKCkpLCBhc3NldEVuZHBvaW50ID0gYXNzZXRUeXBlID09PSBcImltYWdlXCIgPyBcImltYWdlc1wiIDogXCJmaWxlc1wiLCBvcHRpb25zID0gb3B0aW9uc0Zyb21GaWxlKG9wdHMsIGJvZHkpLCB7IHRhZywgbGFiZWwsIHRpdGxlLCBkZXNjcmlwdGlvbiwgY3JlZGl0TGluZSwgZmlsZW5hbWUsIHNvdXJjZSB9ID0gb3B0aW9ucywgcXVlcnkgPSB7XG4gICAgbGFiZWwsXG4gICAgdGl0bGUsXG4gICAgZGVzY3JpcHRpb24sXG4gICAgZmlsZW5hbWUsXG4gICAgbWV0YSxcbiAgICBjcmVkaXRMaW5lXG4gIH07XG4gIHJldHVybiBzb3VyY2UgJiYgKHF1ZXJ5LnNvdXJjZUlkID0gc291cmNlLmlkLCBxdWVyeS5zb3VyY2VOYW1lID0gc291cmNlLm5hbWUsIHF1ZXJ5LnNvdXJjZVVybCA9IHNvdXJjZS51cmwpLCBfcmVxdWVzdE9ic2VydmFibGUoY2xpZW50LCBodHRwUmVxdWVzdCwge1xuICAgIHRhZyxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCB8fCAwLFxuICAgIHVyaTogYC9hc3NldHMvJHthc3NldEVuZHBvaW50fS8ke2RhdGFzZXQyfWAsXG4gICAgaGVhZGVyczogb3B0aW9ucy5jb250ZW50VHlwZSA/IHsgXCJDb250ZW50LVR5cGVcIjogb3B0aW9ucy5jb250ZW50VHlwZSB9IDoge30sXG4gICAgcXVlcnksXG4gICAgYm9keVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9wdGlvbnNGcm9tRmlsZShvcHRzLCBmaWxlKSB7XG4gIHJldHVybiB0eXBlb2YgRmlsZSA+IFwidVwiIHx8ICEoZmlsZSBpbnN0YW5jZW9mIEZpbGUpID8gb3B0cyA6IE9iamVjdC5hc3NpZ24oXG4gICAge1xuICAgICAgZmlsZW5hbWU6IG9wdHMucHJlc2VydmVGaWxlbmFtZSA9PT0gITEgPyB2b2lkIDAgOiBmaWxlLm5hbWUsXG4gICAgICBjb250ZW50VHlwZTogZmlsZS50eXBlXG4gICAgfSxcbiAgICBvcHRzXG4gICk7XG59XG52YXIgZGVmYXVsdHMgPSAob2JqLCBkZWZhdWx0czIpID0+IE9iamVjdC5rZXlzKGRlZmF1bHRzMikuY29uY2F0KE9iamVjdC5rZXlzKG9iaikpLnJlZHVjZSgodGFyZ2V0LCBwcm9wKSA9PiAodGFyZ2V0W3Byb3BdID0gdHlwZW9mIG9ialtwcm9wXSA+IFwidVwiID8gZGVmYXVsdHMyW3Byb3BdIDogb2JqW3Byb3BdLCB0YXJnZXQpLCB7fSk7XG5jb25zdCBwaWNrID0gKG9iaiwgcHJvcHMpID0+IHByb3BzLnJlZHVjZSgoc2VsZWN0aW9uLCBwcm9wKSA9PiAodHlwZW9mIG9ialtwcm9wXSA+IFwidVwiIHx8IChzZWxlY3Rpb25bcHJvcF0gPSBvYmpbcHJvcF0pLCBzZWxlY3Rpb24pLCB7fSksIE1BWF9VUkxfTEVOR1RIID0gMTQ4MDAsIHBvc3NpYmxlT3B0aW9ucyA9IFtcbiAgXCJpbmNsdWRlUHJldmlvdXNSZXZpc2lvblwiLFxuICBcImluY2x1ZGVSZXN1bHRcIixcbiAgXCJpbmNsdWRlTXV0YXRpb25zXCIsXG4gIFwidmlzaWJpbGl0eVwiLFxuICBcImVmZmVjdEZvcm1hdFwiLFxuICBcInRhZ1wiXG5dLCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgaW5jbHVkZVJlc3VsdDogITBcbn07XG5mdW5jdGlvbiBfbGlzdGVuKHF1ZXJ5LCBwYXJhbXMsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IHVybCwgdG9rZW4sIHdpdGhDcmVkZW50aWFscywgcmVxdWVzdFRhZ1ByZWZpeCB9ID0gdGhpcy5jb25maWcoKSwgdGFnID0gb3B0cy50YWcgJiYgcmVxdWVzdFRhZ1ByZWZpeCA/IFtyZXF1ZXN0VGFnUHJlZml4LCBvcHRzLnRhZ10uam9pbihcIi5cIikgOiBvcHRzLnRhZywgb3B0aW9ucyA9IHsgLi4uZGVmYXVsdHMob3B0cywgZGVmYXVsdE9wdGlvbnMpLCB0YWcgfSwgbGlzdGVuT3B0cyA9IHBpY2sob3B0aW9ucywgcG9zc2libGVPcHRpb25zKSwgcXMgPSBlbmNvZGVRdWVyeVN0cmluZyh7IHF1ZXJ5LCBwYXJhbXMsIG9wdGlvbnM6IHsgdGFnLCAuLi5saXN0ZW5PcHRzIH0gfSksIHVyaSA9IGAke3VybH0ke19nZXREYXRhVXJsKHRoaXMsIFwibGlzdGVuXCIsIHFzKX1gO1xuICBpZiAodXJpLmxlbmd0aCA+IE1BWF9VUkxfTEVOR1RIKVxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IG9ic2VydmVyLmVycm9yKG5ldyBFcnJvcihcIlF1ZXJ5IHRvbyBsYXJnZSBmb3IgbGlzdGVuZXJcIikpKTtcbiAgY29uc3QgbGlzdGVuRm9yID0gb3B0aW9ucy5ldmVudHMgPyBvcHRpb25zLmV2ZW50cyA6IFtcIm11dGF0aW9uXCJdLCBzaG91bGRFbWl0UmVjb25uZWN0ID0gbGlzdGVuRm9yLmluZGV4T2YoXCJyZWNvbm5lY3RcIikgIT09IC0xLCBlc09wdGlvbnMgPSB7fTtcbiAgcmV0dXJuICh0b2tlbiB8fCB3aXRoQ3JlZGVudGlhbHMpICYmIChlc09wdGlvbnMud2l0aENyZWRlbnRpYWxzID0gITApLCB0b2tlbiAmJiAoZXNPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgfSksIG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgIGxldCBlcywgcmVjb25uZWN0VGltZXIsIHN0b3BwZWQgPSAhMSwgdW5zdWJzY3JpYmVkID0gITE7XG4gICAgb3BlbigpO1xuICAgIGZ1bmN0aW9uIG9uRXJyb3IoKSB7XG4gICAgICBzdG9wcGVkIHx8IChlbWl0UmVjb25uZWN0KCksICFzdG9wcGVkICYmIGVzLnJlYWR5U3RhdGUgPT09IGVzLkNMT1NFRCAmJiAodW5zdWJzY3JpYmUoKSwgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVyKSwgcmVjb25uZWN0VGltZXIgPSBzZXRUaW1lb3V0KG9wZW4sIDEwMCkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25DaGFubmVsRXJyb3IoZXJyKSB7XG4gICAgICBvYnNlcnZlci5lcnJvcihjb29lcmNlRXJyb3IoZXJyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTWVzc2FnZShldnQpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gcGFyc2VFdmVudCQxKGV2dCk7XG4gICAgICByZXR1cm4gZXZlbnQgaW5zdGFuY2VvZiBFcnJvciA/IG9ic2VydmVyLmVycm9yKGV2ZW50KSA6IG9ic2VydmVyLm5leHQoZXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkRpc2Nvbm5lY3QoKSB7XG4gICAgICBzdG9wcGVkID0gITAsIHVuc3Vic2NyaWJlKCksIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgZXMgJiYgKGVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKSwgZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5uZWxFcnJvclwiLCBvbkNoYW5uZWxFcnJvciksIGVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkaXNjb25uZWN0XCIsIG9uRGlzY29ubmVjdCksIGxpc3RlbkZvci5mb3JFYWNoKCh0eXBlKSA9PiBlcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIG9uTWVzc2FnZSkpLCBlcy5jbG9zZSgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW1pdFJlY29ubmVjdCgpIHtcbiAgICAgIHNob3VsZEVtaXRSZWNvbm5lY3QgJiYgb2JzZXJ2ZXIubmV4dCh7IHR5cGU6IFwicmVjb25uZWN0XCIgfSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldEV2ZW50U291cmNlKCkge1xuICAgICAgY29uc3QgeyBkZWZhdWx0OiBFdmVudFNvdXJjZTIgfSA9IGF3YWl0IGltcG9ydChcIkBzYW5pdHkvZXZlbnRzb3VyY2VcIik7XG4gICAgICBpZiAodW5zdWJzY3JpYmVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBldnMgPSBuZXcgRXZlbnRTb3VyY2UyKHVyaSwgZXNPcHRpb25zKTtcbiAgICAgIHJldHVybiBldnMuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpLCBldnMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5uZWxFcnJvclwiLCBvbkNoYW5uZWxFcnJvciksIGV2cy5hZGRFdmVudExpc3RlbmVyKFwiZGlzY29ubmVjdFwiLCBvbkRpc2Nvbm5lY3QpLCBsaXN0ZW5Gb3IuZm9yRWFjaCgodHlwZSkgPT4gZXZzLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgb25NZXNzYWdlKSksIGV2cztcbiAgICB9XG4gICAgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgIGdldEV2ZW50U291cmNlKCkudGhlbigoZXZlbnRTb3VyY2UpID0+IHtcbiAgICAgICAgZXZlbnRTb3VyY2UgJiYgKGVzID0gZXZlbnRTb3VyY2UsIHVuc3Vic2NyaWJlZCAmJiB1bnN1YnNjcmliZSgpKTtcbiAgICAgIH0pLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IocmVhc29uKSwgc3RvcCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBzdG9wcGVkID0gITAsIHVuc3Vic2NyaWJlKCksIHVuc3Vic2NyaWJlZCA9ICEwO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcDtcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZUV2ZW50JDEoZXZlbnQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YSAmJiBKU09OLnBhcnNlKGV2ZW50LmRhdGEpIHx8IHt9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgdHlwZTogZXZlbnQudHlwZSB9LCBkYXRhKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxufVxuZnVuY3Rpb24gY29vZXJjZUVycm9yKGVycikge1xuICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgcmV0dXJuIGVycjtcbiAgY29uc3QgZXZ0ID0gcGFyc2VFdmVudCQxKGVycik7XG4gIHJldHVybiBldnQgaW5zdGFuY2VvZiBFcnJvciA/IGV2dCA6IG5ldyBFcnJvcihleHRyYWN0RXJyb3JNZXNzYWdlKGV2dCkpO1xufVxuZnVuY3Rpb24gZXh0cmFjdEVycm9yTWVzc2FnZShlcnIpIHtcbiAgcmV0dXJuIGVyci5lcnJvciA/IGVyci5lcnJvci5kZXNjcmlwdGlvbiA/IGVyci5lcnJvci5kZXNjcmlwdGlvbiA6IHR5cGVvZiBlcnIuZXJyb3IgPT0gXCJzdHJpbmdcIiA/IGVyci5lcnJvciA6IEpTT04uc3RyaW5naWZ5KGVyci5lcnJvciwgbnVsbCwgMikgOiBlcnIubWVzc2FnZSB8fCBcIlVua25vd24gbGlzdGVuZXIgZXJyb3JcIjtcbn1cbmNvbnN0IHJlcXVpcmVkQXBpVmVyc2lvbiA9IFwiMjAyMS0wMy0yNlwiO1xuY2xhc3MgTGl2ZUNsaWVudCB7XG4gICNjbGllbnQ7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudDtcbiAgfVxuICAvKipcbiAgICogUmVxdWlyZXMgYGFwaVZlcnNpb25gIHRvIGJlIGAyMDIxLTAzLTI2YCBvciBsYXRlci5cbiAgICovXG4gIGV2ZW50cyh7XG4gICAgaW5jbHVkZURyYWZ0cyA9ICExLFxuICAgIHRhZzogX3RhZ1xuICB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBwcm9qZWN0SWQ6IHByb2plY3RJZDIsXG4gICAgICBhcGlWZXJzaW9uOiBfYXBpVmVyc2lvbixcbiAgICAgIHRva2VuLFxuICAgICAgd2l0aENyZWRlbnRpYWxzLFxuICAgICAgcmVxdWVzdFRhZ1ByZWZpeFxuICAgIH0gPSB0aGlzLiNjbGllbnQuY29uZmlnKCksIGFwaVZlcnNpb24gPSBfYXBpVmVyc2lvbi5yZXBsYWNlKC9edi8sIFwiXCIpO1xuICAgIGlmIChhcGlWZXJzaW9uICE9PSBcIlhcIiAmJiBhcGlWZXJzaW9uIDwgcmVxdWlyZWRBcGlWZXJzaW9uKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIGxpdmUgZXZlbnRzIEFQSSByZXF1aXJlcyBBUEkgdmVyc2lvbiAke3JlcXVpcmVkQXBpVmVyc2lvbn0gb3IgbGF0ZXIuIFRoZSBjdXJyZW50IEFQSSB2ZXJzaW9uIGlzICR7YXBpVmVyc2lvbn0uIFBsZWFzZSB1cGRhdGUgeW91ciBBUEkgdmVyc2lvbiB0byB1c2UgdGhpcyBmZWF0dXJlLmBcbiAgICAgICk7XG4gICAgaWYgKGluY2x1ZGVEcmFmdHMgJiYgIXRva2VuICYmICF3aXRoQ3JlZGVudGlhbHMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVGhlIGxpdmUgZXZlbnRzIEFQSSByZXF1aXJlcyBhIHRva2VuIG9yIHdpdGhDcmVkZW50aWFscyB3aGVuICdpbmNsdWRlRHJhZnRzOiB0cnVlJy4gUGxlYXNlIHVwZGF0ZSB5b3VyIGNsaWVudCBjb25maWd1cmF0aW9uLiBUaGUgdG9rZW4gc2hvdWxkIGhhdmUgdGhlIGxvd2VzdCBwb3NzaWJsZSBhY2Nlc3Mgcm9sZS5cIlxuICAgICAgKTtcbiAgICBpZiAoaW5jbHVkZURyYWZ0cyAmJiBhcGlWZXJzaW9uICE9PSBcIlhcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaGUgbGl2ZSBldmVudHMgQVBJIHJlcXVpcmVzIEFQSSB2ZXJzaW9uIFggd2hlbiAnaW5jbHVkZURyYWZ0czogdHJ1ZScuIFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBvciBldmVuIGJlIHJlbW92ZWQuXCJcbiAgICAgICk7XG4gICAgY29uc3QgcGF0aCA9IF9nZXREYXRhVXJsKHRoaXMuI2NsaWVudCwgXCJsaXZlL2V2ZW50c1wiKSwgdXJsID0gbmV3IFVSTCh0aGlzLiNjbGllbnQuZ2V0VXJsKHBhdGgsICExKSksIHRhZyA9IF90YWcgJiYgcmVxdWVzdFRhZ1ByZWZpeCA/IFtyZXF1ZXN0VGFnUHJlZml4LCBfdGFnXS5qb2luKFwiLlwiKSA6IF90YWc7XG4gICAgdGFnICYmIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwidGFnXCIsIHRhZyksIGluY2x1ZGVEcmFmdHMgJiYgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJpbmNsdWRlRHJhZnRzXCIsIFwidHJ1ZVwiKTtcbiAgICBjb25zdCBsaXN0ZW5Gb3IgPSBbXCJyZXN0YXJ0XCIsIFwibWVzc2FnZVwiLCBcIndlbGNvbWVcIiwgXCJyZWNvbm5lY3RcIl0sIGVzT3B0aW9ucyA9IHt9O1xuICAgIHJldHVybiBpbmNsdWRlRHJhZnRzICYmIHRva2VuICYmIChlc09wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgfSksIGluY2x1ZGVEcmFmdHMgJiYgd2l0aENyZWRlbnRpYWxzICYmIChlc09wdGlvbnMud2l0aENyZWRlbnRpYWxzID0gITApLCBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgIGxldCBlcywgcmVjb25uZWN0VGltZXIsIHN0b3BwZWQgPSAhMSwgdW5zdWJzY3JpYmVkID0gITE7XG4gICAgICBvcGVuKCk7XG4gICAgICBmdW5jdGlvbiBvbkVycm9yKGV2dCkge1xuICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gZXZ0KSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHBhcnNlRXZlbnQoZXZ0KTtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKG5ldyBFcnJvcihldmVudC5tZXNzYWdlLCB7IGNhdXNlOiBldmVudCB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVzLnJlYWR5U3RhdGUgPT09IGVzLkNMT1NFRCAmJiAodW5zdWJzY3JpYmUoKSwgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVyKSwgcmVjb25uZWN0VGltZXIgPSBzZXRUaW1lb3V0KG9wZW4sIDEwMCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvbk1lc3NhZ2UoZXZ0KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gcGFyc2VFdmVudChldnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQgaW5zdGFuY2VvZiBFcnJvciA/IG9ic2VydmVyLmVycm9yKGV2ZW50KSA6IG9ic2VydmVyLm5leHQoZXZlbnQpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmIChlcykge1xuICAgICAgICAgIGVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgbGlzdGVuRm9yKVxuICAgICAgICAgICAgZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBvbk1lc3NhZ2UpO1xuICAgICAgICAgIGVzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFzeW5jIGZ1bmN0aW9uIGdldEV2ZW50U291cmNlKCkge1xuICAgICAgICBjb25zdCBFdmVudFNvdXJjZUltcGxlbWVudGF0aW9uID0gdHlwZW9mIEV2ZW50U291cmNlID4gXCJ1XCIgfHwgZXNPcHRpb25zLmhlYWRlcnMgfHwgZXNPcHRpb25zLndpdGhDcmVkZW50aWFscyA/IChhd2FpdCBpbXBvcnQoXCJAc2FuaXR5L2V2ZW50c291cmNlXCIpKS5kZWZhdWx0IDogRXZlbnRTb3VyY2U7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJPUFRJT05TXCIsXG4gICAgICAgICAgICBtb2RlOiBcImNvcnNcIixcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBlc09wdGlvbnMud2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcIm9taXRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IGVzT3B0aW9ucy5oZWFkZXJzXG4gICAgICAgICAgfSksIHVuc3Vic2NyaWJlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgdGhyb3cgbmV3IENvcnNPcmlnaW5FcnJvcih7IHByb2plY3RJZDogcHJvamVjdElkMiB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldnMgPSBuZXcgRXZlbnRTb3VyY2VJbXBsZW1lbnRhdGlvbih1cmwudG9TdHJpbmcoKSwgZXNPcHRpb25zKTtcbiAgICAgICAgZXZzLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGxpc3RlbkZvcilcbiAgICAgICAgICBldnMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBvbk1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZXZzO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZ2V0RXZlbnRTb3VyY2UoKS50aGVuKChldmVudFNvdXJjZSkgPT4ge1xuICAgICAgICAgIGV2ZW50U291cmNlICYmIChlcyA9IGV2ZW50U291cmNlLCB1bnN1YnNjcmliZWQgJiYgdW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIH0pLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgICBvYnNlcnZlci5lcnJvcihyZWFzb24pLCBzdG9wKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgc3RvcHBlZCA9ICEwLCB1bnN1YnNjcmliZSgpLCB1bnN1YnNjcmliZWQgPSAhMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdG9wO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUV2ZW50KGV2ZW50KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGEgJiYgSlNPTi5wYXJzZShldmVudC5kYXRhKSB8fCB7fTtcbiAgICByZXR1cm4geyB0eXBlOiBldmVudC50eXBlLCBpZDogZXZlbnQubGFzdEV2ZW50SWQsIC4uLmRhdGEgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxufVxuY2xhc3MgT2JzZXJ2YWJsZURhdGFzZXRzQ2xpZW50IHtcbiAgI2NsaWVudDtcbiAgI2h0dHBSZXF1ZXN0O1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGh0dHBSZXF1ZXN0KSB7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgZGF0YXNldCB0byBjcmVhdGVcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgZGF0YXNldFxuICAgKi9cbiAgY3JlYXRlKG5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX21vZGlmeSh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCBcIlBVVFwiLCBuYW1lLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRWRpdCBhIGRhdGFzZXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gZWRpdFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5ldyBvcHRpb25zIGZvciB0aGUgZGF0YXNldFxuICAgKi9cbiAgZWRpdChuYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9tb2RpZnkodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgXCJQQVRDSFwiLCBuYW1lLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgZGF0YXNldCB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIF9tb2RpZnkodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgXCJERUxFVEVcIiwgbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBkYXRhc2V0cyBmb3IgdGhlIGNvbmZpZ3VyZWQgcHJvamVjdFxuICAgKi9cbiAgbGlzdCgpIHtcbiAgICByZXR1cm4gX3JlcXVlc3QodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwge1xuICAgICAgdXJpOiBcIi9kYXRhc2V0c1wiLFxuICAgICAgdGFnOiBudWxsXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIERhdGFzZXRzQ2xpZW50IHtcbiAgI2NsaWVudDtcbiAgI2h0dHBSZXF1ZXN0O1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGh0dHBSZXF1ZXN0KSB7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgZGF0YXNldCB0byBjcmVhdGVcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgZGF0YXNldFxuICAgKi9cbiAgY3JlYXRlKG5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIF9tb2RpZnkodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgXCJQVVRcIiwgbmFtZSwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBFZGl0IGEgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgZGF0YXNldCB0byBlZGl0XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmV3IG9wdGlvbnMgZm9yIHRoZSBkYXRhc2V0XG4gICAqL1xuICBlZGl0KG5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIF9tb2RpZnkodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgXCJQQVRDSFwiLCBuYW1lLCBvcHRpb25zKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGRhdGFzZXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUobmFtZSkge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9tb2RpZnkodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgXCJERUxFVEVcIiwgbmFtZSkpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgZGF0YXNldHMgZm9yIHRoZSBjb25maWd1cmVkIHByb2plY3RcbiAgICovXG4gIGxpc3QoKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICBfcmVxdWVzdCh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCB7IHVyaTogXCIvZGF0YXNldHNcIiwgdGFnOiBudWxsIH0pXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gX21vZGlmeShjbGllbnQsIGh0dHBSZXF1ZXN0LCBtZXRob2QsIG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRhdGFzZXQobmFtZSksIF9yZXF1ZXN0KGNsaWVudCwgaHR0cFJlcXVlc3QsIHtcbiAgICBtZXRob2QsXG4gICAgdXJpOiBgL2RhdGFzZXRzLyR7bmFtZX1gLFxuICAgIGJvZHk6IG9wdGlvbnMsXG4gICAgdGFnOiBudWxsXG4gIH0pO1xufVxuY2xhc3MgT2JzZXJ2YWJsZVByb2plY3RzQ2xpZW50IHtcbiAgI2NsaWVudDtcbiAgI2h0dHBSZXF1ZXN0O1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGh0dHBSZXF1ZXN0KSB7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0O1xuICB9XG4gIGxpc3Qob3B0aW9ucykge1xuICAgIGNvbnN0IHVyaSA9IG9wdGlvbnM/LmluY2x1ZGVNZW1iZXJzID09PSAhMSA/IFwiL3Byb2plY3RzP2luY2x1ZGVNZW1iZXJzPWZhbHNlXCIgOiBcIi9wcm9qZWN0c1wiO1xuICAgIHJldHVybiBfcmVxdWVzdCh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCB7IHVyaSB9KTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9qZWN0IGJ5IHByb2plY3QgSURcbiAgICpcbiAgICogQHBhcmFtIHByb2plY3RJZCAtIElEIG9mIHRoZSBwcm9qZWN0IHRvIGZldGNoXG4gICAqL1xuICBnZXRCeUlkKHByb2plY3RJZDIpIHtcbiAgICByZXR1cm4gX3JlcXVlc3QodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgeyB1cmk6IGAvcHJvamVjdHMvJHtwcm9qZWN0SWQyfWAgfSk7XG4gIH1cbn1cbmNsYXNzIFByb2plY3RzQ2xpZW50IHtcbiAgI2NsaWVudDtcbiAgI2h0dHBSZXF1ZXN0O1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGh0dHBSZXF1ZXN0KSB7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0O1xuICB9XG4gIGxpc3Qob3B0aW9ucykge1xuICAgIGNvbnN0IHVyaSA9IG9wdGlvbnM/LmluY2x1ZGVNZW1iZXJzID09PSAhMSA/IFwiL3Byb2plY3RzP2luY2x1ZGVNZW1iZXJzPWZhbHNlXCIgOiBcIi9wcm9qZWN0c1wiO1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9yZXF1ZXN0KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIHsgdXJpIH0pKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9qZWN0IGJ5IHByb2plY3QgSURcbiAgICpcbiAgICogQHBhcmFtIHByb2plY3RJZCAtIElEIG9mIHRoZSBwcm9qZWN0IHRvIGZldGNoXG4gICAqL1xuICBnZXRCeUlkKHByb2plY3RJZDIpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIF9yZXF1ZXN0KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIHsgdXJpOiBgL3Byb2plY3RzLyR7cHJvamVjdElkMn1gIH0pXG4gICAgKTtcbiAgfVxufVxuY2xhc3MgT2JzZXJ2YWJsZVVzZXJzQ2xpZW50IHtcbiAgI2NsaWVudDtcbiAgI2h0dHBSZXF1ZXN0O1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGh0dHBSZXF1ZXN0KSB7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0O1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHVzZXIgYnkgdXNlciBJRFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBVc2VyIElEIG9mIHRoZSB1c2VyIHRvIGZldGNoLiBJZiBgbWVgIGlzIHByb3ZpZGVkLCBhIG1pbmltYWwgcmVzcG9uc2UgaW5jbHVkaW5nIHRoZSB1c2VycyByb2xlIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiBfcmVxdWVzdChcbiAgICAgIHRoaXMuI2NsaWVudCxcbiAgICAgIHRoaXMuI2h0dHBSZXF1ZXN0LFxuICAgICAgeyB1cmk6IGAvdXNlcnMvJHtpZH1gIH1cbiAgICApO1xuICB9XG59XG5jbGFzcyBVc2Vyc0NsaWVudCB7XG4gICNjbGllbnQ7XG4gICNodHRwUmVxdWVzdDtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdDtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSB1c2VyIGJ5IHVzZXIgSURcbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVXNlciBJRCBvZiB0aGUgdXNlciB0byBmZXRjaC4gSWYgYG1lYCBpcyBwcm92aWRlZCwgYSBtaW5pbWFsIHJlc3BvbnNlIGluY2x1ZGluZyB0aGUgdXNlcnMgcm9sZSBpcyByZXR1cm5lZC5cbiAgICovXG4gIGdldEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIF9yZXF1ZXN0KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIHtcbiAgICAgICAgdXJpOiBgL3VzZXJzLyR7aWR9YFxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBPYnNlcnZhYmxlU2FuaXR5Q2xpZW50IHtcbiAgYXNzZXRzO1xuICBkYXRhc2V0cztcbiAgbGl2ZTtcbiAgcHJvamVjdHM7XG4gIHVzZXJzO1xuICAvKipcbiAgICogUHJpdmF0ZSBwcm9wZXJ0aWVzXG4gICAqL1xuICAjY2xpZW50Q29uZmlnO1xuICAjaHR0cFJlcXVlc3Q7XG4gIC8qKlxuICAgKiBJbnN0YW5jZSBwcm9wZXJ0aWVzXG4gICAqL1xuICBsaXN0ZW4gPSBfbGlzdGVuO1xuICBjb25zdHJ1Y3RvcihodHRwUmVxdWVzdCwgY29uZmlnID0gZGVmYXVsdENvbmZpZykge1xuICAgIHRoaXMuY29uZmlnKGNvbmZpZyksIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3QsIHRoaXMuYXNzZXRzID0gbmV3IE9ic2VydmFibGVBc3NldHNDbGllbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QpLCB0aGlzLmRhdGFzZXRzID0gbmV3IE9ic2VydmFibGVEYXRhc2V0c0NsaWVudCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCksIHRoaXMubGl2ZSA9IG5ldyBMaXZlQ2xpZW50KHRoaXMpLCB0aGlzLnByb2plY3RzID0gbmV3IE9ic2VydmFibGVQcm9qZWN0c0NsaWVudCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCksIHRoaXMudXNlcnMgPSBuZXcgT2JzZXJ2YWJsZVVzZXJzQ2xpZW50KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogQ2xvbmUgdGhlIGNsaWVudCAtIHJldHVybnMgYSBuZXcgaW5zdGFuY2VcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVNhbml0eUNsaWVudCh0aGlzLiNodHRwUmVxdWVzdCwgdGhpcy5jb25maWcoKSk7XG4gIH1cbiAgY29uZmlnKG5ld0NvbmZpZykge1xuICAgIGlmIChuZXdDb25maWcgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiB7IC4uLnRoaXMuI2NsaWVudENvbmZpZyB9O1xuICAgIGlmICh0aGlzLiNjbGllbnRDb25maWcgJiYgdGhpcy4jY2xpZW50Q29uZmlnLmFsbG93UmVjb25maWd1cmUgPT09ICExKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkV4aXN0aW5nIGNsaWVudCBpbnN0YW5jZSBjYW5ub3QgYmUgcmVjb25maWd1cmVkIC0gdXNlIGB3aXRoQ29uZmlnKG5ld0NvbmZpZylgIHRvIHJldHVybiBhIG5ldyBjbGllbnRcIlxuICAgICAgKTtcbiAgICByZXR1cm4gdGhpcy4jY2xpZW50Q29uZmlnID0gaW5pdENvbmZpZyhuZXdDb25maWcsIHRoaXMuI2NsaWVudENvbmZpZyB8fCB7fSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lIHRoZSBjbGllbnQgd2l0aCBhIG5ldyAocGFydGlhbCkgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG5ld0NvbmZpZyAtIE5ldyBjbGllbnQgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLCBzaGFsbG93bHkgbWVyZ2VkIHdpdGggZXhpc3RpbmcgY29uZmlndXJhdGlvblxuICAgKi9cbiAgd2l0aENvbmZpZyhuZXdDb25maWcpIHtcbiAgICBjb25zdCB0aGlzQ29uZmlnID0gdGhpcy5jb25maWcoKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTYW5pdHlDbGllbnQodGhpcy4jaHR0cFJlcXVlc3QsIHtcbiAgICAgIC4uLnRoaXNDb25maWcsXG4gICAgICAuLi5uZXdDb25maWcsXG4gICAgICBzdGVnYToge1xuICAgICAgICAuLi50aGlzQ29uZmlnLnN0ZWdhIHx8IHt9LFxuICAgICAgICAuLi50eXBlb2YgbmV3Q29uZmlnPy5zdGVnYSA9PSBcImJvb2xlYW5cIiA/IHsgZW5hYmxlZDogbmV3Q29uZmlnLnN0ZWdhIH0gOiBuZXdDb25maWc/LnN0ZWdhIHx8IHt9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZmV0Y2gocXVlcnksIHBhcmFtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBfZmV0Y2goXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy4jaHR0cFJlcXVlc3QsXG4gICAgICB0aGlzLiNjbGllbnRDb25maWcuc3RlZ2EsXG4gICAgICBxdWVyeSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHNpbmdsZSBkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBJRC5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gRG9jdW1lbnQgSUQgdG8gZmV0Y2hcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnNcbiAgICovXG4gIGdldERvY3VtZW50KGlkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9nZXREb2N1bWVudCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgaWQsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBtdWx0aXBsZSBkb2N1bWVudHMgaW4gb25lIHJlcXVlc3QuXG4gICAqIFNob3VsZCBiZSB1c2VkIHNwYXJpbmdseSAtIHBlcmZvcm1pbmcgYSBxdWVyeSBpcyB1c3VhbGx5IGEgYmV0dGVyIG9wdGlvbi5cbiAgICogVGhlIG9yZGVyL3Bvc2l0aW9uIG9mIGRvY3VtZW50cyBpcyBwcmVzZXJ2ZWQgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGFycmF5IG9mIElEcy5cbiAgICogSWYgYW55IG9mIHRoZSBkb2N1bWVudHMgYXJlIG1pc3NpbmcsIHRoZXkgd2lsbCBiZSByZXBsYWNlZCBieSBhIGBudWxsYCBlbnRyeSBpbiB0aGUgcmV0dXJuZWQgYXJyYXlcbiAgICpcbiAgICogQHBhcmFtIGlkcyAtIERvY3VtZW50IElEcyB0byBmZXRjaFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9uc1xuICAgKi9cbiAgZ2V0RG9jdW1lbnRzKGlkcywgb3B0aW9ucykge1xuICAgIHJldHVybiBfZ2V0RG9jdW1lbnRzKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBpZHMsIG9wdGlvbnMpO1xuICB9XG4gIGNyZWF0ZShkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfY3JlYXRlKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBkb2N1bWVudCwgXCJjcmVhdGVcIiwgb3B0aW9ucyk7XG4gIH1cbiAgY3JlYXRlSWZOb3RFeGlzdHMoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2NyZWF0ZUlmTm90RXhpc3RzKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBkb2N1bWVudCwgb3B0aW9ucyk7XG4gIH1cbiAgY3JlYXRlT3JSZXBsYWNlKGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVPclJlcGxhY2UodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIGRvY3VtZW50LCBvcHRpb25zKTtcbiAgfVxuICBkZWxldGUoc2VsZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9kZWxldGUodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIHNlbGVjdGlvbiwgb3B0aW9ucyk7XG4gIH1cbiAgbXV0YXRlKG9wZXJhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX211dGF0ZSh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgb3BlcmF0aW9ucywgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBidWlsZGFibGUgcGF0Y2ggb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3Rpb24gLSBEb2N1bWVudCBJRCwgYW4gYXJyYXkgb2YgZG9jdW1lbnQgSURzLCBvciBhbiBvYmplY3Qgd2l0aCBgcXVlcnlgIGFuZCBvcHRpb25hbCBgcGFyYW1zYCwgZGVmaW5pbmcgd2hpY2ggZG9jdW1lbnQocykgdG8gcGF0Y2hcbiAgICogQHBhcmFtIG9wZXJhdGlvbnMgLSBPcHRpb25hbCBvYmplY3Qgb2YgcGF0Y2ggb3BlcmF0aW9ucyB0byBpbml0aWFsaXplIHRoZSBwYXRjaCBpbnN0YW5jZSB3aXRoXG4gICAqIEByZXR1cm5zIFBhdGNoIGluc3RhbmNlIC0gY2FsbCBgLmNvbW1pdCgpYCB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb25zIGRlZmluZWRcbiAgICovXG4gIHBhdGNoKHNlbGVjdGlvbiwgb3BlcmF0aW9ucykge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVBhdGNoKHNlbGVjdGlvbiwgb3BlcmF0aW9ucywgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB0cmFuc2FjdGlvbiBvZiBtdXRhdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIG9wZXJhdGlvbnMgLSBPcHRpb25hbCBhcnJheSBvZiBtdXRhdGlvbiBvcGVyYXRpb25zIHRvIGluaXRpYWxpemUgdGhlIHRyYW5zYWN0aW9uIGluc3RhbmNlIHdpdGhcbiAgICovXG4gIHRyYW5zYWN0aW9uKG9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVUcmFuc2FjdGlvbihvcGVyYXRpb25zLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBhY3Rpb24gb3BlcmF0aW9ucyBhZ2FpbnN0IHRoZSBjb25maWd1cmVkIGRhdGFzZXRcbiAgICpcbiAgICogQHBhcmFtIG9wZXJhdGlvbnMgLSBBY3Rpb24gb3BlcmF0aW9uKHMpIHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBY3Rpb24gb3B0aW9uc1xuICAgKi9cbiAgYWN0aW9uKG9wZXJhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2FjdGlvbih0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgb3BlcmF0aW9ucywgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm0gYW4gSFRUUCByZXF1ZXN0IGFnYWluc3QgdGhlIFNhbml0eSBBUElcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnNcbiAgICovXG4gIHJlcXVlc3Qob3B0aW9ucykge1xuICAgIHJldHVybiBfcmVxdWVzdCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIFNhbml0eSBBUEkgVVJMIGZvciB0aGUgVVJJIHByb3ZpZGVkXG4gICAqXG4gICAqIEBwYXJhbSB1cmkgLSBVUkkvcGF0aCB0byBidWlsZCBVUkwgZm9yXG4gICAqIEBwYXJhbSBjYW5Vc2VDZG4gLSBXaGV0aGVyIG9yIG5vdCB0byBhbGxvdyB1c2luZyB0aGUgQVBJIENETiBmb3IgdGhpcyByb3V0ZVxuICAgKi9cbiAgZ2V0VXJsKHVyaSwgY2FuVXNlQ2RuKSB7XG4gICAgcmV0dXJuIF9nZXRVcmwodGhpcywgdXJpLCBjYW5Vc2VDZG4pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBTYW5pdHkgQVBJIFVSTCBmb3IgdGhlIGRhdGEgb3BlcmF0aW9uIGFuZCBwYXRoIHByb3ZpZGVkXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gLSBEYXRhIG9wZXJhdGlvbiAoZWcgYHF1ZXJ5YCwgYG11dGF0ZWAsIGBsaXN0ZW5gIG9yIHNpbWlsYXIpXG4gICAqIEBwYXJhbSBwYXRoIC0gUGF0aCB0byBhcHBlbmQgYWZ0ZXIgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgZ2V0RGF0YVVybChvcGVyYXRpb24sIHBhdGgpIHtcbiAgICByZXR1cm4gX2dldERhdGFVcmwodGhpcywgb3BlcmF0aW9uLCBwYXRoKTtcbiAgfVxufVxuY2xhc3MgU2FuaXR5Q2xpZW50IHtcbiAgYXNzZXRzO1xuICBkYXRhc2V0cztcbiAgbGl2ZTtcbiAgcHJvamVjdHM7XG4gIHVzZXJzO1xuICAvKipcbiAgICogT2JzZXJ2YWJsZSB2ZXJzaW9uIG9mIHRoZSBTYW5pdHkgY2xpZW50LCB3aXRoIHRoZSBzYW1lIGNvbmZpZ3VyYXRpb24gYXMgdGhlIHByb21pc2UtYmFzZWQgb25lXG4gICAqL1xuICBvYnNlcnZhYmxlO1xuICAvKipcbiAgICogUHJpdmF0ZSBwcm9wZXJ0aWVzXG4gICAqL1xuICAjY2xpZW50Q29uZmlnO1xuICAjaHR0cFJlcXVlc3Q7XG4gIC8qKlxuICAgKiBJbnN0YW5jZSBwcm9wZXJ0aWVzXG4gICAqL1xuICBsaXN0ZW4gPSBfbGlzdGVuO1xuICBjb25zdHJ1Y3RvcihodHRwUmVxdWVzdCwgY29uZmlnID0gZGVmYXVsdENvbmZpZykge1xuICAgIHRoaXMuY29uZmlnKGNvbmZpZyksIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3QsIHRoaXMuYXNzZXRzID0gbmV3IEFzc2V0c0NsaWVudCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCksIHRoaXMuZGF0YXNldHMgPSBuZXcgRGF0YXNldHNDbGllbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QpLCB0aGlzLmxpdmUgPSBuZXcgTGl2ZUNsaWVudCh0aGlzKSwgdGhpcy5wcm9qZWN0cyA9IG5ldyBQcm9qZWN0c0NsaWVudCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCksIHRoaXMudXNlcnMgPSBuZXcgVXNlcnNDbGllbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QpLCB0aGlzLm9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZVNhbml0eUNsaWVudChodHRwUmVxdWVzdCwgY29uZmlnKTtcbiAgfVxuICAvKipcbiAgICogQ2xvbmUgdGhlIGNsaWVudCAtIHJldHVybnMgYSBuZXcgaW5zdGFuY2VcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgU2FuaXR5Q2xpZW50KHRoaXMuI2h0dHBSZXF1ZXN0LCB0aGlzLmNvbmZpZygpKTtcbiAgfVxuICBjb25maWcobmV3Q29uZmlnKSB7XG4gICAgaWYgKG5ld0NvbmZpZyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHsgLi4udGhpcy4jY2xpZW50Q29uZmlnIH07XG4gICAgaWYgKHRoaXMuI2NsaWVudENvbmZpZyAmJiB0aGlzLiNjbGllbnRDb25maWcuYWxsb3dSZWNvbmZpZ3VyZSA9PT0gITEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXhpc3RpbmcgY2xpZW50IGluc3RhbmNlIGNhbm5vdCBiZSByZWNvbmZpZ3VyZWQgLSB1c2UgYHdpdGhDb25maWcobmV3Q29uZmlnKWAgdG8gcmV0dXJuIGEgbmV3IGNsaWVudFwiXG4gICAgICApO1xuICAgIHJldHVybiB0aGlzLm9ic2VydmFibGUgJiYgdGhpcy5vYnNlcnZhYmxlLmNvbmZpZyhuZXdDb25maWcpLCB0aGlzLiNjbGllbnRDb25maWcgPSBpbml0Q29uZmlnKG5ld0NvbmZpZywgdGhpcy4jY2xpZW50Q29uZmlnIHx8IHt9KSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2xvbmUgdGhlIGNsaWVudCB3aXRoIGEgbmV3IChwYXJ0aWFsKSBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbmV3Q29uZmlnIC0gTmV3IGNsaWVudCBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMsIHNoYWxsb3dseSBtZXJnZWQgd2l0aCBleGlzdGluZyBjb25maWd1cmF0aW9uXG4gICAqL1xuICB3aXRoQ29uZmlnKG5ld0NvbmZpZykge1xuICAgIGNvbnN0IHRoaXNDb25maWcgPSB0aGlzLmNvbmZpZygpO1xuICAgIHJldHVybiBuZXcgU2FuaXR5Q2xpZW50KHRoaXMuI2h0dHBSZXF1ZXN0LCB7XG4gICAgICAuLi50aGlzQ29uZmlnLFxuICAgICAgLi4ubmV3Q29uZmlnLFxuICAgICAgc3RlZ2E6IHtcbiAgICAgICAgLi4udGhpc0NvbmZpZy5zdGVnYSB8fCB7fSxcbiAgICAgICAgLi4udHlwZW9mIG5ld0NvbmZpZz8uc3RlZ2EgPT0gXCJib29sZWFuXCIgPyB7IGVuYWJsZWQ6IG5ld0NvbmZpZy5zdGVnYSB9IDogbmV3Q29uZmlnPy5zdGVnYSB8fCB7fVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZldGNoKHF1ZXJ5LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIF9mZXRjaChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy4jaHR0cFJlcXVlc3QsXG4gICAgICAgIHRoaXMuI2NsaWVudENvbmZpZy5zdGVnYSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgc2luZ2xlIGRvY3VtZW50IHdpdGggdGhlIGdpdmVuIElELlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBEb2N1bWVudCBJRCB0byBmZXRjaFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9uc1xuICAgKi9cbiAgZ2V0RG9jdW1lbnQoaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfZ2V0RG9jdW1lbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIGlkLCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIG11bHRpcGxlIGRvY3VtZW50cyBpbiBvbmUgcmVxdWVzdC5cbiAgICogU2hvdWxkIGJlIHVzZWQgc3BhcmluZ2x5IC0gcGVyZm9ybWluZyBhIHF1ZXJ5IGlzIHVzdWFsbHkgYSBiZXR0ZXIgb3B0aW9uLlxuICAgKiBUaGUgb3JkZXIvcG9zaXRpb24gb2YgZG9jdW1lbnRzIGlzIHByZXNlcnZlZCBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgSURzLlxuICAgKiBJZiBhbnkgb2YgdGhlIGRvY3VtZW50cyBhcmUgbWlzc2luZywgdGhleSB3aWxsIGJlIHJlcGxhY2VkIGJ5IGEgYG51bGxgIGVudHJ5IGluIHRoZSByZXR1cm5lZCBhcnJheVxuICAgKlxuICAgKiBAcGFyYW0gaWRzIC0gRG9jdW1lbnQgSURzIHRvIGZldGNoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqL1xuICBnZXREb2N1bWVudHMoaWRzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX2dldERvY3VtZW50cyh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgaWRzLCBvcHRpb25zKSk7XG4gIH1cbiAgY3JlYXRlKGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICBfY3JlYXRlKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBkb2N1bWVudCwgXCJjcmVhdGVcIiwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIGNyZWF0ZUlmTm90RXhpc3RzKGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICBfY3JlYXRlSWZOb3RFeGlzdHModGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIGRvY3VtZW50LCBvcHRpb25zKVxuICAgICk7XG4gIH1cbiAgY3JlYXRlT3JSZXBsYWNlKGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICBfY3JlYXRlT3JSZXBsYWNlKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBkb2N1bWVudCwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIGRlbGV0ZShzZWxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfZGVsZXRlKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBzZWxlY3Rpb24sIG9wdGlvbnMpKTtcbiAgfVxuICBtdXRhdGUob3BlcmF0aW9ucywgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9tdXRhdGUodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIG9wZXJhdGlvbnMsIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGJ1aWxkYWJsZSBwYXRjaCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdGlvbiAtIERvY3VtZW50IElELCBhbiBhcnJheSBvZiBkb2N1bWVudCBJRHMsIG9yIGFuIG9iamVjdCB3aXRoIGBxdWVyeWAgYW5kIG9wdGlvbmFsIGBwYXJhbXNgLCBkZWZpbmluZyB3aGljaCBkb2N1bWVudChzKSB0byBwYXRjaFxuICAgKiBAcGFyYW0gb3BlcmF0aW9ucyAtIE9wdGlvbmFsIG9iamVjdCBvZiBwYXRjaCBvcGVyYXRpb25zIHRvIGluaXRpYWxpemUgdGhlIHBhdGNoIGluc3RhbmNlIHdpdGhcbiAgICogQHJldHVybnMgUGF0Y2ggaW5zdGFuY2UgLSBjYWxsIGAuY29tbWl0KClgIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbnMgZGVmaW5lZFxuICAgKi9cbiAgcGF0Y2goZG9jdW1lbnRJZCwgb3BlcmF0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGF0Y2goZG9jdW1lbnRJZCwgb3BlcmF0aW9ucywgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB0cmFuc2FjdGlvbiBvZiBtdXRhdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIG9wZXJhdGlvbnMgLSBPcHRpb25hbCBhcnJheSBvZiBtdXRhdGlvbiBvcGVyYXRpb25zIHRvIGluaXRpYWxpemUgdGhlIHRyYW5zYWN0aW9uIGluc3RhbmNlIHdpdGhcbiAgICovXG4gIHRyYW5zYWN0aW9uKG9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKG9wZXJhdGlvbnMsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFjdGlvbiBvcGVyYXRpb25zIGFnYWluc3QgdGhlIGNvbmZpZ3VyZWQgZGF0YXNldFxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiByZXN1bHRcbiAgICpcbiAgICogQHBhcmFtIG9wZXJhdGlvbnMgLSBBY3Rpb24gb3BlcmF0aW9uKHMpIHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBY3Rpb24gb3B0aW9uc1xuICAgKi9cbiAgYWN0aW9uKG9wZXJhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfYWN0aW9uKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBvcGVyYXRpb25zLCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSByZXF1ZXN0IGFnYWluc3QgdGhlIFNhbml0eSBBUElcbiAgICogTk9URTogT25seSB1c2UgdGhpcyBmb3IgU2FuaXR5IEFQSSBlbmRwb2ludHMsIG5vdCBmb3IgeW91ciBvd24gQVBJcyFcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnNcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHJlc3BvbnNlIGJvZHlcbiAgICovXG4gIHJlcXVlc3Qob3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9yZXF1ZXN0KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm0gYW4gSFRUUCByZXF1ZXN0IGEgYC9kYXRhYCBzdWItZW5kcG9pbnRcbiAgICogTk9URTogQ29uc2lkZXJlZCBpbnRlcm5hbCwgdGh1cyBtYXJrZWQgYXMgZGVwcmVjYXRlZC4gVXNlIGByZXF1ZXN0YCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCAtIFVzZSBgcmVxdWVzdCgpYCBvciB5b3VyIG93biBIVFRQIGxpYnJhcnkgaW5zdGVhZFxuICAgKiBAcGFyYW0gZW5kcG9pbnQgLSBFbmRwb2ludCB0byBoaXQgKG11dGF0ZSwgcXVlcnkgZXRjKVxuICAgKiBAcGFyYW0gYm9keSAtIFJlcXVlc3QgYm9keVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhdGFSZXF1ZXN0KGVuZHBvaW50LCBib2R5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX2RhdGFSZXF1ZXN0KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBlbmRwb2ludCwgYm9keSwgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBTYW5pdHkgQVBJIFVSTCBmb3IgdGhlIFVSSSBwcm92aWRlZFxuICAgKlxuICAgKiBAcGFyYW0gdXJpIC0gVVJJL3BhdGggdG8gYnVpbGQgVVJMIGZvclxuICAgKiBAcGFyYW0gY2FuVXNlQ2RuIC0gV2hldGhlciBvciBub3QgdG8gYWxsb3cgdXNpbmcgdGhlIEFQSSBDRE4gZm9yIHRoaXMgcm91dGVcbiAgICovXG4gIGdldFVybCh1cmksIGNhblVzZUNkbikge1xuICAgIHJldHVybiBfZ2V0VXJsKHRoaXMsIHVyaSwgY2FuVXNlQ2RuKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgU2FuaXR5IEFQSSBVUkwgZm9yIHRoZSBkYXRhIG9wZXJhdGlvbiBhbmQgcGF0aCBwcm92aWRlZFxuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9uIC0gRGF0YSBvcGVyYXRpb24gKGVnIGBxdWVyeWAsIGBtdXRhdGVgLCBgbGlzdGVuYCBvciBzaW1pbGFyKVxuICAgKiBAcGFyYW0gcGF0aCAtIFBhdGggdG8gYXBwZW5kIGFmdGVyIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGdldERhdGFVcmwob3BlcmF0aW9uLCBwYXRoKSB7XG4gICAgcmV0dXJuIF9nZXREYXRhVXJsKHRoaXMsIG9wZXJhdGlvbiwgcGF0aCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZUNyZWF0ZUNsaWVudEV4cG9ydHMoZW52TWlkZGxld2FyZTIsIENsYXNzQ29uc3RydWN0b3IpIHtcbiAgY29uc3QgZGVmYXVsdFJlcXVlc3RlciA9IGRlZmluZUh0dHBSZXF1ZXN0KGVudk1pZGRsZXdhcmUyKTtcbiAgcmV0dXJuIHsgcmVxdWVzdGVyOiBkZWZhdWx0UmVxdWVzdGVyLCBjcmVhdGVDbGllbnQ6IChjb25maWcpID0+IG5ldyBDbGFzc0NvbnN0cnVjdG9yKFxuICAgIChvcHRpb25zLCByZXF1ZXN0ZXIyKSA9PiAocmVxdWVzdGVyMiB8fCBkZWZhdWx0UmVxdWVzdGVyKSh7XG4gICAgICBtYXhSZWRpcmVjdHM6IDAsXG4gICAgICBtYXhSZXRyaWVzOiBjb25maWcubWF4UmV0cmllcyxcbiAgICAgIHJldHJ5RGVsYXk6IGNvbmZpZy5yZXRyeURlbGF5LFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pLFxuICAgIGNvbmZpZ1xuICApIH07XG59XG5mdW5jdGlvbiBkZWZpbmVEZXByZWNhdGVkQ3JlYXRlQ2xpZW50KGNyZWF0ZUNsaWVudDIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHJldHVybiBwcmludE5vRGVmYXVsdEV4cG9ydCgpLCBjcmVhdGVDbGllbnQyKGNvbmZpZyk7XG4gIH07XG59XG52YXIgZW52TWlkZGxld2FyZSA9IFtdO1xuY29uc3QgZXhwID0gZGVmaW5lQ3JlYXRlQ2xpZW50RXhwb3J0cyhlbnZNaWRkbGV3YXJlLCBTYW5pdHlDbGllbnQpLCByZXF1ZXN0ZXIgPSBleHAucmVxdWVzdGVyLCBjcmVhdGVDbGllbnQgPSBleHAuY3JlYXRlQ2xpZW50LCBkZXByZWNhdGVkQ3JlYXRlQ2xpZW50ID0gZGVmaW5lRGVwcmVjYXRlZENyZWF0ZUNsaWVudChjcmVhdGVDbGllbnQpO1xuZXhwb3J0IHtcbiAgQmFzZVBhdGNoLFxuICBCYXNlVHJhbnNhY3Rpb24sXG4gIENsaWVudEVycm9yLFxuICBDb3JzT3JpZ2luRXJyb3IsXG4gIE9ic2VydmFibGVQYXRjaCxcbiAgT2JzZXJ2YWJsZVNhbml0eUNsaWVudCxcbiAgT2JzZXJ2YWJsZVRyYW5zYWN0aW9uLFxuICBQYXRjaCxcbiAgU2FuaXR5Q2xpZW50LFxuICBTZXJ2ZXJFcnJvcixcbiAgVHJhbnNhY3Rpb24sXG4gIGNyZWF0ZUNsaWVudCxcbiAgZGVwcmVjYXRlZENyZWF0ZUNsaWVudCBhcyBkZWZhdWx0LFxuICByZXF1ZXN0ZXIsXG4gIGFkYXB0ZXIgYXMgdW5zdGFibGVfX2FkYXB0ZXIsXG4gIGVudmlyb25tZW50IGFzIHVuc3RhYmxlX19lbnZpcm9ubWVudCxcbiAgdmFsaWRhdGVBcGlQZXJzcGVjdGl2ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmJyb3dzZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@sanity/client/dist/index.browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@sanity/next-loader/dist/_chunks-es/isCorsOriginError.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/_chunks-es/isCorsOriginError.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isCorsOriginError: () => (/* binding */ isCorsOriginError)\n/* harmony export */ });\n/* harmony import */ var _sanity_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/client */ \"(rsc)/./node_modules/@sanity/client/dist/index.browser.js\");\n\nfunction isCorsOriginError(error) {\n  return error instanceof _sanity_client__WEBPACK_IMPORTED_MODULE_0__.CorsOriginError;\n}\n\n//# sourceMappingURL=isCorsOriginError.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L19jaHVua3MtZXMvaXNDb3JzT3JpZ2luRXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUQ7QUFDakQ7QUFDQSwwQkFBMEIsMkRBQWU7QUFDekM7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWNfZGlyZWN0b3J5Ly4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvbmV4dC1sb2FkZXIvZGlzdC9fY2h1bmtzLWVzL2lzQ29yc09yaWdpbkVycm9yLmpzPzcyN2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29yc09yaWdpbkVycm9yIH0gZnJvbSBcIkBzYW5pdHkvY2xpZW50XCI7XG5mdW5jdGlvbiBpc0NvcnNPcmlnaW5FcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBDb3JzT3JpZ2luRXJyb3I7XG59XG5leHBvcnQge1xuICBpc0NvcnNPcmlnaW5FcnJvclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQ29yc09yaWdpbkVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@sanity/next-loader/dist/_chunks-es/isCorsOriginError.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@sanity/next-loader/dist/_chunks-es/utils.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/_chunks-es/utils.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   perspectiveCookieName: () => (/* binding */ perspectiveCookieName),\n/* harmony export */   sanitizePerspective: () => (/* binding */ sanitizePerspective)\n/* harmony export */ });\n/* harmony import */ var _sanity_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/client */ \"(action-browser)/./node_modules/@sanity/client/dist/index.browser.js\");\n\nconst perspectiveCookieName = \"sanity-preview-perspective\";\nfunction sanitizePerspective(_perspective, fallback) {\n  const perspective = typeof _perspective == \"string\" && _perspective.includes(\",\") ? _perspective.split(\",\") : _perspective;\n  try {\n    return (0,_sanity_client__WEBPACK_IMPORTED_MODULE_0__.validateApiPerspective)(perspective), perspective === \"raw\" ? fallback : perspective;\n  } catch (err) {\n    return console.warn(\"Invalid perspective:\", _perspective, perspective, err), fallback;\n  }\n}\n\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL2Rpc3QvX2NodW5rcy1lcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNFQUFzQjtBQUNqQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3ljX2RpcmVjdG9yeS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL2Rpc3QvX2NodW5rcy1lcy91dGlscy5qcz85ZTJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZhbGlkYXRlQXBpUGVyc3BlY3RpdmUgfSBmcm9tIFwiQHNhbml0eS9jbGllbnRcIjtcbmNvbnN0IHBlcnNwZWN0aXZlQ29va2llTmFtZSA9IFwic2FuaXR5LXByZXZpZXctcGVyc3BlY3RpdmVcIjtcbmZ1bmN0aW9uIHNhbml0aXplUGVyc3BlY3RpdmUoX3BlcnNwZWN0aXZlLCBmYWxsYmFjaykge1xuICBjb25zdCBwZXJzcGVjdGl2ZSA9IHR5cGVvZiBfcGVyc3BlY3RpdmUgPT0gXCJzdHJpbmdcIiAmJiBfcGVyc3BlY3RpdmUuaW5jbHVkZXMoXCIsXCIpID8gX3BlcnNwZWN0aXZlLnNwbGl0KFwiLFwiKSA6IF9wZXJzcGVjdGl2ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdmFsaWRhdGVBcGlQZXJzcGVjdGl2ZShwZXJzcGVjdGl2ZSksIHBlcnNwZWN0aXZlID09PSBcInJhd1wiID8gZmFsbGJhY2sgOiBwZXJzcGVjdGl2ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUud2FybihcIkludmFsaWQgcGVyc3BlY3RpdmU6XCIsIF9wZXJzcGVjdGl2ZSwgcGVyc3BlY3RpdmUsIGVyciksIGZhbGxiYWNrO1xuICB9XG59XG5leHBvcnQge1xuICBwZXJzcGVjdGl2ZUNvb2tpZU5hbWUsXG4gIHNhbml0aXplUGVyc3BlY3RpdmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@sanity/next-loader/dist/_chunks-es/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@sanity/next-loader/dist/_chunks-es/utils.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/_chunks-es/utils.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   perspectiveCookieName: () => (/* binding */ perspectiveCookieName),\n/* harmony export */   sanitizePerspective: () => (/* binding */ sanitizePerspective)\n/* harmony export */ });\n/* harmony import */ var _sanity_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/client */ \"(rsc)/./node_modules/@sanity/client/dist/index.browser.js\");\n\nconst perspectiveCookieName = \"sanity-preview-perspective\";\nfunction sanitizePerspective(_perspective, fallback) {\n  const perspective = typeof _perspective == \"string\" && _perspective.includes(\",\") ? _perspective.split(\",\") : _perspective;\n  try {\n    return (0,_sanity_client__WEBPACK_IMPORTED_MODULE_0__.validateApiPerspective)(perspective), perspective === \"raw\" ? fallback : perspective;\n  } catch (err) {\n    return console.warn(\"Invalid perspective:\", _perspective, perspective, err), fallback;\n  }\n}\n\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L19jaHVua3MtZXMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzRUFBc0I7QUFDakMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95Y19kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L19jaHVua3MtZXMvdXRpbHMuanM/MDBjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2YWxpZGF0ZUFwaVBlcnNwZWN0aXZlIH0gZnJvbSBcIkBzYW5pdHkvY2xpZW50XCI7XG5jb25zdCBwZXJzcGVjdGl2ZUNvb2tpZU5hbWUgPSBcInNhbml0eS1wcmV2aWV3LXBlcnNwZWN0aXZlXCI7XG5mdW5jdGlvbiBzYW5pdGl6ZVBlcnNwZWN0aXZlKF9wZXJzcGVjdGl2ZSwgZmFsbGJhY2spIHtcbiAgY29uc3QgcGVyc3BlY3RpdmUgPSB0eXBlb2YgX3BlcnNwZWN0aXZlID09IFwic3RyaW5nXCIgJiYgX3BlcnNwZWN0aXZlLmluY2x1ZGVzKFwiLFwiKSA/IF9wZXJzcGVjdGl2ZS5zcGxpdChcIixcIikgOiBfcGVyc3BlY3RpdmU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlQXBpUGVyc3BlY3RpdmUocGVyc3BlY3RpdmUpLCBwZXJzcGVjdGl2ZSA9PT0gXCJyYXdcIiA/IGZhbGxiYWNrIDogcGVyc3BlY3RpdmU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHBlcnNwZWN0aXZlOlwiLCBfcGVyc3BlY3RpdmUsIHBlcnNwZWN0aXZlLCBlcnIpLCBmYWxsYmFjaztcbiAgfVxufVxuZXhwb3J0IHtcbiAgcGVyc3BlY3RpdmVDb29raWVOYW1lLFxuICBzYW5pdGl6ZVBlcnNwZWN0aXZlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@sanity/next-loader/dist/_chunks-es/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@sanity/next-loader/dist/client-components/live-stream.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/client-components/live-stream.js ***!
  \********************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");


const proxy = await (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/kunal/Desktop/nextJS/YC_Directory/node_modules/@sanity/next-loader/dist/client-components/live-stream.js`)
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (proxy.default);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "(rsc)/./node_modules/@sanity/next-loader/dist/client-components/live.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/client-components/live.js ***!
  \*************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");


const proxy = await (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/kunal/Desktop/nextJS/YC_Directory/node_modules/@sanity/next-loader/dist/client-components/live.js`)
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (proxy.default);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "(rsc)/./node_modules/@sanity/next-loader/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/index.js ***!
  \********************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineLive: () => (/* binding */ defineLive),\n/* harmony export */   isCorsOriginError: () => (/* reexport safe */ _chunks_es_isCorsOriginError_js__WEBPACK_IMPORTED_MODULE_5__.isCorsOriginError)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var _sanity_next_loader_client_components_live__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sanity/next-loader/client-components/live */ \"(rsc)/./node_modules/@sanity/next-loader/dist/client-components/live.js\");\n/* harmony import */ var _sanity_next_loader_client_components_live_stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sanity/next-loader/client-components/live-stream */ \"(rsc)/./node_modules/@sanity/next-loader/dist/client-components/live-stream.js\");\n/* harmony import */ var _chunks_es_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_chunks-es/utils.js */ \"(rsc)/./node_modules/@sanity/next-loader/dist/_chunks-es/utils.js\");\n/* harmony import */ var next_headers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/headers.js */ \"(rsc)/./node_modules/next/dist/api/headers.js\");\n/* harmony import */ var _chunks_es_isCorsOriginError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_chunks-es/isCorsOriginError.js */ \"(rsc)/./node_modules/@sanity/next-loader/dist/_chunks-es/isCorsOriginError.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sanity_next_loader_client_components_live__WEBPACK_IMPORTED_MODULE_3__, _sanity_next_loader_client_components_live_stream__WEBPACK_IMPORTED_MODULE_4__]);\n([_sanity_next_loader_client_components_live__WEBPACK_IMPORTED_MODULE_3__, _sanity_next_loader_client_components_live_stream__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\nfunction defineLive(config) {\n  const {\n    client: _client,\n    serverToken,\n    browserToken,\n    fetchOptions,\n    stega: stegaEnabled = !0\n  } = config;\n  if (!_client)\n    throw new Error(\"`client` is required for `defineLive` to function\");\n   true && !serverToken && console.warn(\n    \"No `serverToken` provided to `defineLive`. This means that only published content will be fetched and respond to live events\"\n  ),  true && !browserToken && console.warn(\n    \"No `browserToken` provided to `defineLive`. This means that live previewing drafts will only work when using the Presentation Tool in your Sanity Studio. To support live previewing drafts stand-alone, provide a `browserToken`. It is shared with the browser so it should only have Viewer rights or lower\"\n  );\n  const client = _client.withConfig({ allowReconfigure: !1, useCdn: !1 }), { token: originalToken } = client.config(), studioUrlDefined = typeof client.config().stega.studioUrl < \"u\", sanityFetch = async function({\n    query,\n    params = {},\n    stega: _stega,\n    perspective: _perspective,\n    tag = \"next-loader.fetch\"\n  }) {\n    const stega = _stega ?? (stegaEnabled && studioUrlDefined && (await (0,next_headers_js__WEBPACK_IMPORTED_MODULE_1__.draftMode)()).isEnabled), perspective = _perspective ?? ((await (0,next_headers_js__WEBPACK_IMPORTED_MODULE_1__.draftMode)()).isEnabled ? (await (0,next_headers_js__WEBPACK_IMPORTED_MODULE_1__.cookies)()).has(_chunks_es_utils_js__WEBPACK_IMPORTED_MODULE_2__.perspectiveCookieName) ? (0,_chunks_es_utils_js__WEBPACK_IMPORTED_MODULE_2__.sanitizePerspective)(\n      (await (0,next_headers_js__WEBPACK_IMPORTED_MODULE_1__.cookies)()).get(_chunks_es_utils_js__WEBPACK_IMPORTED_MODULE_2__.perspectiveCookieName)?.value,\n      \"previewDrafts\"\n    ) : \"previewDrafts\" : \"published\"), useCdn = perspective === \"published\", revalidate = fetchOptions?.revalidate ?? \"development\" === \"production\" ? !1 : void 0, { syncTags } = await client.fetch(query, await params, {\n      filterResponse: !1,\n      perspective,\n      stega: !1,\n      returnQuery: !1,\n      next: { revalidate, tags: [\"sanity:fetch-sync-tags\"] },\n      useCdn,\n      cacheMode: useCdn ? \"noStale\" : void 0,\n      tag: [tag, \"fetch-sync-tags\"].filter(Boolean).join(\".\")\n    }), tags = [\"sanity\", ...syncTags?.map((tag2) => `sanity:${tag2}`) || []], { result, resultSourceMap } = await client.fetch(query, await params, {\n      filterResponse: !1,\n      perspective,\n      stega,\n      token: perspective !== \"published\" && serverToken ? serverToken : originalToken,\n      next: { revalidate, tags },\n      useCdn,\n      cacheMode: useCdn ? \"noStale\" : void 0,\n      tag\n    });\n    return { data: result, sourceMap: resultSourceMap || null, tags };\n  };\n  return {\n    sanityFetch,\n    SanityLive: async function(props) {\n      const {\n        // handleDraftModeAction = handleDraftModeActionMissing\n        refreshOnMount,\n        refreshOnFocus,\n        refreshOnReconnect,\n        tag = \"next-loader.live\",\n        onError\n      } = props, {\n        projectId,\n        dataset,\n        apiHost,\n        apiVersion: _apiVersion,\n        useProjectHostname,\n        requestTagPrefix\n      } = client.config(), { isEnabled: isDraftModeEnabled } = await (0,next_headers_js__WEBPACK_IMPORTED_MODULE_1__.draftMode)();\n      let apiVersion = _apiVersion;\n      return typeof browserToken == \"string\" && isDraftModeEnabled && (apiVersion = \"vX\"), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n        _sanity_next_loader_client_components_live__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n        {\n          projectId,\n          dataset,\n          apiHost,\n          apiVersion,\n          useProjectHostname,\n          requestTagPrefix,\n          tag,\n          token: typeof browserToken == \"string\" && isDraftModeEnabled ? browserToken : void 0,\n          draftModeEnabled: isDraftModeEnabled,\n          draftModePerspective: isDraftModeEnabled ? (await (0,next_headers_js__WEBPACK_IMPORTED_MODULE_1__.cookies)()).has(_chunks_es_utils_js__WEBPACK_IMPORTED_MODULE_2__.perspectiveCookieName) ? (0,_chunks_es_utils_js__WEBPACK_IMPORTED_MODULE_2__.sanitizePerspective)(\n            (await (0,next_headers_js__WEBPACK_IMPORTED_MODULE_1__.cookies)()).get(_chunks_es_utils_js__WEBPACK_IMPORTED_MODULE_2__.perspectiveCookieName)?.value,\n            \"previewDrafts\"\n          ) : \"previewDrafts\" : \"published\",\n          refreshOnMount,\n          refreshOnFocus,\n          refreshOnReconnect,\n          onError\n        }\n      );\n    },\n    SanityLiveStream: async function(props) {\n      const {\n        query,\n        params,\n        perspective: _perspective,\n        stega: _stega,\n        children,\n        tag = \"next-loader.live-stream.fetch\"\n      } = props, { data, sourceMap, tags } = await sanityFetch({\n        query,\n        params,\n        perspective: _perspective,\n        stega: _stega,\n        tag\n      }), { isEnabled: isDraftModeEnabled } = await (0,next_headers_js__WEBPACK_IMPORTED_MODULE_1__.draftMode)();\n      if (isDraftModeEnabled) {\n        const stega = _stega ?? (stegaEnabled && studioUrlDefined && (await (0,next_headers_js__WEBPACK_IMPORTED_MODULE_1__.draftMode)()).isEnabled), perspective = _perspective ?? (await (0,next_headers_js__WEBPACK_IMPORTED_MODULE_1__.cookies)()).has(_chunks_es_utils_js__WEBPACK_IMPORTED_MODULE_2__.perspectiveCookieName) ? (0,_chunks_es_utils_js__WEBPACK_IMPORTED_MODULE_2__.sanitizePerspective)(\n          (await (0,next_headers_js__WEBPACK_IMPORTED_MODULE_1__.cookies)()).get(_chunks_es_utils_js__WEBPACK_IMPORTED_MODULE_2__.perspectiveCookieName)?.value,\n          \"previewDrafts\"\n        ) : \"previewDrafts\", { projectId, dataset } = client.config();\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n          _sanity_next_loader_client_components_live_stream__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n          {\n            projectId,\n            dataset,\n            query,\n            params: await params,\n            perspective,\n            stega,\n            initial: children({ data, sourceMap, tags }),\n            children\n          }\n        );\n      }\n      return children({ data, sourceMap, tags });\n    }\n    // verifyPreviewSecret\n  };\n}\n\n//# sourceMappingURL=index.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQzJDO0FBQ2E7QUFDYjtBQUM5QjtBQUNpQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRSxLQUFxQztBQUN2QztBQUNBLEtBQUssS0FBcUM7QUFDMUM7QUFDQTtBQUNBLHNDQUFzQyxrQ0FBa0MsS0FBSyx1QkFBdUI7QUFDcEc7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdFQUF3RSwwREFBUyxzREFBc0QsMERBQVMsdUJBQXVCLHdEQUFPLFFBQVEsc0VBQXFCLElBQUksd0VBQW1CO0FBQ2xPLGFBQWEsd0RBQU8sUUFBUSxzRUFBcUI7QUFDakQ7QUFDQSx1SEFBdUgsYUFBb0IsbUNBQW1DLFdBQVc7QUFDekw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhDQUE4QztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxLQUFLLDBEQUEwRCxLQUFLLGFBQWEsMEJBQTBCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUJBQXFCLGdDQUFnQyxRQUFRLDBEQUFTO0FBQzlFO0FBQ0EsMkdBQTJHLHNEQUFHO0FBQzlHLFFBQVEsa0ZBQXlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHdEQUFPLFFBQVEsc0VBQXFCLElBQUksd0VBQW1CO0FBQ3ZILG1CQUFtQix3REFBTyxRQUFRLHNFQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVcsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEtBQUssZ0NBQWdDLFFBQVEsMERBQVM7QUFDN0Q7QUFDQSw0RUFBNEUsMERBQVMscURBQXFELHdEQUFPLFFBQVEsc0VBQXFCLElBQUksd0VBQW1CO0FBQ3JNLGlCQUFpQix3REFBTyxRQUFRLHNFQUFxQjtBQUNyRDtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQsK0JBQStCLHNEQUFHO0FBQ2xDLFVBQVUseUZBQStCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWNfZGlyZWN0b3J5Ly4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvbmV4dC1sb2FkZXIvZGlzdC9pbmRleC5qcz9mNzhjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IFNhbml0eUxpdmVDbGllbnRDb21wb25lbnQgZnJvbSBcIkBzYW5pdHkvbmV4dC1sb2FkZXIvY2xpZW50LWNvbXBvbmVudHMvbGl2ZVwiO1xuaW1wb3J0IFNhbml0eUxpdmVTdHJlYW1DbGllbnRDb21wb25lbnQgZnJvbSBcIkBzYW5pdHkvbmV4dC1sb2FkZXIvY2xpZW50LWNvbXBvbmVudHMvbGl2ZS1zdHJlYW1cIjtcbmltcG9ydCB7IHBlcnNwZWN0aXZlQ29va2llTmFtZSwgc2FuaXRpemVQZXJzcGVjdGl2ZSB9IGZyb20gXCIuL19jaHVua3MtZXMvdXRpbHMuanNcIjtcbmltcG9ydCB7IGRyYWZ0TW9kZSwgY29va2llcyB9IGZyb20gXCJuZXh0L2hlYWRlcnMuanNcIjtcbmltcG9ydCB7IGlzQ29yc09yaWdpbkVycm9yIH0gZnJvbSBcIi4vX2NodW5rcy1lcy9pc0NvcnNPcmlnaW5FcnJvci5qc1wiO1xuZnVuY3Rpb24gZGVmaW5lTGl2ZShjb25maWcpIHtcbiAgY29uc3Qge1xuICAgIGNsaWVudDogX2NsaWVudCxcbiAgICBzZXJ2ZXJUb2tlbixcbiAgICBicm93c2VyVG9rZW4sXG4gICAgZmV0Y2hPcHRpb25zLFxuICAgIHN0ZWdhOiBzdGVnYUVuYWJsZWQgPSAhMFxuICB9ID0gY29uZmlnO1xuICBpZiAoIV9jbGllbnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYGNsaWVudGAgaXMgcmVxdWlyZWQgZm9yIGBkZWZpbmVMaXZlYCB0byBmdW5jdGlvblwiKTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFzZXJ2ZXJUb2tlbiAmJiBjb25zb2xlLndhcm4oXG4gICAgXCJObyBgc2VydmVyVG9rZW5gIHByb3ZpZGVkIHRvIGBkZWZpbmVMaXZlYC4gVGhpcyBtZWFucyB0aGF0IG9ubHkgcHVibGlzaGVkIGNvbnRlbnQgd2lsbCBiZSBmZXRjaGVkIGFuZCByZXNwb25kIHRvIGxpdmUgZXZlbnRzXCJcbiAgKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFicm93c2VyVG9rZW4gJiYgY29uc29sZS53YXJuKFxuICAgIFwiTm8gYGJyb3dzZXJUb2tlbmAgcHJvdmlkZWQgdG8gYGRlZmluZUxpdmVgLiBUaGlzIG1lYW5zIHRoYXQgbGl2ZSBwcmV2aWV3aW5nIGRyYWZ0cyB3aWxsIG9ubHkgd29yayB3aGVuIHVzaW5nIHRoZSBQcmVzZW50YXRpb24gVG9vbCBpbiB5b3VyIFNhbml0eSBTdHVkaW8uIFRvIHN1cHBvcnQgbGl2ZSBwcmV2aWV3aW5nIGRyYWZ0cyBzdGFuZC1hbG9uZSwgcHJvdmlkZSBhIGBicm93c2VyVG9rZW5gLiBJdCBpcyBzaGFyZWQgd2l0aCB0aGUgYnJvd3NlciBzbyBpdCBzaG91bGQgb25seSBoYXZlIFZpZXdlciByaWdodHMgb3IgbG93ZXJcIlxuICApO1xuICBjb25zdCBjbGllbnQgPSBfY2xpZW50LndpdGhDb25maWcoeyBhbGxvd1JlY29uZmlndXJlOiAhMSwgdXNlQ2RuOiAhMSB9KSwgeyB0b2tlbjogb3JpZ2luYWxUb2tlbiB9ID0gY2xpZW50LmNvbmZpZygpLCBzdHVkaW9VcmxEZWZpbmVkID0gdHlwZW9mIGNsaWVudC5jb25maWcoKS5zdGVnYS5zdHVkaW9VcmwgPCBcInVcIiwgc2FuaXR5RmV0Y2ggPSBhc3luYyBmdW5jdGlvbih7XG4gICAgcXVlcnksXG4gICAgcGFyYW1zID0ge30sXG4gICAgc3RlZ2E6IF9zdGVnYSxcbiAgICBwZXJzcGVjdGl2ZTogX3BlcnNwZWN0aXZlLFxuICAgIHRhZyA9IFwibmV4dC1sb2FkZXIuZmV0Y2hcIlxuICB9KSB7XG4gICAgY29uc3Qgc3RlZ2EgPSBfc3RlZ2EgPz8gKHN0ZWdhRW5hYmxlZCAmJiBzdHVkaW9VcmxEZWZpbmVkICYmIChhd2FpdCBkcmFmdE1vZGUoKSkuaXNFbmFibGVkKSwgcGVyc3BlY3RpdmUgPSBfcGVyc3BlY3RpdmUgPz8gKChhd2FpdCBkcmFmdE1vZGUoKSkuaXNFbmFibGVkID8gKGF3YWl0IGNvb2tpZXMoKSkuaGFzKHBlcnNwZWN0aXZlQ29va2llTmFtZSkgPyBzYW5pdGl6ZVBlcnNwZWN0aXZlKFxuICAgICAgKGF3YWl0IGNvb2tpZXMoKSkuZ2V0KHBlcnNwZWN0aXZlQ29va2llTmFtZSk/LnZhbHVlLFxuICAgICAgXCJwcmV2aWV3RHJhZnRzXCJcbiAgICApIDogXCJwcmV2aWV3RHJhZnRzXCIgOiBcInB1Ymxpc2hlZFwiKSwgdXNlQ2RuID0gcGVyc3BlY3RpdmUgPT09IFwicHVibGlzaGVkXCIsIHJldmFsaWRhdGUgPSBmZXRjaE9wdGlvbnM/LnJldmFsaWRhdGUgPz8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gITEgOiB2b2lkIDAsIHsgc3luY1RhZ3MgfSA9IGF3YWl0IGNsaWVudC5mZXRjaChxdWVyeSwgYXdhaXQgcGFyYW1zLCB7XG4gICAgICBmaWx0ZXJSZXNwb25zZTogITEsXG4gICAgICBwZXJzcGVjdGl2ZSxcbiAgICAgIHN0ZWdhOiAhMSxcbiAgICAgIHJldHVyblF1ZXJ5OiAhMSxcbiAgICAgIG5leHQ6IHsgcmV2YWxpZGF0ZSwgdGFnczogW1wic2FuaXR5OmZldGNoLXN5bmMtdGFnc1wiXSB9LFxuICAgICAgdXNlQ2RuLFxuICAgICAgY2FjaGVNb2RlOiB1c2VDZG4gPyBcIm5vU3RhbGVcIiA6IHZvaWQgMCxcbiAgICAgIHRhZzogW3RhZywgXCJmZXRjaC1zeW5jLXRhZ3NcIl0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIuXCIpXG4gICAgfSksIHRhZ3MgPSBbXCJzYW5pdHlcIiwgLi4uc3luY1RhZ3M/Lm1hcCgodGFnMikgPT4gYHNhbml0eToke3RhZzJ9YCkgfHwgW11dLCB7IHJlc3VsdCwgcmVzdWx0U291cmNlTWFwIH0gPSBhd2FpdCBjbGllbnQuZmV0Y2gocXVlcnksIGF3YWl0IHBhcmFtcywge1xuICAgICAgZmlsdGVyUmVzcG9uc2U6ICExLFxuICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICBzdGVnYSxcbiAgICAgIHRva2VuOiBwZXJzcGVjdGl2ZSAhPT0gXCJwdWJsaXNoZWRcIiAmJiBzZXJ2ZXJUb2tlbiA/IHNlcnZlclRva2VuIDogb3JpZ2luYWxUb2tlbixcbiAgICAgIG5leHQ6IHsgcmV2YWxpZGF0ZSwgdGFncyB9LFxuICAgICAgdXNlQ2RuLFxuICAgICAgY2FjaGVNb2RlOiB1c2VDZG4gPyBcIm5vU3RhbGVcIiA6IHZvaWQgMCxcbiAgICAgIHRhZ1xuICAgIH0pO1xuICAgIHJldHVybiB7IGRhdGE6IHJlc3VsdCwgc291cmNlTWFwOiByZXN1bHRTb3VyY2VNYXAgfHwgbnVsbCwgdGFncyB9O1xuICB9O1xuICByZXR1cm4ge1xuICAgIHNhbml0eUZldGNoLFxuICAgIFNhbml0eUxpdmU6IGFzeW5jIGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIC8vIGhhbmRsZURyYWZ0TW9kZUFjdGlvbiA9IGhhbmRsZURyYWZ0TW9kZUFjdGlvbk1pc3NpbmdcbiAgICAgICAgcmVmcmVzaE9uTW91bnQsXG4gICAgICAgIHJlZnJlc2hPbkZvY3VzLFxuICAgICAgICByZWZyZXNoT25SZWNvbm5lY3QsXG4gICAgICAgIHRhZyA9IFwibmV4dC1sb2FkZXIubGl2ZVwiLFxuICAgICAgICBvbkVycm9yXG4gICAgICB9ID0gcHJvcHMsIHtcbiAgICAgICAgcHJvamVjdElkLFxuICAgICAgICBkYXRhc2V0LFxuICAgICAgICBhcGlIb3N0LFxuICAgICAgICBhcGlWZXJzaW9uOiBfYXBpVmVyc2lvbixcbiAgICAgICAgdXNlUHJvamVjdEhvc3RuYW1lLFxuICAgICAgICByZXF1ZXN0VGFnUHJlZml4XG4gICAgICB9ID0gY2xpZW50LmNvbmZpZygpLCB7IGlzRW5hYmxlZDogaXNEcmFmdE1vZGVFbmFibGVkIH0gPSBhd2FpdCBkcmFmdE1vZGUoKTtcbiAgICAgIGxldCBhcGlWZXJzaW9uID0gX2FwaVZlcnNpb247XG4gICAgICByZXR1cm4gdHlwZW9mIGJyb3dzZXJUb2tlbiA9PSBcInN0cmluZ1wiICYmIGlzRHJhZnRNb2RlRW5hYmxlZCAmJiAoYXBpVmVyc2lvbiA9IFwidlhcIiksIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgIFNhbml0eUxpdmVDbGllbnRDb21wb25lbnQsXG4gICAgICAgIHtcbiAgICAgICAgICBwcm9qZWN0SWQsXG4gICAgICAgICAgZGF0YXNldCxcbiAgICAgICAgICBhcGlIb3N0LFxuICAgICAgICAgIGFwaVZlcnNpb24sXG4gICAgICAgICAgdXNlUHJvamVjdEhvc3RuYW1lLFxuICAgICAgICAgIHJlcXVlc3RUYWdQcmVmaXgsXG4gICAgICAgICAgdGFnLFxuICAgICAgICAgIHRva2VuOiB0eXBlb2YgYnJvd3NlclRva2VuID09IFwic3RyaW5nXCIgJiYgaXNEcmFmdE1vZGVFbmFibGVkID8gYnJvd3NlclRva2VuIDogdm9pZCAwLFxuICAgICAgICAgIGRyYWZ0TW9kZUVuYWJsZWQ6IGlzRHJhZnRNb2RlRW5hYmxlZCxcbiAgICAgICAgICBkcmFmdE1vZGVQZXJzcGVjdGl2ZTogaXNEcmFmdE1vZGVFbmFibGVkID8gKGF3YWl0IGNvb2tpZXMoKSkuaGFzKHBlcnNwZWN0aXZlQ29va2llTmFtZSkgPyBzYW5pdGl6ZVBlcnNwZWN0aXZlKFxuICAgICAgICAgICAgKGF3YWl0IGNvb2tpZXMoKSkuZ2V0KHBlcnNwZWN0aXZlQ29va2llTmFtZSk/LnZhbHVlLFxuICAgICAgICAgICAgXCJwcmV2aWV3RHJhZnRzXCJcbiAgICAgICAgICApIDogXCJwcmV2aWV3RHJhZnRzXCIgOiBcInB1Ymxpc2hlZFwiLFxuICAgICAgICAgIHJlZnJlc2hPbk1vdW50LFxuICAgICAgICAgIHJlZnJlc2hPbkZvY3VzLFxuICAgICAgICAgIHJlZnJlc2hPblJlY29ubmVjdCxcbiAgICAgICAgICBvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICBTYW5pdHlMaXZlU3RyZWFtOiBhc3luYyBmdW5jdGlvbihwcm9wcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBxdWVyeSxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBwZXJzcGVjdGl2ZTogX3BlcnNwZWN0aXZlLFxuICAgICAgICBzdGVnYTogX3N0ZWdhLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnID0gXCJuZXh0LWxvYWRlci5saXZlLXN0cmVhbS5mZXRjaFwiXG4gICAgICB9ID0gcHJvcHMsIHsgZGF0YSwgc291cmNlTWFwLCB0YWdzIH0gPSBhd2FpdCBzYW5pdHlGZXRjaCh7XG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHBlcnNwZWN0aXZlOiBfcGVyc3BlY3RpdmUsXG4gICAgICAgIHN0ZWdhOiBfc3RlZ2EsXG4gICAgICAgIHRhZ1xuICAgICAgfSksIHsgaXNFbmFibGVkOiBpc0RyYWZ0TW9kZUVuYWJsZWQgfSA9IGF3YWl0IGRyYWZ0TW9kZSgpO1xuICAgICAgaWYgKGlzRHJhZnRNb2RlRW5hYmxlZCkge1xuICAgICAgICBjb25zdCBzdGVnYSA9IF9zdGVnYSA/PyAoc3RlZ2FFbmFibGVkICYmIHN0dWRpb1VybERlZmluZWQgJiYgKGF3YWl0IGRyYWZ0TW9kZSgpKS5pc0VuYWJsZWQpLCBwZXJzcGVjdGl2ZSA9IF9wZXJzcGVjdGl2ZSA/PyAoYXdhaXQgY29va2llcygpKS5oYXMocGVyc3BlY3RpdmVDb29raWVOYW1lKSA/IHNhbml0aXplUGVyc3BlY3RpdmUoXG4gICAgICAgICAgKGF3YWl0IGNvb2tpZXMoKSkuZ2V0KHBlcnNwZWN0aXZlQ29va2llTmFtZSk/LnZhbHVlLFxuICAgICAgICAgIFwicHJldmlld0RyYWZ0c1wiXG4gICAgICAgICkgOiBcInByZXZpZXdEcmFmdHNcIiwgeyBwcm9qZWN0SWQsIGRhdGFzZXQgfSA9IGNsaWVudC5jb25maWcoKTtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgU2FuaXR5TGl2ZVN0cmVhbUNsaWVudENvbXBvbmVudCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwcm9qZWN0SWQsXG4gICAgICAgICAgICBkYXRhc2V0LFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBwYXJhbXM6IGF3YWl0IHBhcmFtcyxcbiAgICAgICAgICAgIHBlcnNwZWN0aXZlLFxuICAgICAgICAgICAgc3RlZ2EsXG4gICAgICAgICAgICBpbml0aWFsOiBjaGlsZHJlbih7IGRhdGEsIHNvdXJjZU1hcCwgdGFncyB9KSxcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkcmVuKHsgZGF0YSwgc291cmNlTWFwLCB0YWdzIH0pO1xuICAgIH1cbiAgICAvLyB2ZXJpZnlQcmV2aWV3U2VjcmV0XG4gIH07XG59XG5leHBvcnQge1xuICBkZWZpbmVMaXZlLFxuICBpc0NvcnNPcmlnaW5FcnJvclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@sanity/next-loader/dist/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@sanity/next-loader/dist/server-actions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/server-actions.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   revalidateSyncTags: () => (/* binding */ revalidateSyncTags),\n/* harmony export */   setPerspectiveCookie: () => (/* binding */ setPerspectiveCookie)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(action-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(action-browser)/./node_modules/next/dist/server/app-render/encryption.js\");\n/* harmony import */ var _chunks_es_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_chunks-es/utils.js */ \"(action-browser)/./node_modules/@sanity/next-loader/dist/_chunks-es/utils.js\");\n/* harmony import */ var next_cache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/cache.js */ \"(action-browser)/./node_modules/next/cache.js\");\n/* harmony import */ var next_headers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/headers.js */ \"(action-browser)/./node_modules/next/dist/api/headers.js\");\n/* harmony import */ var private_next_rsc_action_validate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! private-next-rsc-action-validate */ \"(action-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-validate.js\");\n/* __next_internal_action_entry_do_not_use__ {\"d0e679eb3bed5f47eac9728adb520d88c20f2294\":\"revalidateSyncTags\",\"e7d447ba6bcd4a7db5fb0574fdcc1286073bbbc9\":\"setPerspectiveCookie\"} */ \n\n\n\n\nasync function revalidateSyncTags(tags) {\n    await (0,next_cache_js__WEBPACK_IMPORTED_MODULE_2__.revalidateTag)(\"sanity:fetch-sync-tags\");\n    for (const _tag of tags){\n        const tag = `sanity:${_tag}`;\n        await (0,next_cache_js__WEBPACK_IMPORTED_MODULE_2__.revalidateTag)(tag), console.log(`<SanityLive /> revalidated tag: ${tag}`);\n    }\n}\nasync function setPerspectiveCookie(perspective) {\n    if (!(await (0,next_headers_js__WEBPACK_IMPORTED_MODULE_3__.draftMode)()).isEnabled) return;\n    const sanitizedPerspective = (0,_chunks_es_utils_js__WEBPACK_IMPORTED_MODULE_4__.sanitizePerspective)(perspective, \"previewDrafts\");\n    if (perspective !== sanitizedPerspective) throw new Error(`Invalid perspective: ${perspective}`);\n    (await (0,next_headers_js__WEBPACK_IMPORTED_MODULE_3__.cookies)()).set(_chunks_es_utils_js__WEBPACK_IMPORTED_MODULE_4__.perspectiveCookieName, Array.isArray(sanitizedPerspective) ? sanitizedPerspective.join(\",\") : sanitizedPerspective, {\n        httpOnly: !0,\n        path: \"/\",\n        secure: !0,\n        sameSite: \"none\"\n    });\n}\n //# sourceMappingURL=server-actions.js.map\n\n(0,private_next_rsc_action_validate__WEBPACK_IMPORTED_MODULE_5__.ensureServerEntryExports)([\n    revalidateSyncTags,\n    setPerspectiveCookie\n]);\n(0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(revalidateSyncTags, \"d0e679eb3bed5f47eac9728adb520d88c20f2294\", null);\n(0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(setPerspectiveCookie, \"e7d447ba6bcd4a7db5fb0574fdcc1286073bbbc9\", null);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL2Rpc3Qvc2VydmVyLWFjdGlvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxlQUFzQixtQkFBbUIsTUFBZ0M7SUFDdkUsTUFBTSw0REFBYSxDQUFDLHdCQUF3QjtJQUU1QyxXQUFXLFFBQVEsS0FBTTtRQUNqQixZQUFNLFVBQVUsSUFBSTtRQUMxQixNQUFNLDREQUFhLENBQUMsR0FBRyxHQUV2QixRQUFRLElBQUksbUNBQW1DLEdBQUcsRUFBRTtJQUFBO0FBRXhEO0FBRUEsZUFBc0IscUJBQXFCLGFBQStDO0lBQ3BGLE1BQUUsTUFBTSwwREFBUyxFQUFULEVBQWEsV0FFdkI7SUFFSSw2QkFBdUIsd0VBQW1CLENBQUMsYUFBYSxlQUFlO0lBQzdFLElBQUksZ0JBQWdCLHNCQUNsQixNQUFNLElBQUksTUFBTSx3QkFBd0IsV0FBVyxFQUFFO0tBR3JELE1BQU0sd0RBQU8sRUFBUCxFQUFXLElBQ2pCLHNFQUFxQixFQUNyQixNQUFNLFFBQVEsb0JBQW9CLElBQUkscUJBQXFCLEtBQUssR0FBRyxJQUFJLHNCQUN2RTtRQUNFLFVBQVU7UUFDVixNQUFNO1FBQ04sUUFBUTtRQUNSLFVBQVU7SUFBQTtBQUdoQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ljX2RpcmVjdG9yeS8uLi9zcmMvc2VydmVyLWFjdGlvbnMvaW5kZXgudHM/MTYzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHNlcnZlcidcblxuaW1wb3J0IHR5cGUge0NsaWVudFBlcnNwZWN0aXZlLCBTeW5jVGFnfSBmcm9tICdAc2FuaXR5L2NsaWVudCdcbmltcG9ydCB7cGVyc3BlY3RpdmVDb29raWVOYW1lfSBmcm9tICdAc2FuaXR5L3ByZXZpZXctdXJsLXNlY3JldC9jb25zdGFudHMnXG5pbXBvcnQge3JldmFsaWRhdGVUYWd9IGZyb20gJ25leHQvY2FjaGUuanMnXG5pbXBvcnQge2Nvb2tpZXMsIGRyYWZ0TW9kZX0gZnJvbSAnbmV4dC9oZWFkZXJzLmpzJ1xuaW1wb3J0IHtzYW5pdGl6ZVBlcnNwZWN0aXZlfSBmcm9tICcuLi91dGlscydcblxuLy8gZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRpc2FibGVEcmFmdE1vZGUoKTogUHJvbWlzZTx2b2lkPiB7XG4vLyAgICd1c2Ugc2VydmVyJ1xuLy8gICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoW1xuLy8gICAgIChhd2FpdCBkcmFmdE1vZGUoKSkuZGlzYWJsZSgpLFxuLy8gICAgIC8vIFNpbXVsYXRlIGEgZGVsYXkgdG8gc2hvdyB0aGUgbG9hZGluZyBzdGF0ZVxuLy8gICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKSxcbi8vICAgXSlcbi8vIH1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJldmFsaWRhdGVTeW5jVGFncyh0YWdzOiBTeW5jVGFnW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgcmV2YWxpZGF0ZVRhZygnc2FuaXR5OmZldGNoLXN5bmMtdGFncycpXG5cbiAgZm9yIChjb25zdCBfdGFnIG9mIHRhZ3MpIHtcbiAgICBjb25zdCB0YWcgPSBgc2FuaXR5OiR7X3RhZ31gXG4gICAgYXdhaXQgcmV2YWxpZGF0ZVRhZyh0YWcpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmxvZyhgPFNhbml0eUxpdmUgLz4gcmV2YWxpZGF0ZWQgdGFnOiAke3RhZ31gKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXRQZXJzcGVjdGl2ZUNvb2tpZShwZXJzcGVjdGl2ZTogQ2xpZW50UGVyc3BlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKCEoYXdhaXQgZHJhZnRNb2RlKCkpLmlzRW5hYmxlZCkge1xuICAgIC8vIHRocm93IG5ldyBFcnJvcignRHJhZnQgbW9kZSBpcyBub3QgZW5hYmxlZCwgc2V0dGluZyBwZXJzcGVjdGl2ZSBjb29raWUgaXMgbm90IGFsbG93ZWQnKVxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHNhbml0aXplZFBlcnNwZWN0aXZlID0gc2FuaXRpemVQZXJzcGVjdGl2ZShwZXJzcGVjdGl2ZSwgJ3ByZXZpZXdEcmFmdHMnKVxuICBpZiAocGVyc3BlY3RpdmUgIT09IHNhbml0aXplZFBlcnNwZWN0aXZlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBlcnNwZWN0aXZlOiAke3BlcnNwZWN0aXZlfWApXG4gIH1cblxuICA7KGF3YWl0IGNvb2tpZXMoKSkuc2V0KFxuICAgIHBlcnNwZWN0aXZlQ29va2llTmFtZSxcbiAgICBBcnJheS5pc0FycmF5KHNhbml0aXplZFBlcnNwZWN0aXZlKSA/IHNhbml0aXplZFBlcnNwZWN0aXZlLmpvaW4oJywnKSA6IHNhbml0aXplZFBlcnNwZWN0aXZlLFxuICAgIHtcbiAgICAgIGh0dHBPbmx5OiB0cnVlLFxuICAgICAgcGF0aDogJy8nLFxuICAgICAgc2VjdXJlOiB0cnVlLFxuICAgICAgc2FtZVNpdGU6ICdub25lJyxcbiAgICB9LFxuICApXG59XG5cbi8vIGV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVEcmFmdE1vZGVBY3Rpb25NaXNzaW5nKCk6IFByb21pc2U8dm9pZCB8IHN0cmluZz4ge1xuLy8gICByZXR1cm4gJ1RoZSA8U2FuaXR5TGl2ZSAvPiBjb21wb25lbnQgaXMgbWlzc2luZyB0aGUgaGFuZGxlRHJhZnRNb2RlQWN0aW9uIHByb3AnXG4vLyB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@sanity/next-loader/dist/server-actions.js\n");

/***/ })

};
;